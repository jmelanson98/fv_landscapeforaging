
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model35a4af15f285fc__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 66> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 23, column 2 to column 20)",
  25 :   " (in 'anon_model', line 24, column 2 to column 22)",
  26 :   " (in 'anon_model', line 25, column 2 to column 16)",
  27 :   " (in 'anon_model', line 27, column 2 to column 50)",
  28 :   " (in 'anon_model', line 28, column 2 to column 50)",
  29 :   " (in 'anon_model', line 32, column 2 to column 40)",
  30 :   " (in 'anon_model', line 69, column 2 to column 19)",
  31 :   " (in 'anon_model', line 76, column 4 to column 26)",
  32 :   " (in 'anon_model', line 77, column 4 to column 28)",
  33 :   " (in 'anon_model', line 80, column 11 to column 17)",
  34 :   " (in 'anon_model', line 80, column 4 to line 81, column 94)",
  35 :   " (in 'anon_model', line 83, column 11 to column 17)",
  36 :   " (in 'anon_model', line 83, column 4 to line 85, column 63)",
  37 :   " (in 'anon_model', line 88, column 4 to column 83)",
  38 :   " (in 'anon_model', line 73, column 17 to line 89, column 3)",
  39 :   " (in 'anon_model', line 73, column 2 to line 89, column 3)",
  40 :   " (in 'anon_model', line 70, column 4 to line 90, column 1)",
  41 :   " (in 'anon_model', line 36, column 2 to column 33)",
  42 :   " (in 'anon_model', line 37, column 2 to column 25)",
  43 :   " (in 'anon_model', line 38, column 2 to column 21)",
  44 :   " (in 'anon_model', line 46, column 4 to column 26)",
  45 :   " (in 'anon_model', line 47, column 4 to column 28)",
  46 :   " (in 'anon_model', line 50, column 11 to column 17)",
  47 :   " (in 'anon_model', line 50, column 4 to line 51, column 94)",
  48 :   " (in 'anon_model', line 54, column 8 to column 51)",
  49 :   " (in 'anon_model', line 53, column 28 to line 55, column 7)",
  50 :   " (in 'anon_model', line 53, column 6 to line 55, column 7)",
  51 :   " (in 'anon_model', line 52, column 23 to line 56, column 5)",
  52 :   " (in 'anon_model', line 52, column 4 to line 56, column 5)",
  53 :   " (in 'anon_model', line 59, column 11 to column 17)",
  54 :   " (in 'anon_model', line 59, column 4 to line 61, column 63)",
  55 :   " (in 'anon_model', line 64, column 4 to column 66)",
  56 :   " (in 'anon_model', line 43, column 17 to line 65, column 3)",
  57 :   " (in 'anon_model', line 43, column 2 to line 65, column 3)",
  58 :   " (in 'anon_model', line 40, column 2 to line 66, column 1)",
  59 :   " (in 'anon_model', line 4, column 2 to column 17)",
  60 :   " (in 'anon_model', line 5, column 2 to column 17)",
  61 :   " (in 'anon_model', line 6, column 2 to column 17)",
  62 :   " (in 'anon_model', line 7, column 13 to column 14)",
  63 :   " (in 'anon_model', line 7, column 2 to column 16)",
  64 :   " (in 'anon_model', line 8, column 14 to column 15)",
  65 :   " (in 'anon_model', line 8, column 2 to column 17)",
  66 :   " (in 'anon_model', line 9, column 9 to column 10)",
  67 :   " (in 'anon_model', line 9, column 2 to column 24)",
  68 :   " (in 'anon_model', line 10, column 9 to column 10)",
  69 :   " (in 'anon_model', line 10, column 2 to column 26)",
  70 :   " (in 'anon_model', line 11, column 16 to column 17)",
  71 :   " (in 'anon_model', line 11, column 2 to column 19)",
  72 :   " (in 'anon_model', line 12, column 14 to column 15)",
  73 :   " (in 'anon_model', line 12, column 2 to column 17)",
  74 :   " (in 'anon_model', line 13, column 12 to column 13)",
  75 :   " (in 'anon_model', line 13, column 2 to column 15)",
  76 :   " (in 'anon_model', line 14, column 9 to column 10)",
  77 :   " (in 'anon_model', line 14, column 2 to column 15)",
  78 :   " (in 'anon_model', line 15, column 2 to column 15)",
  79 :   " (in 'anon_model', line 16, column 2 to column 15)",
  80 :   " (in 'anon_model', line 17, column 2 to column 15)",
  81 :   " (in 'anon_model', line 18, column 2 to column 15)",
  82 :   " (in 'anon_model', line 19, column 2 to column 12)",
  83 :   " (in 'anon_model', line 20, column 2 to column 17)",
  84 :   " (in 'anon_model', line 25, column 9 to column 10)",
  85 :   " (in 'anon_model', line 27, column 39 to column 40)",
  86 :   " (in 'anon_model', line 28, column 39 to column 40)",
  87 :   " (in 'anon_model', line 32, column 9 to column 10)",
  88 :   " (in 'anon_model', line 69, column 9 to column 10)"};
  89 : class model35a4af15f285fc_ final : public model_base_crtp<model35a4af15f285fc_> {
  90 : private:
  91 :   int C;
  92 :   int K;
  93 :   int O;
  94 :   std::vector<int> starts;
  95 :   std::vector<int> lengths;
  96 :   Eigen::Matrix<double,-1,-1> trap_pos_data__;
  97 :   Eigen::Matrix<double,-1,1> sample_effort_data__;
  98 :   std::vector<int> colony_id;
  99 :   std::vector<int> trap_id;
 100 :   std::vector<int> y_obs;
 101 :   Eigen::Matrix<double,-1,1> yn_data__;
 102 :   double lower_x;
 103 :   double upper_x;
 104 :   double lower_y;
 105 :   double upper_y;
 106 :   double Rmax;
 107 :   double steepness;
 108 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap_pos{nullptr, 0, 0};
 109 :   Eigen::Map<Eigen::Matrix<double,-1,1>> sample_effort{nullptr, 0};
 110 :   Eigen::Map<Eigen::Matrix<double,-1,1>> yn{nullptr, 0};
 111 : public:
 112 :   ~model35a4af15f285fc_() {}
 113 :   model35a4af15f285fc_(stan::io::var_context& context__, unsigned int
 114 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
 115 :       : model_base_crtp(0) {
 116 :     int current_statement__ = 0;
 117 :     using local_scalar_t__ = double;
 118 :     boost::ecuyer1988 base_rng__ =
 119 :       stan::services::util::create_rng(random_seed__, 0);
 120 :     // suppress unused var warning
 121 :     (void) base_rng__;
 122 :     static constexpr const char* function__ =
 123 :       "model35a4af15f285fc__namespace::model35a4af15f285fc_";
 124 :     // suppress unused var warning
 125 :     (void) function__;
 126 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 127 :     // suppress unused var warning
 128 :     (void) DUMMY_VAR__;
 129 :     try {
 130 :       int pos__ = std::numeric_limits<int>::min();
 131 :       pos__ = 1;
 132 :       current_statement__ = 36;
 133 :       context__.validate_dims("data initialization", "C", "int",
 134 :         std::vector<size_t>{});
 135 :       C = std::numeric_limits<int>::min();
 136 :       current_statement__ = 36;
 137 :       C = context__.vals_i("C")[(1 - 1)];
 138 :       current_statement__ = 36;
 139 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 140 :       current_statement__ = 37;
 141 :       context__.validate_dims("data initialization", "K", "int",
 142 :         std::vector<size_t>{});
 143 :       K = std::numeric_limits<int>::min();
 144 :       current_statement__ = 37;
 145 :       K = context__.vals_i("K")[(1 - 1)];
 146 :       current_statement__ = 37;
 147 :       stan::math::check_greater_or_equal(function__, "K", K, 1);
 148 :       current_statement__ = 38;
 149 :       context__.validate_dims("data initialization", "O", "int",
 150 :         std::vector<size_t>{});
 151 :       O = std::numeric_limits<int>::min();
 152 :       current_statement__ = 38;
 153 :       O = context__.vals_i("O")[(1 - 1)];
 154 :       current_statement__ = 38;
 155 :       stan::math::check_greater_or_equal(function__, "O", O, 1);
 156 :       current_statement__ = 39;
 157 :       stan::math::validate_non_negative_index("starts", "C", C);
 158 :       current_statement__ = 40;
 159 :       context__.validate_dims("data initialization", "starts", "int",
 160 :         std::vector<size_t>{static_cast<size_t>(C)});
 161 :       starts = std::vector<int>(C, std::numeric_limits<int>::min());
 162 :       current_statement__ = 40;
 163 :       starts = context__.vals_i("starts");
 164 :       current_statement__ = 41;
 165 :       stan::math::validate_non_negative_index("lengths", "C", C);
 166 :       current_statement__ = 42;
 167 :       context__.validate_dims("data initialization", "lengths", "int",
 168 :         std::vector<size_t>{static_cast<size_t>(C)});
 169 :       lengths = std::vector<int>(C, std::numeric_limits<int>::min());
 170 :       current_statement__ = 42;
 171 :       lengths = context__.vals_i("lengths");
 172 :       current_statement__ = 43;
 173 :       stan::math::validate_non_negative_index("trap_pos", "O", O);
 174 :       current_statement__ = 44;
 175 :       context__.validate_dims("data initialization", "trap_pos", "double",
 176 :         std::vector<size_t>{static_cast<size_t>(O), static_cast<size_t>(2)});
 177 :       trap_pos_data__ = Eigen::Matrix<double,-1,-1>::Constant(O, 2,
 178 :                           std::numeric_limits<double>::quiet_NaN());
 179 :       new (&trap_pos)
 180 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_pos_data__.data(), O, 2);
 181 :       {
 182 :         std::vector<local_scalar_t__> trap_pos_flat__;
 183 :         current_statement__ = 44;
 184 :         trap_pos_flat__ = context__.vals_r("trap_pos");
 185 :         current_statement__ = 44;
 186 :         pos__ = 1;
 187 :         current_statement__ = 44;
 188 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 189 :           current_statement__ = 44;
 190 :           for (int sym2__ = 1; sym2__ <= O; ++sym2__) {
 191 :             current_statement__ = 44;
 192 :             stan::model::assign(trap_pos, trap_pos_flat__[(pos__ - 1)],
 193 :               "assigning variable trap_pos", stan::model::index_uni(sym2__),
 194 :               stan::model::index_uni(sym1__));
 195 :             current_statement__ = 44;
 196 :             pos__ = (pos__ + 1);
 197 :           }
 198 :         }
 199 :       }
 200 :       current_statement__ = 45;
 201 :       stan::math::validate_non_negative_index("sample_effort", "O", O);
 202 :       current_statement__ = 46;
 203 :       context__.validate_dims("data initialization", "sample_effort",
 204 :         "double", std::vector<size_t>{static_cast<size_t>(O)});
 205 :       sample_effort_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 206 :                                std::numeric_limits<double>::quiet_NaN());
 207 :       new (&sample_effort)
 208 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(sample_effort_data__.data(),
 209 :         O);
 210 :       {
 211 :         std::vector<local_scalar_t__> sample_effort_flat__;
 212 :         current_statement__ = 46;
 213 :         sample_effort_flat__ = context__.vals_r("sample_effort");
 214 :         current_statement__ = 46;
 215 :         pos__ = 1;
 216 :         current_statement__ = 46;
 217 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 218 :           current_statement__ = 46;
 219 :           stan::model::assign(sample_effort, sample_effort_flat__[(pos__ -
 220 :             1)], "assigning variable sample_effort",
 221 :             stan::model::index_uni(sym1__));
 222 :           current_statement__ = 46;
 223 :           pos__ = (pos__ + 1);
 224 :         }
 225 :       }
 226 :       current_statement__ = 47;
 227 :       stan::math::validate_non_negative_index("colony_id", "O", O);
 228 :       current_statement__ = 48;
 229 :       context__.validate_dims("data initialization", "colony_id", "int",
 230 :         std::vector<size_t>{static_cast<size_t>(O)});
 231 :       colony_id = std::vector<int>(O, std::numeric_limits<int>::min());
 232 :       current_statement__ = 48;
 233 :       colony_id = context__.vals_i("colony_id");
 234 :       current_statement__ = 49;
 235 :       stan::math::validate_non_negative_index("trap_id", "O", O);
 236 :       current_statement__ = 50;
 237 :       context__.validate_dims("data initialization", "trap_id", "int",
 238 :         std::vector<size_t>{static_cast<size_t>(O)});
 239 :       trap_id = std::vector<int>(O, std::numeric_limits<int>::min());
 240 :       current_statement__ = 50;
 241 :       trap_id = context__.vals_i("trap_id");
 242 :       current_statement__ = 51;
 243 :       stan::math::validate_non_negative_index("y_obs", "O", O);
 244 :       current_statement__ = 52;
 245 :       context__.validate_dims("data initialization", "y_obs", "int",
 246 :         std::vector<size_t>{static_cast<size_t>(O)});
 247 :       y_obs = std::vector<int>(O, std::numeric_limits<int>::min());
 248 :       current_statement__ = 52;
 249 :       y_obs = context__.vals_i("y_obs");
 250 :       current_statement__ = 53;
 251 :       stan::math::validate_non_negative_index("yn", "O", O);
 252 :       current_statement__ = 54;
 253 :       context__.validate_dims("data initialization", "yn", "double",
 254 :         std::vector<size_t>{static_cast<size_t>(O)});
 255 :       yn_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 256 :                     std::numeric_limits<double>::quiet_NaN());
 257 :       new (&yn) Eigen::Map<Eigen::Matrix<double,-1,1>>(yn_data__.data(), O);
 258 :       {
 259 :         std::vector<local_scalar_t__> yn_flat__;
 260 :         current_statement__ = 54;
 261 :         yn_flat__ = context__.vals_r("yn");
 262 :         current_statement__ = 54;
 263 :         pos__ = 1;
 264 :         current_statement__ = 54;
 265 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 266 :           current_statement__ = 54;
 267 :           stan::model::assign(yn, yn_flat__[(pos__ - 1)],
 268 :             "assigning variable yn", stan::model::index_uni(sym1__));
 269 :           current_statement__ = 54;
 270 :           pos__ = (pos__ + 1);
 271 :         }
 272 :       }
 273 :       current_statement__ = 55;
 274 :       context__.validate_dims("data initialization", "lower_x", "double",
 275 :         std::vector<size_t>{});
 276 :       lower_x = std::numeric_limits<double>::quiet_NaN();
 277 :       current_statement__ = 55;
 278 :       lower_x = context__.vals_r("lower_x")[(1 - 1)];
 279 :       current_statement__ = 56;
 280 :       context__.validate_dims("data initialization", "upper_x", "double",
 281 :         std::vector<size_t>{});
 282 :       upper_x = std::numeric_limits<double>::quiet_NaN();
 283 :       current_statement__ = 56;
 284 :       upper_x = context__.vals_r("upper_x")[(1 - 1)];
 285 :       current_statement__ = 57;
 286 :       context__.validate_dims("data initialization", "lower_y", "double",
 287 :         std::vector<size_t>{});
 288 :       lower_y = std::numeric_limits<double>::quiet_NaN();
 289 :       current_statement__ = 57;
 290 :       lower_y = context__.vals_r("lower_y")[(1 - 1)];
 291 :       current_statement__ = 58;
 292 :       context__.validate_dims("data initialization", "upper_y", "double",
 293 :         std::vector<size_t>{});
 294 :       upper_y = std::numeric_limits<double>::quiet_NaN();
 295 :       current_statement__ = 58;
 296 :       upper_y = context__.vals_r("upper_y")[(1 - 1)];
 297 :       current_statement__ = 59;
 298 :       context__.validate_dims("data initialization", "Rmax", "double",
 299 :         std::vector<size_t>{});
 300 :       Rmax = std::numeric_limits<double>::quiet_NaN();
 301 :       current_statement__ = 59;
 302 :       Rmax = context__.vals_r("Rmax")[(1 - 1)];
 303 :       current_statement__ = 60;
 304 :       context__.validate_dims("data initialization", "steepness", "double",
 305 :         std::vector<size_t>{});
 306 :       steepness = std::numeric_limits<double>::quiet_NaN();
 307 :       current_statement__ = 60;
 308 :       steepness = context__.vals_r("steepness")[(1 - 1)];
 309 :       current_statement__ = 61;
 310 :       stan::math::validate_non_negative_index("eps", "K", K);
 311 :       current_statement__ = 62;
 312 :       stan::math::validate_non_negative_index("delta_x", "C", C);
 313 :       current_statement__ = 63;
 314 :       stan::math::validate_non_negative_index("delta_y", "C", C);
 315 :       current_statement__ = 64;
 316 :       stan::math::validate_non_negative_index("eps_scale", "K", K);
 317 :       current_statement__ = 65;
 318 :       stan::math::validate_non_negative_index("loglik", "C", C);
 319 :     } catch (const std::exception& e) {
 320 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 321 :     }
 322 :     num_params_r__ = 1 + 1 + K + C + C;
 323 :   }
 324 :   inline std::string model_name() const final {
 325 :     return "model35a4af15f285fc_";
 326 :   }
 327 :   inline std::vector<std::string> model_compile_info() const noexcept {
 328 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 329 :              "stancflags = --"};
 330 :   }
 331 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 332 :             stan::require_vector_like_t<VecR>* = nullptr,
 333 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 334 :   inline stan::scalar_type_t<VecR>
 335 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 336 :                 pstream__ = nullptr) const {
 337 :     using T__ = stan::scalar_type_t<VecR>;
 338 :     using local_scalar_t__ = T__;
 339 :     T__ lp__(0.0);
 340 :     stan::math::accumulator<T__> lp_accum__;
 341 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 342 :     int current_statement__ = 0;
 343 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 344 :     // suppress unused var warning
 345 :     (void) DUMMY_VAR__;
 346 :     static constexpr const char* function__ =
 347 :       "model35a4af15f285fc__namespace::log_prob";
 348 :     // suppress unused var warning
 349 :     (void) function__;
 350 :     try {
 351 :       local_scalar_t__ rho = DUMMY_VAR__;
 352 :       current_statement__ = 1;
 353 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 354 :               lp__);
 355 :       local_scalar_t__ sigma = DUMMY_VAR__;
 356 :       current_statement__ = 2;
 357 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 358 :                 jacobian__>(0, lp__);
 359 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 360 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 361 :       current_statement__ = 3;
 362 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 363 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 364 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 365 :       current_statement__ = 4;
 366 :       delta_x = in__.template read_constrain_lub<
 367 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_x,
 368 :                   upper_x, lp__, C);
 369 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 370 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 371 :       current_statement__ = 5;
 372 :       delta_y = in__.template read_constrain_lub<
 373 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_y,
 374 :                   upper_y, lp__, C);
 375 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 376 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 377 :       current_statement__ = 6;
 378 :       stan::model::assign(eps_scale,
 379 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 380 :         "assigning variable eps_scale");
 381 :       {
 382 :         current_statement__ = 18;
 383 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho,
 384 :                          stan::math::log(0.5), 0.5));
 385 :         current_statement__ = 19;
 386 :         lp_accum__.add(stan::math::exponential_lpdf<propto__>(sigma, 1));
 387 :         current_statement__ = 20;
 388 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 389 :         {
 390 :           current_statement__ = 34;
 391 :           for (int c = 1; c <= C; ++c) {
 392 :             int start = std::numeric_limits<int>::min();
 393 :             current_statement__ = 21;
 394 :             start = stan::model::rvalue(starts, "starts",
 395 :                       stan::model::index_uni(c));
 396 :             int length = std::numeric_limits<int>::min();
 397 :             current_statement__ = 22;
 398 :             length = stan::model::rvalue(lengths, "lengths",
 399 :                        stan::model::index_uni(c));
 400 :             current_statement__ = 23;
 401 :             stan::math::validate_non_negative_index("dis", "length", length);
 402 :             Eigen::Matrix<local_scalar_t__,-1,1> dis =
 403 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 404 :                 DUMMY_VAR__);
 405 :             current_statement__ = 24;
 406 :             stan::model::assign(dis,
 407 :               stan::math::sqrt(
 408 :                 stan::math::add(
 409 :                   stan::math::square(
 410 :                     stan::math::subtract(
 411 :                       stan::model::rvalue(delta_x, "delta_x",
 412 :                         stan::model::index_uni(
 413 :                           stan::model::rvalue(colony_id, "colony_id",
 414 :                             stan::model::index_uni(start)))),
 415 :                       stan::model::rvalue(trap_pos, "trap_pos",
 416 :                         stan::model::index_min_max(start, ((start + length) -
 417 :                           1)), stan::model::index_uni(1)))),
 418 :                   stan::math::square(
 419 :                     stan::math::subtract(
 420 :                       stan::model::rvalue(delta_y, "delta_y",
 421 :                         stan::model::index_uni(
 422 :                           stan::model::rvalue(colony_id, "colony_id",
 423 :                             stan::model::index_uni(start)))),
 424 :                       stan::model::rvalue(trap_pos, "trap_pos",
 425 :                         stan::model::index_min_max(start, ((start + length) -
 426 :                           1)), stan::model::index_uni(2)))))),
 427 :               "assigning variable dis");
 428 :             current_statement__ = 29;
 429 :             for (int l = 1; l <= length; ++l) {
 430 :               current_statement__ = 27;
 431 :               if (stan::math::logical_eq(
 432 :                     stan::model::rvalue(yn, "yn",
 433 :                       stan::model::index_uni(((start + l) - 1))), 1)) {
 434 :                 current_statement__ = 25;
 435 :                 lp_accum__.add(stan::math::minus(
 436 :                                  stan::math::log1p_exp(
 437 :                                    stan::math::multiply(
 438 :                                      stan::math::subtract(dis, Rmax),
 439 :                                      steepness))));
 440 :               }
 441 :             }
 442 :             current_statement__ = 30;
 443 :             stan::math::validate_non_negative_index("lambda_ik", "length",
 444 :               length);
 445 :             Eigen::Matrix<local_scalar_t__,-1,1> lambda_ik =
 446 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 447 :                 DUMMY_VAR__);
 448 :             current_statement__ = 31;
 449 :             stan::model::assign(lambda_ik,
 450 :               stan::math::add(
 451 :                 stan::math::add(
 452 :                   stan::math::multiply(-0.5,
 453 :                     stan::math::pow(stan::math::divide(dis, rho), 2)),
 454 :                   stan::model::rvalue(eps_scale, "eps_scale",
 455 :                     stan::model::index_multi(
 456 :                       stan::model::rvalue(trap_id, "trap_id",
 457 :                         stan::model::index_min_max(start, ((start + length) -
 458 :                           1)))))),
 459 :                 stan::math::log(
 460 :                   stan::model::rvalue(sample_effort, "sample_effort",
 461 :                     stan::model::index_min_max(start, ((start + length) - 1))))),
 462 :               "assigning variable lambda_ik");
 463 :             current_statement__ = 32;
 464 :             lp_accum__.add(stan::math::multinomial_lpmf<propto__>(
 465 :                              stan::model::rvalue(y_obs, "y_obs",
 466 :                                stan::model::index_min_max(start, ((start +
 467 :                                  length) - 1))),
 468 :                              stan::math::softmax(lambda_ik)));
 469 :           }
 470 :         }
 471 :       }
 472 :     } catch (const std::exception& e) {
 473 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 474 :     }
 475 :     lp_accum__.add(lp__);
 476 :     return lp_accum__.sum();
 477 :   }
 478 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 479 :             stan::require_vector_like_vt<std::is_floating_point,
 480 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 481 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 482 :             VecVar>* = nullptr>
 483 :   inline void
 484 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 485 :                    VecVar& vars__, const bool
 486 :                    emit_transformed_parameters__ = true, const bool
 487 :                    emit_generated_quantities__ = true, std::ostream*
 488 :                    pstream__ = nullptr) const {
 489 :     using local_scalar_t__ = double;
 490 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 491 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 492 :     static constexpr bool propto__ = true;
 493 :     // suppress unused var warning
 494 :     (void) propto__;
 495 :     double lp__ = 0.0;
 496 :     // suppress unused var warning
 497 :     (void) lp__;
 498 :     int current_statement__ = 0;
 499 :     stan::math::accumulator<double> lp_accum__;
 500 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 501 :     // suppress unused var warning
 502 :     (void) DUMMY_VAR__;
 503 :     constexpr bool jacobian__ = false;
 504 :     static constexpr const char* function__ =
 505 :       "model35a4af15f285fc__namespace::write_array";
 506 :     // suppress unused var warning
 507 :     (void) function__;
 508 :     try {
 509 :       double rho = std::numeric_limits<double>::quiet_NaN();
 510 :       current_statement__ = 1;
 511 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 512 :               lp__);
 513 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 514 :       current_statement__ = 2;
 515 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 516 :                 jacobian__>(0, lp__);
 517 :       Eigen::Matrix<double,-1,1> eps =
 518 :         Eigen::Matrix<double,-1,1>::Constant(K,
 519 :           std::numeric_limits<double>::quiet_NaN());
 520 :       current_statement__ = 3;
 521 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 522 :       Eigen::Matrix<double,-1,1> delta_x =
 523 :         Eigen::Matrix<double,-1,1>::Constant(C,
 524 :           std::numeric_limits<double>::quiet_NaN());
 525 :       current_statement__ = 4;
 526 :       delta_x = in__.template read_constrain_lub<
 527 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_x,
 528 :                   upper_x, lp__, C);
 529 :       Eigen::Matrix<double,-1,1> delta_y =
 530 :         Eigen::Matrix<double,-1,1>::Constant(C,
 531 :           std::numeric_limits<double>::quiet_NaN());
 532 :       current_statement__ = 5;
 533 :       delta_y = in__.template read_constrain_lub<
 534 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_y,
 535 :                   upper_y, lp__, C);
 536 :       Eigen::Matrix<double,-1,1> eps_scale =
 537 :         Eigen::Matrix<double,-1,1>::Constant(K,
 538 :           std::numeric_limits<double>::quiet_NaN());
 539 :       out__.write(rho);
 540 :       out__.write(sigma);
 541 :       out__.write(eps);
 542 :       out__.write(delta_x);
 543 :       out__.write(delta_y);
 544 :       if (stan::math::logical_negation(
 545 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 546 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 547 :         return ;
 548 :       }
 549 :       current_statement__ = 6;
 550 :       stan::model::assign(eps_scale,
 551 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 552 :         "assigning variable eps_scale");
 553 :       if (emit_transformed_parameters__) {
 554 :         out__.write(eps_scale);
 555 :       }
 556 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 557 :         return ;
 558 :       }
 559 :       Eigen::Matrix<double,-1,1> loglik =
 560 :         Eigen::Matrix<double,-1,1>::Constant(C,
 561 :           std::numeric_limits<double>::quiet_NaN());
 562 :       {
 563 :         current_statement__ = 16;
 564 :         for (int c = 1; c <= C; ++c) {
 565 :           int start = std::numeric_limits<int>::min();
 566 :           current_statement__ = 8;
 567 :           start = stan::model::rvalue(starts, "starts",
 568 :                     stan::model::index_uni(c));
 569 :           int length = std::numeric_limits<int>::min();
 570 :           current_statement__ = 9;
 571 :           length = stan::model::rvalue(lengths, "lengths",
 572 :                      stan::model::index_uni(c));
 573 :           current_statement__ = 10;
 574 :           stan::math::validate_non_negative_index("dis", "length", length);
 575 :           Eigen::Matrix<double,-1,1> dis =
 576 :             Eigen::Matrix<double,-1,1>::Constant(length,
 577 :               std::numeric_limits<double>::quiet_NaN());
 578 :           current_statement__ = 11;
 579 :           stan::model::assign(dis,
 580 :             stan::math::sqrt(
 581 :               stan::math::add(
 582 :                 stan::math::square(
 583 :                   stan::math::subtract(
 584 :                     stan::model::rvalue(delta_x, "delta_x",
 585 :                       stan::model::index_uni(
 586 :                         stan::model::rvalue(colony_id, "colony_id",
 587 :                           stan::model::index_uni(start)))),
 588 :                     stan::model::rvalue(trap_pos, "trap_pos",
 589 :                       stan::model::index_min_max(start, ((start + length) -
 590 :                         1)), stan::model::index_uni(1)))),
 591 :                 stan::math::square(
 592 :                   stan::math::subtract(
 593 :                     stan::model::rvalue(delta_y, "delta_y",
 594 :                       stan::model::index_uni(
 595 :                         stan::model::rvalue(colony_id, "colony_id",
 596 :                           stan::model::index_uni(start)))),
 597 :                     stan::model::rvalue(trap_pos, "trap_pos",
 598 :                       stan::model::index_min_max(start, ((start + length) -
 599 :                         1)), stan::model::index_uni(2)))))),
 600 :             "assigning variable dis");
 601 :           current_statement__ = 12;
 602 :           stan::math::validate_non_negative_index("lambda_ik", "length",
 603 :             length);
 604 :           Eigen::Matrix<double,-1,1> lambda_ik =
 605 :             Eigen::Matrix<double,-1,1>::Constant(length,
 606 :               std::numeric_limits<double>::quiet_NaN());
 607 :           current_statement__ = 13;
 608 :           stan::model::assign(lambda_ik,
 609 :             stan::math::add(
 610 :               stan::math::add(
 611 :                 stan::math::multiply(-0.5,
 612 :                   stan::math::pow(stan::math::divide(dis, rho), 2)),
 613 :                 stan::model::rvalue(eps_scale, "eps_scale",
 614 :                   stan::model::index_multi(
 615 :                     stan::model::rvalue(trap_id, "trap_id",
 616 :                       stan::model::index_min_max(start, ((start + length) -
 617 :                         1)))))),
 618 :               stan::math::log(
 619 :                 stan::model::rvalue(sample_effort, "sample_effort",
 620 :                   stan::model::index_min_max(start, ((start + length) - 1))))),
 621 :             "assigning variable lambda_ik");
 622 :           current_statement__ = 14;
 623 :           stan::model::assign(loglik,
 624 :             stan::math::multinomial_lpmf<false>(
 625 :               stan::model::rvalue(y_obs, "y_obs",
 626 :                 stan::model::index_min_max(start, ((start + length) - 1))),
 627 :               stan::math::softmax(lambda_ik)), "assigning variable loglik",
 628 :             stan::model::index_uni(c));
 629 :         }
 630 :       }
 631 :       out__.write(loglik);
 632 :     } catch (const std::exception& e) {
 633 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 634 :     }
 635 :   }
 636 :   template <typename VecVar, typename VecI,
 637 :             stan::require_vector_t<VecVar>* = nullptr,
 638 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 639 :   inline void
 640 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 641 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 642 :     using local_scalar_t__ = double;
 643 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 644 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 645 :     int current_statement__ = 0;
 646 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 647 :     // suppress unused var warning
 648 :     (void) DUMMY_VAR__;
 649 :     try {
 650 :       int pos__ = std::numeric_limits<int>::min();
 651 :       pos__ = 1;
 652 :       local_scalar_t__ rho = DUMMY_VAR__;
 653 :       current_statement__ = 1;
 654 :       rho = in__.read<local_scalar_t__>();
 655 :       out__.write_free_lb(0, rho);
 656 :       local_scalar_t__ sigma = DUMMY_VAR__;
 657 :       current_statement__ = 2;
 658 :       sigma = in__.read<local_scalar_t__>();
 659 :       out__.write_free_lb(0, sigma);
 660 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 661 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 662 :       current_statement__ = 3;
 663 :       stan::model::assign(eps,
 664 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 665 :         "assigning variable eps");
 666 :       out__.write(eps);
 667 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 668 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 669 :       current_statement__ = 4;
 670 :       stan::model::assign(delta_x,
 671 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 672 :         "assigning variable delta_x");
 673 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 674 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 675 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 676 :       current_statement__ = 5;
 677 :       stan::model::assign(delta_y,
 678 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 679 :         "assigning variable delta_y");
 680 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 681 :     } catch (const std::exception& e) {
 682 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 683 :     }
 684 :   }
 685 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 686 :   inline void
 687 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 688 :                        vars__, std::ostream* pstream__ = nullptr) const {
 689 :     using local_scalar_t__ = double;
 690 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 691 :     int current_statement__ = 0;
 692 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 693 :     // suppress unused var warning
 694 :     (void) DUMMY_VAR__;
 695 :     try {
 696 :       current_statement__ = 1;
 697 :       context__.validate_dims("parameter initialization", "rho", "double",
 698 :         std::vector<size_t>{});
 699 :       current_statement__ = 2;
 700 :       context__.validate_dims("parameter initialization", "sigma", "double",
 701 :         std::vector<size_t>{});
 702 :       current_statement__ = 3;
 703 :       context__.validate_dims("parameter initialization", "eps", "double",
 704 :         std::vector<size_t>{static_cast<size_t>(K)});
 705 :       current_statement__ = 4;
 706 :       context__.validate_dims("parameter initialization", "delta_x",
 707 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 708 :       current_statement__ = 5;
 709 :       context__.validate_dims("parameter initialization", "delta_y",
 710 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 711 :       int pos__ = std::numeric_limits<int>::min();
 712 :       pos__ = 1;
 713 :       local_scalar_t__ rho = DUMMY_VAR__;
 714 :       current_statement__ = 1;
 715 :       rho = context__.vals_r("rho")[(1 - 1)];
 716 :       out__.write_free_lb(0, rho);
 717 :       local_scalar_t__ sigma = DUMMY_VAR__;
 718 :       current_statement__ = 2;
 719 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 720 :       out__.write_free_lb(0, sigma);
 721 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 722 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 723 :       {
 724 :         std::vector<local_scalar_t__> eps_flat__;
 725 :         current_statement__ = 3;
 726 :         eps_flat__ = context__.vals_r("eps");
 727 :         current_statement__ = 3;
 728 :         pos__ = 1;
 729 :         current_statement__ = 3;
 730 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 731 :           current_statement__ = 3;
 732 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 733 :             "assigning variable eps", stan::model::index_uni(sym1__));
 734 :           current_statement__ = 3;
 735 :           pos__ = (pos__ + 1);
 736 :         }
 737 :       }
 738 :       out__.write(eps);
 739 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 740 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 741 :       {
 742 :         std::vector<local_scalar_t__> delta_x_flat__;
 743 :         current_statement__ = 4;
 744 :         delta_x_flat__ = context__.vals_r("delta_x");
 745 :         current_statement__ = 4;
 746 :         pos__ = 1;
 747 :         current_statement__ = 4;
 748 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 749 :           current_statement__ = 4;
 750 :           stan::model::assign(delta_x, delta_x_flat__[(pos__ - 1)],
 751 :             "assigning variable delta_x", stan::model::index_uni(sym1__));
 752 :           current_statement__ = 4;
 753 :           pos__ = (pos__ + 1);
 754 :         }
 755 :       }
 756 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 757 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 758 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 759 :       {
 760 :         std::vector<local_scalar_t__> delta_y_flat__;
 761 :         current_statement__ = 5;
 762 :         delta_y_flat__ = context__.vals_r("delta_y");
 763 :         current_statement__ = 5;
 764 :         pos__ = 1;
 765 :         current_statement__ = 5;
 766 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 767 :           current_statement__ = 5;
 768 :           stan::model::assign(delta_y, delta_y_flat__[(pos__ - 1)],
 769 :             "assigning variable delta_y", stan::model::index_uni(sym1__));
 770 :           current_statement__ = 5;
 771 :           pos__ = (pos__ + 1);
 772 :         }
 773 :       }
 774 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 775 :     } catch (const std::exception& e) {
 776 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 777 :     }
 778 :   }
 779 :   inline void
 780 :   get_param_names(std::vector<std::string>& names__, const bool
 781 :                   emit_transformed_parameters__ = true, const bool
 782 :                   emit_generated_quantities__ = true) const {
 783 :     names__ = std::vector<std::string>{"rho", "sigma", "eps", "delta_x",
 784 :                 "delta_y"};
 785 :     if (emit_transformed_parameters__) {
 786 :       std::vector<std::string> temp{"eps_scale"};
 787 :       names__.reserve(names__.size() + temp.size());
 788 :       names__.insert(names__.end(), temp.begin(), temp.end());
 789 :     }
 790 :     if (emit_generated_quantities__) {
 791 :       std::vector<std::string> temp{"loglik"};
 792 :       names__.reserve(names__.size() + temp.size());
 793 :       names__.insert(names__.end(), temp.begin(), temp.end());
 794 :     }
 795 :   }
 796 :   inline void
 797 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 798 :            emit_transformed_parameters__ = true, const bool
 799 :            emit_generated_quantities__ = true) const {
 800 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 801 :                 std::vector<size_t>{},
 802 :                 std::vector<size_t>{static_cast<size_t>(K)},
 803 :                 std::vector<size_t>{static_cast<size_t>(C)},
 804 :                 std::vector<size_t>{static_cast<size_t>(C)}};
 805 :     if (emit_transformed_parameters__) {
 806 :       std::vector<std::vector<size_t>>
 807 :         temp{std::vector<size_t>{static_cast<size_t>(K)}};
 808 :       dimss__.reserve(dimss__.size() + temp.size());
 809 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 810 :     }
 811 :     if (emit_generated_quantities__) {
 812 :       std::vector<std::vector<size_t>>
 813 :         temp{std::vector<size_t>{static_cast<size_t>(C)}};
 814 :       dimss__.reserve(dimss__.size() + temp.size());
 815 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 816 :     }
 817 :   }
 818 :   inline void
 819 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 820 :                           emit_transformed_parameters__ = true, bool
 821 :                           emit_generated_quantities__ = true) const final {
 822 :     param_names__.emplace_back(std::string() + "rho");
 823 :     param_names__.emplace_back(std::string() + "sigma");
 824 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 825 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 826 :         std::to_string(sym1__));
 827 :     }
 828 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 829 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 830 :         std::to_string(sym1__));
 831 :     }
 832 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 833 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 834 :         std::to_string(sym1__));
 835 :     }
 836 :     if (emit_transformed_parameters__) {
 837 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 838 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 839 :           std::to_string(sym1__));
 840 :       }
 841 :     }
 842 :     if (emit_generated_quantities__) {
 843 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 844 :         param_names__.emplace_back(std::string() + "loglik" + '.' +
 845 :           std::to_string(sym1__));
 846 :       }
 847 :     }
 848 :   }
 849 :   inline void
 850 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 851 :                             emit_transformed_parameters__ = true, bool
 852 :                             emit_generated_quantities__ = true) const final {
 853 :     param_names__.emplace_back(std::string() + "rho");
 854 :     param_names__.emplace_back(std::string() + "sigma");
 855 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 856 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 857 :         std::to_string(sym1__));
 858 :     }
 859 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 860 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 861 :         std::to_string(sym1__));
 862 :     }
 863 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 864 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 865 :         std::to_string(sym1__));
 866 :     }
 867 :     if (emit_transformed_parameters__) {
 868 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 869 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 870 :           std::to_string(sym1__));
 871 :       }
 872 :     }
 873 :     if (emit_generated_quantities__) {
 874 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 875 :         param_names__.emplace_back(std::string() + "loglik" + '.' +
 876 :           std::to_string(sym1__));
 877 :       }
 878 :     }
 879 :   }
 880 :   inline std::string get_constrained_sizedtypes() const {
 881 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"},{\"name\":\"loglik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
 882 :   }
 883 :   inline std::string get_unconstrained_sizedtypes() const {
 884 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"},{\"name\":\"loglik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
 885 :   }
 886 :   // Begin method overload boilerplate
 887 :   template <typename RNG> inline void
 888 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 889 :               Eigen::Matrix<double,-1,1>& vars, const bool
 890 :               emit_transformed_parameters = true, const bool
 891 :               emit_generated_quantities = true, std::ostream*
 892 :               pstream = nullptr) const {
 893 :     const size_t num_params__ = ((((1 + 1) + K) + C) + C);
 894 :     const size_t num_transformed = emit_transformed_parameters * (K);
 895 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
 896 :     const size_t num_to_write = num_params__ + num_transformed +
 897 :       num_gen_quantities;
 898 :     std::vector<int> params_i;
 899 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 900 :              std::numeric_limits<double>::quiet_NaN());
 901 :     write_array_impl(base_rng, params_r, params_i, vars,
 902 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 903 :   }
 904 :   template <typename RNG> inline void
 905 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 906 :               params_i, std::vector<double>& vars, bool
 907 :               emit_transformed_parameters = true, bool
 908 :               emit_generated_quantities = true, std::ostream*
 909 :               pstream = nullptr) const {
 910 :     const size_t num_params__ = ((((1 + 1) + K) + C) + C);
 911 :     const size_t num_transformed = emit_transformed_parameters * (K);
 912 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
 913 :     const size_t num_to_write = num_params__ + num_transformed +
 914 :       num_gen_quantities;
 915 :     vars = std::vector<double>(num_to_write,
 916 :              std::numeric_limits<double>::quiet_NaN());
 917 :     write_array_impl(base_rng, params_r, params_i, vars,
 918 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 919 :   }
 920 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 921 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 922 :     Eigen::Matrix<int,-1,1> params_i;
 923 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 924 :   }
 925 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 926 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 927 :            std::ostream* pstream = nullptr) const {
 928 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 929 :   }
 930 :   inline void
 931 :   transform_inits(const stan::io::var_context& context,
 932 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 933 :                   pstream = nullptr) const final {
 934 :     std::vector<double> params_r_vec(params_r.size());
 935 :     std::vector<int> params_i;
 936 :     transform_inits(context, params_i, params_r_vec, pstream);
 937 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 938 :                  params_r_vec.size());
 939 :   }
 940 :   inline void
 941 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 942 :                   params_i, std::vector<double>& vars, std::ostream*
 943 :                   pstream__ = nullptr) const {
 944 :     vars.resize(num_params_r__);
 945 :     transform_inits_impl(context, vars, pstream__);
 946 :   }
 947 :   inline void
 948 :   unconstrain_array(const std::vector<double>& params_constrained,
 949 :                     std::vector<double>& params_unconstrained, std::ostream*
 950 :                     pstream = nullptr) const {
 951 :     const std::vector<int> params_i;
 952 :     params_unconstrained = std::vector<double>(num_params_r__,
 953 :                              std::numeric_limits<double>::quiet_NaN());
 954 :     unconstrain_array_impl(params_constrained, params_i,
 955 :       params_unconstrained, pstream);
 956 :   }
 957 :   inline void
 958 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 959 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
 960 :                     std::ostream* pstream = nullptr) const {
 961 :     const std::vector<int> params_i;
 962 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
 963 :                              std::numeric_limits<double>::quiet_NaN());
 964 :     unconstrain_array_impl(params_constrained, params_i,
 965 :       params_unconstrained, pstream);
 966 :   }
 967 : };
 968 : }
 969 : using stan_model = model35a4af15f285fc__namespace::model35a4af15f285fc_;
 970 : #ifndef USING_R
 971 : // Boilerplate
 972 : stan::model::model_base&
 973 : new_model(stan::io::var_context& data_context, unsigned int seed,
 974 :           std::ostream* msg_stream) {
 975 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
 976 :   return *m;
 977 : }
 978 : stan::math::profile_map& get_stan_profile_data() {
 979 :   return model35a4af15f285fc__namespace::profiles__;
 980 : }
 981 : #endif
 982 : #endif
 983 : 
 984 : RCPP_MODULE(stan_fit4model35a4af15f285fc__mod) {
 985 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
 986 :       "stan_fit4model35a4af15f285fc_")
 987 : 
 988 :       .constructor<SEXP, SEXP, SEXP>()
 989 : 
 990 :       .method(
 991 :           "call_sampler",
 992 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
 993 :       .method(
 994 :           "param_names",
 995 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
 996 :       .method("param_names_oi",
 997 :               &rstan::stan_fit<stan_model,
 998 :                                boost::random::ecuyer1988>::param_names_oi)
 999 :       .method("param_fnames_oi",
1000 :               &rstan::stan_fit<stan_model,
1001 :                                boost::random::ecuyer1988>::param_fnames_oi)
1002 :       .method(
1003 :           "param_dims",
1004 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
1005 :       .method("param_dims_oi",
1006 :               &rstan::stan_fit<stan_model,
1007 :                                boost::random::ecuyer1988>::param_dims_oi)
1008 :       .method("update_param_oi",
1009 :               &rstan::stan_fit<stan_model,
1010 :                                boost::random::ecuyer1988>::update_param_oi)
1011 :       .method("param_oi_tidx",
1012 :               &rstan::stan_fit<stan_model,
1013 :                                boost::random::ecuyer1988>::param_oi_tidx)
1014 :       .method("grad_log_prob",
1015 :               &rstan::stan_fit<stan_model,
1016 :                                boost::random::ecuyer1988>::grad_log_prob)
1017 :       .method("log_prob",
1018 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
1019 :       .method("unconstrain_pars",
1020 :               &rstan::stan_fit<stan_model,
1021 :                                boost::random::ecuyer1988>::unconstrain_pars)
1022 :       .method("constrain_pars",
1023 :               &rstan::stan_fit<stan_model,
1024 :                                boost::random::ecuyer1988>::constrain_pars)
1025 :       .method(
1026 :           "num_pars_unconstrained",
1027 :           &rstan::stan_fit<stan_model,
1028 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
1029 :       .method(
1030 :           "unconstrained_param_names",
1031 :           &rstan::stan_fit<
1032 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
1033 :       .method(
1034 :           "constrained_param_names",
1035 :           &rstan::stan_fit<stan_model,
1036 :                            boost::random::ecuyer1988>::constrained_param_names)
1037 :       .method("standalone_gqs",
1038 :               &rstan::stan_fit<stan_model,
1039 :                                boost::random::ecuyer1988>::standalone_gqs);
1040 : }
1041 : 
1042 : 
1043 : // declarations
1044 : extern "C" {
1045 : SEXP file35a4af559d2d3d( ) ;
1046 : }
1047 : 
1048 : // definition
1049 : SEXP file35a4af559d2d3d() {
1050 :  return Rcpp::wrap("anon_model");
1051 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file35a4af559d2d3d.so' OBJECTS='file35a4af559d2d3d.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file35a4af559d2d3d.cpp -o file35a4af559d2d3d.o
if test  "zfile35a4af559d2d3d.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file35a4af559d2d3d.so file35a4af559d2d3d.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file35a4af559d2d3d.so file35a4af559d2d3d.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).
Chain 2: 
Chain 2: Gradient evaluation took 0.014198 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 141.98 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 4: 
Chain 4: Gradient evaluation took 0.014442 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 144.42 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: 
Chain 1: Gradient evaluation took 0.017337 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 173.37 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 3: 
Chain 3: Gradient evaluation took 0.0174 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 174 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 652.303 seconds (Warm-up)
Chain 2:                270.217 seconds (Sampling)
Chain 2:                922.52 seconds (Total)
Chain 2: 
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 670.883 seconds (Warm-up)
Chain 3:                267.196 seconds (Sampling)
Chain 3:                938.079 seconds (Total)
Chain 3: 
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 801.352 seconds (Warm-up)
Chain 1:                283.88 seconds (Sampling)
Chain 1:                1085.23 seconds (Total)
Chain 1: 
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 856.133 seconds (Warm-up)
Chain 4:                274.893 seconds (Sampling)
Chain 4:                1131.03 seconds (Total)
Chain 4: 
Stan model 'anon_model' does not contain samples.
