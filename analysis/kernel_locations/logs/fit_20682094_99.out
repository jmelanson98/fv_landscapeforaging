
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model2934ad4ba3dd78__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 49> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 21, column 2 to column 20)",
  25 :   " (in 'anon_model', line 22, column 2 to column 22)",
  26 :   " (in 'anon_model', line 23, column 2 to column 13)",
  27 :   " (in 'anon_model', line 24, column 2 to column 13)",
  28 :   " (in 'anon_model', line 25, column 2 to column 16)",
  29 :   " (in 'anon_model', line 27, column 2 to column 50)",
  30 :   " (in 'anon_model', line 28, column 2 to column 50)",
  31 :   " (in 'anon_model', line 32, column 2 to column 40)",
  32 :   " (in 'anon_model', line 36, column 2 to column 33)",
  33 :   " (in 'anon_model', line 37, column 2 to column 22)",
  34 :   " (in 'anon_model', line 38, column 2 to column 22)",
  35 :   " (in 'anon_model', line 39, column 2 to column 25)",
  36 :   " (in 'anon_model', line 40, column 2 to column 21)",
  37 :   " (in 'anon_model', line 48, column 4 to line 49, column 71)",
  38 :   " (in 'anon_model', line 51, column 8 to column 50)",
  39 :   " (in 'anon_model', line 50, column 18 to line 52, column 7)",
  40 :   " (in 'anon_model', line 50, column 4 to line 52, column 7)",
  41 :   " (in 'anon_model', line 56, column 4 to line 58, column 44)",
  42 :   " (in 'anon_model', line 61, column 4 to column 38)",
  43 :   " (in 'anon_model', line 45, column 17 to line 62, column 3)",
  44 :   " (in 'anon_model', line 45, column 2 to line 62, column 3)",
  45 :   " (in 'anon_model', line 42, column 2 to line 63, column 1)",
  46 :   " (in 'anon_model', line 4, column 2 to column 17)",
  47 :   " (in 'anon_model', line 5, column 2 to column 17)",
  48 :   " (in 'anon_model', line 6, column 2 to column 17)",
  49 :   " (in 'anon_model', line 7, column 9 to column 10)",
  50 :   " (in 'anon_model', line 7, column 2 to column 24)",
  51 :   " (in 'anon_model', line 8, column 9 to column 10)",
  52 :   " (in 'anon_model', line 8, column 2 to column 26)",
  53 :   " (in 'anon_model', line 9, column 16 to column 17)",
  54 :   " (in 'anon_model', line 9, column 2 to column 19)",
  55 :   " (in 'anon_model', line 10, column 14 to column 15)",
  56 :   " (in 'anon_model', line 10, column 2 to column 17)",
  57 :   " (in 'anon_model', line 11, column 9 to column 10)",
  58 :   " (in 'anon_model', line 11, column 2 to column 15)",
  59 :   " (in 'anon_model', line 12, column 12 to column 13)",
  60 :   " (in 'anon_model', line 12, column 2 to column 15)",
  61 :   " (in 'anon_model', line 13, column 9 to column 10)",
  62 :   " (in 'anon_model', line 13, column 2 to column 15)",
  63 :   " (in 'anon_model', line 14, column 2 to column 15)",
  64 :   " (in 'anon_model', line 15, column 2 to column 15)",
  65 :   " (in 'anon_model', line 16, column 2 to column 15)",
  66 :   " (in 'anon_model', line 17, column 2 to column 15)",
  67 :   " (in 'anon_model', line 18, column 2 to column 12)",
  68 :   " (in 'anon_model', line 25, column 9 to column 10)",
  69 :   " (in 'anon_model', line 27, column 39 to column 40)",
  70 :   " (in 'anon_model', line 28, column 39 to column 40)",
  71 :   " (in 'anon_model', line 32, column 9 to column 10)"};
  72 : class model2934ad4ba3dd78_ final : public model_base_crtp<model2934ad4ba3dd78_> {
  73 : private:
  74 :   int C;
  75 :   int K;
  76 :   int O;
  77 :   Eigen::Matrix<double,-1,-1> trap_pos_data__;
  78 :   Eigen::Matrix<double,-1,1> sample_effort_data__;
  79 :   std::vector<int> colony_id;
  80 :   std::vector<int> trap_id;
  81 :   Eigen::Matrix<double,-1,1> fq_data__;
  82 :   std::vector<int> y_obs;
  83 :   Eigen::Matrix<double,-1,1> yn_data__;
  84 :   double lower_x;
  85 :   double upper_x;
  86 :   double lower_y;
  87 :   double upper_y;
  88 :   double Rmax;
  89 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap_pos{nullptr, 0, 0};
  90 :   Eigen::Map<Eigen::Matrix<double,-1,1>> sample_effort{nullptr, 0};
  91 :   Eigen::Map<Eigen::Matrix<double,-1,1>> fq{nullptr, 0};
  92 :   Eigen::Map<Eigen::Matrix<double,-1,1>> yn{nullptr, 0};
  93 : public:
  94 :   ~model2934ad4ba3dd78_() {}
  95 :   model2934ad4ba3dd78_(stan::io::var_context& context__, unsigned int
  96 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
  97 :       : model_base_crtp(0) {
  98 :     int current_statement__ = 0;
  99 :     using local_scalar_t__ = double;
 100 :     boost::ecuyer1988 base_rng__ =
 101 :       stan::services::util::create_rng(random_seed__, 0);
 102 :     // suppress unused var warning
 103 :     (void) base_rng__;
 104 :     static constexpr const char* function__ =
 105 :       "model2934ad4ba3dd78__namespace::model2934ad4ba3dd78_";
 106 :     // suppress unused var warning
 107 :     (void) function__;
 108 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 109 :     // suppress unused var warning
 110 :     (void) DUMMY_VAR__;
 111 :     try {
 112 :       int pos__ = std::numeric_limits<int>::min();
 113 :       pos__ = 1;
 114 :       current_statement__ = 23;
 115 :       context__.validate_dims("data initialization", "C", "int",
 116 :         std::vector<size_t>{});
 117 :       C = std::numeric_limits<int>::min();
 118 :       current_statement__ = 23;
 119 :       C = context__.vals_i("C")[(1 - 1)];
 120 :       current_statement__ = 23;
 121 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 122 :       current_statement__ = 24;
 123 :       context__.validate_dims("data initialization", "K", "int",
 124 :         std::vector<size_t>{});
 125 :       K = std::numeric_limits<int>::min();
 126 :       current_statement__ = 24;
 127 :       K = context__.vals_i("K")[(1 - 1)];
 128 :       current_statement__ = 24;
 129 :       stan::math::check_greater_or_equal(function__, "K", K, 1);
 130 :       current_statement__ = 25;
 131 :       context__.validate_dims("data initialization", "O", "int",
 132 :         std::vector<size_t>{});
 133 :       O = std::numeric_limits<int>::min();
 134 :       current_statement__ = 25;
 135 :       O = context__.vals_i("O")[(1 - 1)];
 136 :       current_statement__ = 25;
 137 :       stan::math::check_greater_or_equal(function__, "O", O, 1);
 138 :       current_statement__ = 26;
 139 :       stan::math::validate_non_negative_index("trap_pos", "O", O);
 140 :       current_statement__ = 27;
 141 :       context__.validate_dims("data initialization", "trap_pos", "double",
 142 :         std::vector<size_t>{static_cast<size_t>(O), static_cast<size_t>(2)});
 143 :       trap_pos_data__ = Eigen::Matrix<double,-1,-1>::Constant(O, 2,
 144 :                           std::numeric_limits<double>::quiet_NaN());
 145 :       new (&trap_pos)
 146 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_pos_data__.data(), O, 2);
 147 :       {
 148 :         std::vector<local_scalar_t__> trap_pos_flat__;
 149 :         current_statement__ = 27;
 150 :         trap_pos_flat__ = context__.vals_r("trap_pos");
 151 :         current_statement__ = 27;
 152 :         pos__ = 1;
 153 :         current_statement__ = 27;
 154 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 155 :           current_statement__ = 27;
 156 :           for (int sym2__ = 1; sym2__ <= O; ++sym2__) {
 157 :             current_statement__ = 27;
 158 :             stan::model::assign(trap_pos, trap_pos_flat__[(pos__ - 1)],
 159 :               "assigning variable trap_pos", stan::model::index_uni(sym2__),
 160 :               stan::model::index_uni(sym1__));
 161 :             current_statement__ = 27;
 162 :             pos__ = (pos__ + 1);
 163 :           }
 164 :         }
 165 :       }
 166 :       current_statement__ = 28;
 167 :       stan::math::validate_non_negative_index("sample_effort", "O", O);
 168 :       current_statement__ = 29;
 169 :       context__.validate_dims("data initialization", "sample_effort",
 170 :         "double", std::vector<size_t>{static_cast<size_t>(O)});
 171 :       sample_effort_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 172 :                                std::numeric_limits<double>::quiet_NaN());
 173 :       new (&sample_effort)
 174 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(sample_effort_data__.data(),
 175 :         O);
 176 :       {
 177 :         std::vector<local_scalar_t__> sample_effort_flat__;
 178 :         current_statement__ = 29;
 179 :         sample_effort_flat__ = context__.vals_r("sample_effort");
 180 :         current_statement__ = 29;
 181 :         pos__ = 1;
 182 :         current_statement__ = 29;
 183 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 184 :           current_statement__ = 29;
 185 :           stan::model::assign(sample_effort, sample_effort_flat__[(pos__ -
 186 :             1)], "assigning variable sample_effort",
 187 :             stan::model::index_uni(sym1__));
 188 :           current_statement__ = 29;
 189 :           pos__ = (pos__ + 1);
 190 :         }
 191 :       }
 192 :       current_statement__ = 30;
 193 :       stan::math::validate_non_negative_index("colony_id", "O", O);
 194 :       current_statement__ = 31;
 195 :       context__.validate_dims("data initialization", "colony_id", "int",
 196 :         std::vector<size_t>{static_cast<size_t>(O)});
 197 :       colony_id = std::vector<int>(O, std::numeric_limits<int>::min());
 198 :       current_statement__ = 31;
 199 :       colony_id = context__.vals_i("colony_id");
 200 :       current_statement__ = 32;
 201 :       stan::math::validate_non_negative_index("trap_id", "O", O);
 202 :       current_statement__ = 33;
 203 :       context__.validate_dims("data initialization", "trap_id", "int",
 204 :         std::vector<size_t>{static_cast<size_t>(O)});
 205 :       trap_id = std::vector<int>(O, std::numeric_limits<int>::min());
 206 :       current_statement__ = 33;
 207 :       trap_id = context__.vals_i("trap_id");
 208 :       current_statement__ = 34;
 209 :       stan::math::validate_non_negative_index("fq", "O", O);
 210 :       current_statement__ = 35;
 211 :       context__.validate_dims("data initialization", "fq", "double",
 212 :         std::vector<size_t>{static_cast<size_t>(O)});
 213 :       fq_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 214 :                     std::numeric_limits<double>::quiet_NaN());
 215 :       new (&fq) Eigen::Map<Eigen::Matrix<double,-1,1>>(fq_data__.data(), O);
 216 :       {
 217 :         std::vector<local_scalar_t__> fq_flat__;
 218 :         current_statement__ = 35;
 219 :         fq_flat__ = context__.vals_r("fq");
 220 :         current_statement__ = 35;
 221 :         pos__ = 1;
 222 :         current_statement__ = 35;
 223 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 224 :           current_statement__ = 35;
 225 :           stan::model::assign(fq, fq_flat__[(pos__ - 1)],
 226 :             "assigning variable fq", stan::model::index_uni(sym1__));
 227 :           current_statement__ = 35;
 228 :           pos__ = (pos__ + 1);
 229 :         }
 230 :       }
 231 :       current_statement__ = 36;
 232 :       stan::math::validate_non_negative_index("y_obs", "O", O);
 233 :       current_statement__ = 37;
 234 :       context__.validate_dims("data initialization", "y_obs", "int",
 235 :         std::vector<size_t>{static_cast<size_t>(O)});
 236 :       y_obs = std::vector<int>(O, std::numeric_limits<int>::min());
 237 :       current_statement__ = 37;
 238 :       y_obs = context__.vals_i("y_obs");
 239 :       current_statement__ = 38;
 240 :       stan::math::validate_non_negative_index("yn", "O", O);
 241 :       current_statement__ = 39;
 242 :       context__.validate_dims("data initialization", "yn", "double",
 243 :         std::vector<size_t>{static_cast<size_t>(O)});
 244 :       yn_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 245 :                     std::numeric_limits<double>::quiet_NaN());
 246 :       new (&yn) Eigen::Map<Eigen::Matrix<double,-1,1>>(yn_data__.data(), O);
 247 :       {
 248 :         std::vector<local_scalar_t__> yn_flat__;
 249 :         current_statement__ = 39;
 250 :         yn_flat__ = context__.vals_r("yn");
 251 :         current_statement__ = 39;
 252 :         pos__ = 1;
 253 :         current_statement__ = 39;
 254 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 255 :           current_statement__ = 39;
 256 :           stan::model::assign(yn, yn_flat__[(pos__ - 1)],
 257 :             "assigning variable yn", stan::model::index_uni(sym1__));
 258 :           current_statement__ = 39;
 259 :           pos__ = (pos__ + 1);
 260 :         }
 261 :       }
 262 :       current_statement__ = 40;
 263 :       context__.validate_dims("data initialization", "lower_x", "double",
 264 :         std::vector<size_t>{});
 265 :       lower_x = std::numeric_limits<double>::quiet_NaN();
 266 :       current_statement__ = 40;
 267 :       lower_x = context__.vals_r("lower_x")[(1 - 1)];
 268 :       current_statement__ = 41;
 269 :       context__.validate_dims("data initialization", "upper_x", "double",
 270 :         std::vector<size_t>{});
 271 :       upper_x = std::numeric_limits<double>::quiet_NaN();
 272 :       current_statement__ = 41;
 273 :       upper_x = context__.vals_r("upper_x")[(1 - 1)];
 274 :       current_statement__ = 42;
 275 :       context__.validate_dims("data initialization", "lower_y", "double",
 276 :         std::vector<size_t>{});
 277 :       lower_y = std::numeric_limits<double>::quiet_NaN();
 278 :       current_statement__ = 42;
 279 :       lower_y = context__.vals_r("lower_y")[(1 - 1)];
 280 :       current_statement__ = 43;
 281 :       context__.validate_dims("data initialization", "upper_y", "double",
 282 :         std::vector<size_t>{});
 283 :       upper_y = std::numeric_limits<double>::quiet_NaN();
 284 :       current_statement__ = 43;
 285 :       upper_y = context__.vals_r("upper_y")[(1 - 1)];
 286 :       current_statement__ = 44;
 287 :       context__.validate_dims("data initialization", "Rmax", "double",
 288 :         std::vector<size_t>{});
 289 :       Rmax = std::numeric_limits<double>::quiet_NaN();
 290 :       current_statement__ = 44;
 291 :       Rmax = context__.vals_r("Rmax")[(1 - 1)];
 292 :       current_statement__ = 45;
 293 :       stan::math::validate_non_negative_index("eps", "K", K);
 294 :       current_statement__ = 46;
 295 :       stan::math::validate_non_negative_index("delta_x", "C", C);
 296 :       current_statement__ = 47;
 297 :       stan::math::validate_non_negative_index("delta_y", "C", C);
 298 :       current_statement__ = 48;
 299 :       stan::math::validate_non_negative_index("eps_scale", "K", K);
 300 :     } catch (const std::exception& e) {
 301 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 302 :     }
 303 :     num_params_r__ = 1 + 1 + 1 + 1 + K + C + C;
 304 :   }
 305 :   inline std::string model_name() const final {
 306 :     return "model2934ad4ba3dd78_";
 307 :   }
 308 :   inline std::vector<std::string> model_compile_info() const noexcept {
 309 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 310 :              "stancflags = --"};
 311 :   }
 312 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 313 :             stan::require_vector_like_t<VecR>* = nullptr,
 314 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 315 :   inline stan::scalar_type_t<VecR>
 316 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 317 :                 pstream__ = nullptr) const {
 318 :     using T__ = stan::scalar_type_t<VecR>;
 319 :     using local_scalar_t__ = T__;
 320 :     T__ lp__(0.0);
 321 :     stan::math::accumulator<T__> lp_accum__;
 322 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 323 :     int current_statement__ = 0;
 324 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 325 :     // suppress unused var warning
 326 :     (void) DUMMY_VAR__;
 327 :     static constexpr const char* function__ =
 328 :       "model2934ad4ba3dd78__namespace::log_prob";
 329 :     // suppress unused var warning
 330 :     (void) function__;
 331 :     try {
 332 :       local_scalar_t__ rho = DUMMY_VAR__;
 333 :       current_statement__ = 1;
 334 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 335 :               lp__);
 336 :       local_scalar_t__ sigma = DUMMY_VAR__;
 337 :       current_statement__ = 2;
 338 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 339 :                 jacobian__>(0, lp__);
 340 :       local_scalar_t__ theta = DUMMY_VAR__;
 341 :       current_statement__ = 3;
 342 :       theta = in__.template read<local_scalar_t__>();
 343 :       local_scalar_t__ alpha = DUMMY_VAR__;
 344 :       current_statement__ = 4;
 345 :       alpha = in__.template read<local_scalar_t__>();
 346 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 347 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 348 :       current_statement__ = 5;
 349 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 350 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 351 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 352 :       current_statement__ = 6;
 353 :       delta_x = in__.template read_constrain_lub<
 354 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_x,
 355 :                   upper_x, lp__, C);
 356 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 357 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 358 :       current_statement__ = 7;
 359 :       delta_y = in__.template read_constrain_lub<
 360 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_y,
 361 :                   upper_y, lp__, C);
 362 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 363 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 364 :       current_statement__ = 8;
 365 :       stan::model::assign(eps_scale,
 366 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 367 :         "assigning variable eps_scale");
 368 :       {
 369 :         current_statement__ = 9;
 370 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho,
 371 :                          stan::math::log(0.5), 0.5));
 372 :         current_statement__ = 10;
 373 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, 0, 1));
 374 :         current_statement__ = 11;
 375 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 0, 3));
 376 :         current_statement__ = 12;
 377 :         lp_accum__.add(stan::math::exponential_lpdf<propto__>(sigma, 1));
 378 :         current_statement__ = 13;
 379 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 380 :         {
 381 :           current_statement__ = 21;
 382 :           for (int i = 1; i <= O; ++i) {
 383 :             local_scalar_t__ dis = DUMMY_VAR__;
 384 :             current_statement__ = 14;
 385 :             dis = stan::math::sqrt(
 386 :                     (stan::math::square(
 387 :                        (stan::model::rvalue(delta_x, "delta_x",
 388 :                           stan::model::index_uni(
 389 :                             stan::model::rvalue(colony_id, "colony_id",
 390 :                               stan::model::index_uni(i)))) -
 391 :                        stan::model::rvalue(trap_pos, "trap_pos",
 392 :                          stan::model::index_uni(i), stan::model::index_uni(1))))
 393 :                     +
 394 :                     stan::math::square(
 395 :                       (stan::model::rvalue(delta_y, "delta_y",
 396 :                          stan::model::index_uni(
 397 :                            stan::model::rvalue(colony_id, "colony_id",
 398 :                              stan::model::index_uni(i)))) -
 399 :                       stan::model::rvalue(trap_pos, "trap_pos",
 400 :                         stan::model::index_uni(i), stan::model::index_uni(2))))));
 401 :             current_statement__ = 17;
 402 :             if (stan::math::logical_eq(
 403 :                   stan::model::rvalue(yn, "yn", stan::model::index_uni(i)), 1)) {
 404 :               current_statement__ = 15;
 405 :               lp_accum__.add(stan::math::normal_lpdf<false>(dis, 0, (Rmax /
 406 :                                2.58)));
 407 :             }
 408 :             local_scalar_t__ lambda_ik = DUMMY_VAR__;
 409 :             current_statement__ = 18;
 410 :             lambda_ik = ((((alpha - (0.5 * stan::math::pow((dis / rho), 2)))
 411 :               + (theta *
 412 :               stan::model::rvalue(fq, "fq", stan::model::index_uni(i)))) +
 413 :               stan::model::rvalue(eps_scale, "eps_scale",
 414 :                 stan::model::index_uni(
 415 :                   stan::model::rvalue(trap_id, "trap_id",
 416 :                     stan::model::index_uni(i)))))
 417 :               +
 418 :               stan::math::log(
 419 :                 stan::model::rvalue(sample_effort, "sample_effort",
 420 :                   stan::model::index_uni(i))));
 421 :             current_statement__ = 19;
 422 :             lp_accum__.add(stan::math::poisson_log_lpmf<propto__>(
 423 :                              stan::model::rvalue(y_obs, "y_obs",
 424 :                                stan::model::index_uni(i)), lambda_ik));
 425 :           }
 426 :         }
 427 :       }
 428 :     } catch (const std::exception& e) {
 429 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 430 :     }
 431 :     lp_accum__.add(lp__);
 432 :     return lp_accum__.sum();
 433 :   }
 434 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 435 :             stan::require_vector_like_vt<std::is_floating_point,
 436 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 437 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 438 :             VecVar>* = nullptr>
 439 :   inline void
 440 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 441 :                    VecVar& vars__, const bool
 442 :                    emit_transformed_parameters__ = true, const bool
 443 :                    emit_generated_quantities__ = true, std::ostream*
 444 :                    pstream__ = nullptr) const {
 445 :     using local_scalar_t__ = double;
 446 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 447 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 448 :     static constexpr bool propto__ = true;
 449 :     // suppress unused var warning
 450 :     (void) propto__;
 451 :     double lp__ = 0.0;
 452 :     // suppress unused var warning
 453 :     (void) lp__;
 454 :     int current_statement__ = 0;
 455 :     stan::math::accumulator<double> lp_accum__;
 456 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 457 :     // suppress unused var warning
 458 :     (void) DUMMY_VAR__;
 459 :     constexpr bool jacobian__ = false;
 460 :     static constexpr const char* function__ =
 461 :       "model2934ad4ba3dd78__namespace::write_array";
 462 :     // suppress unused var warning
 463 :     (void) function__;
 464 :     try {
 465 :       double rho = std::numeric_limits<double>::quiet_NaN();
 466 :       current_statement__ = 1;
 467 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 468 :               lp__);
 469 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 470 :       current_statement__ = 2;
 471 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 472 :                 jacobian__>(0, lp__);
 473 :       double theta = std::numeric_limits<double>::quiet_NaN();
 474 :       current_statement__ = 3;
 475 :       theta = in__.template read<local_scalar_t__>();
 476 :       double alpha = std::numeric_limits<double>::quiet_NaN();
 477 :       current_statement__ = 4;
 478 :       alpha = in__.template read<local_scalar_t__>();
 479 :       Eigen::Matrix<double,-1,1> eps =
 480 :         Eigen::Matrix<double,-1,1>::Constant(K,
 481 :           std::numeric_limits<double>::quiet_NaN());
 482 :       current_statement__ = 5;
 483 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 484 :       Eigen::Matrix<double,-1,1> delta_x =
 485 :         Eigen::Matrix<double,-1,1>::Constant(C,
 486 :           std::numeric_limits<double>::quiet_NaN());
 487 :       current_statement__ = 6;
 488 :       delta_x = in__.template read_constrain_lub<
 489 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_x,
 490 :                   upper_x, lp__, C);
 491 :       Eigen::Matrix<double,-1,1> delta_y =
 492 :         Eigen::Matrix<double,-1,1>::Constant(C,
 493 :           std::numeric_limits<double>::quiet_NaN());
 494 :       current_statement__ = 7;
 495 :       delta_y = in__.template read_constrain_lub<
 496 :                   Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(lower_y,
 497 :                   upper_y, lp__, C);
 498 :       Eigen::Matrix<double,-1,1> eps_scale =
 499 :         Eigen::Matrix<double,-1,1>::Constant(K,
 500 :           std::numeric_limits<double>::quiet_NaN());
 501 :       out__.write(rho);
 502 :       out__.write(sigma);
 503 :       out__.write(theta);
 504 :       out__.write(alpha);
 505 :       out__.write(eps);
 506 :       out__.write(delta_x);
 507 :       out__.write(delta_y);
 508 :       if (stan::math::logical_negation(
 509 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 510 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 511 :         return ;
 512 :       }
 513 :       current_statement__ = 8;
 514 :       stan::model::assign(eps_scale,
 515 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 516 :         "assigning variable eps_scale");
 517 :       if (emit_transformed_parameters__) {
 518 :         out__.write(eps_scale);
 519 :       }
 520 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 521 :         return ;
 522 :       }
 523 :     } catch (const std::exception& e) {
 524 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 525 :     }
 526 :   }
 527 :   template <typename VecVar, typename VecI,
 528 :             stan::require_vector_t<VecVar>* = nullptr,
 529 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 530 :   inline void
 531 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 532 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 533 :     using local_scalar_t__ = double;
 534 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 535 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 536 :     int current_statement__ = 0;
 537 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 538 :     // suppress unused var warning
 539 :     (void) DUMMY_VAR__;
 540 :     try {
 541 :       int pos__ = std::numeric_limits<int>::min();
 542 :       pos__ = 1;
 543 :       local_scalar_t__ rho = DUMMY_VAR__;
 544 :       current_statement__ = 1;
 545 :       rho = in__.read<local_scalar_t__>();
 546 :       out__.write_free_lb(0, rho);
 547 :       local_scalar_t__ sigma = DUMMY_VAR__;
 548 :       current_statement__ = 2;
 549 :       sigma = in__.read<local_scalar_t__>();
 550 :       out__.write_free_lb(0, sigma);
 551 :       local_scalar_t__ theta = DUMMY_VAR__;
 552 :       current_statement__ = 3;
 553 :       theta = in__.read<local_scalar_t__>();
 554 :       out__.write(theta);
 555 :       local_scalar_t__ alpha = DUMMY_VAR__;
 556 :       current_statement__ = 4;
 557 :       alpha = in__.read<local_scalar_t__>();
 558 :       out__.write(alpha);
 559 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 560 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 561 :       current_statement__ = 5;
 562 :       stan::model::assign(eps,
 563 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 564 :         "assigning variable eps");
 565 :       out__.write(eps);
 566 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 567 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 568 :       current_statement__ = 6;
 569 :       stan::model::assign(delta_x,
 570 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 571 :         "assigning variable delta_x");
 572 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 573 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 574 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 575 :       current_statement__ = 7;
 576 :       stan::model::assign(delta_y,
 577 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 578 :         "assigning variable delta_y");
 579 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 580 :     } catch (const std::exception& e) {
 581 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 582 :     }
 583 :   }
 584 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 585 :   inline void
 586 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 587 :                        vars__, std::ostream* pstream__ = nullptr) const {
 588 :     using local_scalar_t__ = double;
 589 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 590 :     int current_statement__ = 0;
 591 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 592 :     // suppress unused var warning
 593 :     (void) DUMMY_VAR__;
 594 :     try {
 595 :       current_statement__ = 1;
 596 :       context__.validate_dims("parameter initialization", "rho", "double",
 597 :         std::vector<size_t>{});
 598 :       current_statement__ = 2;
 599 :       context__.validate_dims("parameter initialization", "sigma", "double",
 600 :         std::vector<size_t>{});
 601 :       current_statement__ = 3;
 602 :       context__.validate_dims("parameter initialization", "theta", "double",
 603 :         std::vector<size_t>{});
 604 :       current_statement__ = 4;
 605 :       context__.validate_dims("parameter initialization", "alpha", "double",
 606 :         std::vector<size_t>{});
 607 :       current_statement__ = 5;
 608 :       context__.validate_dims("parameter initialization", "eps", "double",
 609 :         std::vector<size_t>{static_cast<size_t>(K)});
 610 :       current_statement__ = 6;
 611 :       context__.validate_dims("parameter initialization", "delta_x",
 612 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 613 :       current_statement__ = 7;
 614 :       context__.validate_dims("parameter initialization", "delta_y",
 615 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 616 :       int pos__ = std::numeric_limits<int>::min();
 617 :       pos__ = 1;
 618 :       local_scalar_t__ rho = DUMMY_VAR__;
 619 :       current_statement__ = 1;
 620 :       rho = context__.vals_r("rho")[(1 - 1)];
 621 :       out__.write_free_lb(0, rho);
 622 :       local_scalar_t__ sigma = DUMMY_VAR__;
 623 :       current_statement__ = 2;
 624 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 625 :       out__.write_free_lb(0, sigma);
 626 :       local_scalar_t__ theta = DUMMY_VAR__;
 627 :       current_statement__ = 3;
 628 :       theta = context__.vals_r("theta")[(1 - 1)];
 629 :       out__.write(theta);
 630 :       local_scalar_t__ alpha = DUMMY_VAR__;
 631 :       current_statement__ = 4;
 632 :       alpha = context__.vals_r("alpha")[(1 - 1)];
 633 :       out__.write(alpha);
 634 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 635 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 636 :       {
 637 :         std::vector<local_scalar_t__> eps_flat__;
 638 :         current_statement__ = 5;
 639 :         eps_flat__ = context__.vals_r("eps");
 640 :         current_statement__ = 5;
 641 :         pos__ = 1;
 642 :         current_statement__ = 5;
 643 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 644 :           current_statement__ = 5;
 645 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 646 :             "assigning variable eps", stan::model::index_uni(sym1__));
 647 :           current_statement__ = 5;
 648 :           pos__ = (pos__ + 1);
 649 :         }
 650 :       }
 651 :       out__.write(eps);
 652 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_x =
 653 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 654 :       {
 655 :         std::vector<local_scalar_t__> delta_x_flat__;
 656 :         current_statement__ = 6;
 657 :         delta_x_flat__ = context__.vals_r("delta_x");
 658 :         current_statement__ = 6;
 659 :         pos__ = 1;
 660 :         current_statement__ = 6;
 661 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 662 :           current_statement__ = 6;
 663 :           stan::model::assign(delta_x, delta_x_flat__[(pos__ - 1)],
 664 :             "assigning variable delta_x", stan::model::index_uni(sym1__));
 665 :           current_statement__ = 6;
 666 :           pos__ = (pos__ + 1);
 667 :         }
 668 :       }
 669 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 670 :       Eigen::Matrix<local_scalar_t__,-1,1> delta_y =
 671 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 672 :       {
 673 :         std::vector<local_scalar_t__> delta_y_flat__;
 674 :         current_statement__ = 7;
 675 :         delta_y_flat__ = context__.vals_r("delta_y");
 676 :         current_statement__ = 7;
 677 :         pos__ = 1;
 678 :         current_statement__ = 7;
 679 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 680 :           current_statement__ = 7;
 681 :           stan::model::assign(delta_y, delta_y_flat__[(pos__ - 1)],
 682 :             "assigning variable delta_y", stan::model::index_uni(sym1__));
 683 :           current_statement__ = 7;
 684 :           pos__ = (pos__ + 1);
 685 :         }
 686 :       }
 687 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 688 :     } catch (const std::exception& e) {
 689 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 690 :     }
 691 :   }
 692 :   inline void
 693 :   get_param_names(std::vector<std::string>& names__, const bool
 694 :                   emit_transformed_parameters__ = true, const bool
 695 :                   emit_generated_quantities__ = true) const {
 696 :     names__ = std::vector<std::string>{"rho", "sigma", "theta", "alpha",
 697 :                 "eps", "delta_x", "delta_y"};
 698 :     if (emit_transformed_parameters__) {
 699 :       std::vector<std::string> temp{"eps_scale"};
 700 :       names__.reserve(names__.size() + temp.size());
 701 :       names__.insert(names__.end(), temp.begin(), temp.end());
 702 :     }
 703 :     if (emit_generated_quantities__) {}
 704 :   }
 705 :   inline void
 706 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 707 :            emit_transformed_parameters__ = true, const bool
 708 :            emit_generated_quantities__ = true) const {
 709 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 710 :                 std::vector<size_t>{}, std::vector<size_t>{},
 711 :                 std::vector<size_t>{},
 712 :                 std::vector<size_t>{static_cast<size_t>(K)},
 713 :                 std::vector<size_t>{static_cast<size_t>(C)},
 714 :                 std::vector<size_t>{static_cast<size_t>(C)}};
 715 :     if (emit_transformed_parameters__) {
 716 :       std::vector<std::vector<size_t>>
 717 :         temp{std::vector<size_t>{static_cast<size_t>(K)}};
 718 :       dimss__.reserve(dimss__.size() + temp.size());
 719 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 720 :     }
 721 :     if (emit_generated_quantities__) {}
 722 :   }
 723 :   inline void
 724 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 725 :                           emit_transformed_parameters__ = true, bool
 726 :                           emit_generated_quantities__ = true) const final {
 727 :     param_names__.emplace_back(std::string() + "rho");
 728 :     param_names__.emplace_back(std::string() + "sigma");
 729 :     param_names__.emplace_back(std::string() + "theta");
 730 :     param_names__.emplace_back(std::string() + "alpha");
 731 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 732 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 733 :         std::to_string(sym1__));
 734 :     }
 735 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 736 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 737 :         std::to_string(sym1__));
 738 :     }
 739 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 740 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 741 :         std::to_string(sym1__));
 742 :     }
 743 :     if (emit_transformed_parameters__) {
 744 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 745 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 746 :           std::to_string(sym1__));
 747 :       }
 748 :     }
 749 :     if (emit_generated_quantities__) {}
 750 :   }
 751 :   inline void
 752 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 753 :                             emit_transformed_parameters__ = true, bool
 754 :                             emit_generated_quantities__ = true) const final {
 755 :     param_names__.emplace_back(std::string() + "rho");
 756 :     param_names__.emplace_back(std::string() + "sigma");
 757 :     param_names__.emplace_back(std::string() + "theta");
 758 :     param_names__.emplace_back(std::string() + "alpha");
 759 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 760 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 761 :         std::to_string(sym1__));
 762 :     }
 763 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 764 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 765 :         std::to_string(sym1__));
 766 :     }
 767 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 768 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 769 :         std::to_string(sym1__));
 770 :     }
 771 :     if (emit_transformed_parameters__) {
 772 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 773 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 774 :           std::to_string(sym1__));
 775 :       }
 776 :     }
 777 :     if (emit_generated_quantities__) {}
 778 :   }
 779 :   inline std::string get_constrained_sizedtypes() const {
 780 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 781 :   }
 782 :   inline std::string get_unconstrained_sizedtypes() const {
 783 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 784 :   }
 785 :   // Begin method overload boilerplate
 786 :   template <typename RNG> inline void
 787 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 788 :               Eigen::Matrix<double,-1,1>& vars, const bool
 789 :               emit_transformed_parameters = true, const bool
 790 :               emit_generated_quantities = true, std::ostream*
 791 :               pstream = nullptr) const {
 792 :     const size_t num_params__ = ((((((1 + 1) + 1) + 1) + K) + C) + C);
 793 :     const size_t num_transformed = emit_transformed_parameters * (K);
 794 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 795 :     const size_t num_to_write = num_params__ + num_transformed +
 796 :       num_gen_quantities;
 797 :     std::vector<int> params_i;
 798 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 799 :              std::numeric_limits<double>::quiet_NaN());
 800 :     write_array_impl(base_rng, params_r, params_i, vars,
 801 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 802 :   }
 803 :   template <typename RNG> inline void
 804 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 805 :               params_i, std::vector<double>& vars, bool
 806 :               emit_transformed_parameters = true, bool
 807 :               emit_generated_quantities = true, std::ostream*
 808 :               pstream = nullptr) const {
 809 :     const size_t num_params__ = ((((((1 + 1) + 1) + 1) + K) + C) + C);
 810 :     const size_t num_transformed = emit_transformed_parameters * (K);
 811 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 812 :     const size_t num_to_write = num_params__ + num_transformed +
 813 :       num_gen_quantities;
 814 :     vars = std::vector<double>(num_to_write,
 815 :              std::numeric_limits<double>::quiet_NaN());
 816 :     write_array_impl(base_rng, params_r, params_i, vars,
 817 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 818 :   }
 819 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 820 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 821 :     Eigen::Matrix<int,-1,1> params_i;
 822 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 823 :   }
 824 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 825 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 826 :            std::ostream* pstream = nullptr) const {
 827 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 828 :   }
 829 :   inline void
 830 :   transform_inits(const stan::io::var_context& context,
 831 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 832 :                   pstream = nullptr) const final {
 833 :     std::vector<double> params_r_vec(params_r.size());
 834 :     std::vector<int> params_i;
 835 :     transform_inits(context, params_i, params_r_vec, pstream);
 836 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 837 :                  params_r_vec.size());
 838 :   }
 839 :   inline void
 840 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 841 :                   params_i, std::vector<double>& vars, std::ostream*
 842 :                   pstream__ = nullptr) const {
 843 :     vars.resize(num_params_r__);
 844 :     transform_inits_impl(context, vars, pstream__);
 845 :   }
 846 :   inline void
 847 :   unconstrain_array(const std::vector<double>& params_constrained,
 848 :                     std::vector<double>& params_unconstrained, std::ostream*
 849 :                     pstream = nullptr) const {
 850 :     const std::vector<int> params_i;
 851 :     params_unconstrained = std::vector<double>(num_params_r__,
 852 :                              std::numeric_limits<double>::quiet_NaN());
 853 :     unconstrain_array_impl(params_constrained, params_i,
 854 :       params_unconstrained, pstream);
 855 :   }
 856 :   inline void
 857 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 858 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
 859 :                     std::ostream* pstream = nullptr) const {
 860 :     const std::vector<int> params_i;
 861 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
 862 :                              std::numeric_limits<double>::quiet_NaN());
 863 :     unconstrain_array_impl(params_constrained, params_i,
 864 :       params_unconstrained, pstream);
 865 :   }
 866 : };
 867 : }
 868 : using stan_model = model2934ad4ba3dd78__namespace::model2934ad4ba3dd78_;
 869 : #ifndef USING_R
 870 : // Boilerplate
 871 : stan::model::model_base&
 872 : new_model(stan::io::var_context& data_context, unsigned int seed,
 873 :           std::ostream* msg_stream) {
 874 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
 875 :   return *m;
 876 : }
 877 : stan::math::profile_map& get_stan_profile_data() {
 878 :   return model2934ad4ba3dd78__namespace::profiles__;
 879 : }
 880 : #endif
 881 : #endif
 882 : 
 883 : RCPP_MODULE(stan_fit4model2934ad4ba3dd78__mod) {
 884 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
 885 :       "stan_fit4model2934ad4ba3dd78_")
 886 : 
 887 :       .constructor<SEXP, SEXP, SEXP>()
 888 : 
 889 :       .method(
 890 :           "call_sampler",
 891 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
 892 :       .method(
 893 :           "param_names",
 894 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
 895 :       .method("param_names_oi",
 896 :               &rstan::stan_fit<stan_model,
 897 :                                boost::random::ecuyer1988>::param_names_oi)
 898 :       .method("param_fnames_oi",
 899 :               &rstan::stan_fit<stan_model,
 900 :                                boost::random::ecuyer1988>::param_fnames_oi)
 901 :       .method(
 902 :           "param_dims",
 903 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
 904 :       .method("param_dims_oi",
 905 :               &rstan::stan_fit<stan_model,
 906 :                                boost::random::ecuyer1988>::param_dims_oi)
 907 :       .method("update_param_oi",
 908 :               &rstan::stan_fit<stan_model,
 909 :                                boost::random::ecuyer1988>::update_param_oi)
 910 :       .method("param_oi_tidx",
 911 :               &rstan::stan_fit<stan_model,
 912 :                                boost::random::ecuyer1988>::param_oi_tidx)
 913 :       .method("grad_log_prob",
 914 :               &rstan::stan_fit<stan_model,
 915 :                                boost::random::ecuyer1988>::grad_log_prob)
 916 :       .method("log_prob",
 917 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
 918 :       .method("unconstrain_pars",
 919 :               &rstan::stan_fit<stan_model,
 920 :                                boost::random::ecuyer1988>::unconstrain_pars)
 921 :       .method("constrain_pars",
 922 :               &rstan::stan_fit<stan_model,
 923 :                                boost::random::ecuyer1988>::constrain_pars)
 924 :       .method(
 925 :           "num_pars_unconstrained",
 926 :           &rstan::stan_fit<stan_model,
 927 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
 928 :       .method(
 929 :           "unconstrained_param_names",
 930 :           &rstan::stan_fit<
 931 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
 932 :       .method(
 933 :           "constrained_param_names",
 934 :           &rstan::stan_fit<stan_model,
 935 :                            boost::random::ecuyer1988>::constrained_param_names)
 936 :       .method("standalone_gqs",
 937 :               &rstan::stan_fit<stan_model,
 938 :                                boost::random::ecuyer1988>::standalone_gqs);
 939 : }
 940 : 
 941 : 
 942 : // declarations
 943 : extern "C" {
 944 : SEXP file2934ad185c994d( ) ;
 945 : }
 946 : 
 947 : // definition
 948 : SEXP file2934ad185c994d() {
 949 :  return Rcpp::wrap("anon_model");
 950 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file2934ad185c994d.so' OBJECTS='file2934ad185c994d.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file2934ad185c994d.cpp -o file2934ad185c994d.o
if test  "zfile2934ad185c994d.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file2934ad185c994d.so file2934ad185c994d.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file2934ad185c994d.so file2934ad185c994d.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).
Chain 4: 
Chain 4: Gradient evaluation took 0.021875 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 218.75 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: 
Chain 1: Gradient evaluation took 0.076249 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 762.49 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: 
Chain 2: Gradient evaluation took 0.065366 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 653.66 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 3: 
Chain 3: Gradient evaluation took 0.070487 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 704.87 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 1080.08 seconds (Warm-up)
Chain 1:                568.191 seconds (Sampling)
Chain 1:                1648.27 seconds (Total)
Chain 1: 
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 1112.4 seconds (Warm-up)
Chain 2:                542.865 seconds (Sampling)
Chain 2:                1655.27 seconds (Total)
Chain 2: 
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 1143.44 seconds (Warm-up)
Chain 3:                550.777 seconds (Sampling)
Chain 3:                1694.22 seconds (Total)
Chain 3: 
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 1151.45 seconds (Warm-up)
Chain 4:                558.317 seconds (Sampling)
Chain 4:                1709.77 seconds (Total)
Chain 4: 
[1] "Done with 1"
[1] "Done with 2"
[1] "Done with 3"
[1] "Done with 4"
[1] "Done with 5"
[1] "Done with 6"
[1] "Done with 7"
[1] "Done with 8"
[1] "Done with 9"
[1] "Done with 10"
[1] "Done with 11"
[1] "Done with 12"
[1] "Done with 13"
[1] "Done with 14"
[1] "Done with 15"
[1] "Done with 16"
[1] "Done with 17"
[1] "Done with 18"
[1] "Done with 19"
[1] "Done with 20"
[1] "Done with 21"
[1] "Done with 22"
[1] "Done with 23"
[1] "Done with 24"
[1] "Done with 25"
[1] "Done with 26"
[1] "Done with 27"
[1] "Done with 28"
[1] "Done with 29"
[1] "Done with 30"
[1] "Done with 31"
[1] "Done with 32"
[1] "Done with 33"
[1] "Done with 34"
[1] "Done with 35"
[1] "Done with 36"
[1] "Done with 37"
[1] "Done with 38"
[1] "Done with 39"
[1] "Done with 40"
[1] "Done with 41"
[1] "Done with 42"
[1] "Done with 43"
[1] "Done with 44"
[1] "Done with 45"
[1] "Done with 46"
[1] "Done with 47"
[1] "Done with 48"
[1] "Done with 49"
[1] "Done with 50"
[1] "Done with 51"
[1] "Done with 52"
[1] "Done with 53"
[1] "Done with 54"
[1] "Done with 55"
[1] "Done with 56"
[1] "Done with 57"
[1] "Done with 58"
[1] "Done with 59"
[1] "Done with 60"
[1] "Done with 61"
[1] "Done with 62"
[1] "Done with 63"
[1] "Done with 64"
[1] "Done with 65"
[1] "Done with 66"
[1] "Done with 67"
[1] "Done with 68"
[1] "Done with 69"
[1] "Done with 70"
[1] "Done with 71"
[1] "Done with 72"
[1] "Done with 73"
[1] "Done with 74"
[1] "Done with 75"
[1] "Done with 76"
[1] "Done with 77"
[1] "Done with 78"
[1] "Done with 79"
[1] "Done with 80"
[1] "Done with 81"
[1] "Done with 82"
[1] "Done with 83"
[1] "Done with 84"
[1] "Done with 85"
[1] "Done with 86"
[1] "Done with 87"
[1] "Done with 88"
[1] "Done with 89"
[1] "Done with 90"
[1] "Done with 91"
[1] "Done with 92"
[1] "Done with 93"
[1] "Done with 94"
[1] "Done with 95"
[1] "Done with 96"
[1] "Done with 97"
[1] "Done with 98"
[1] "Done with 99"
[1] "Done with 100"
[1] "Done with 101"
[1] "Done with 102"
[1] "Done with 103"
[1] "Done with 104"
[1] "Done with 105"
[1] "Done with 106"
[1] "Done with 107"
[1] "Done with 108"
[1] "Done with 109"
[1] "Done with 110"
[1] "Done with 111"
[1] "Done with 112"
[1] "Done with 113"
[1] "Done with 114"
[1] "Done with 115"
[1] "Done with 116"
[1] "Done with 117"
[1] "Done with 118"
[1] "Done with 119"
[1] "Done with 120"
[1] "Done with 121"
[1] "Done with 122"
[1] "Done with 123"
[1] "Done with 124"
[1] "Done with 125"
[1] "Done with 126"
[1] "Done with 127"
[1] "Done with 128"
[1] "Done with 129"
[1] "Done with 130"
[1] "Done with 131"
[1] "Done with 132"
[1] "Done with 133"
[1] "Done with 134"
[1] "Done with 135"
[1] "Done with 136"
[1] "Done with 137"
[1] "Done with 138"
[1] "Done with 139"
[1] "Done with 140"
[1] "Done with 141"
[1] "Done with 142"
[1] "Done with 143"
[1] "Done with 144"
[1] "Done with 145"
[1] "Done with 146"
[1] "Done with 147"
[1] "Done with 148"
[1] "Done with 149"
[1] "Done with 150"
[1] "Done with 151"
[1] "Done with 152"
[1] "Done with 153"
[1] "Done with 154"
[1] "Done with 155"
[1] "Done with 156"
[1] "Done with 157"
[1] "Done with 158"
[1] "Done with 159"
[1] "Done with 160"
[1] "Done with 161"
[1] "Done with 162"
[1] "Done with 163"
[1] "Done with 164"
[1] "Done with 165"
[1] "Done with 166"
[1] "Done with 167"
[1] "Done with 168"
[1] "Done with 169"
[1] "Done with 170"
[1] "Done with 171"
[1] "Done with 172"
[1] "Done with 173"
[1] "Done with 174"
[1] "Done with 175"
[1] "Done with 176"
[1] "Done with 177"
[1] "Done with 178"
[1] "Done with 179"
[1] "Done with 180"
[1] "Done with 181"
[1] "Done with 182"
[1] "Done with 183"
[1] "Done with 184"
[1] "Done with 185"
[1] "Done with 186"
[1] "Done with 187"
[1] "Done with 188"
[1] "Done with 189"
[1] "Done with 190"
[1] "Done with 191"
[1] "Done with 192"
[1] "Done with 193"
[1] "Done with 194"
[1] "Done with 195"
[1] "Done with 196"
[1] "Done with 197"
[1] "Done with 198"
[1] "Done with 199"
[1] "Done with 200"
[1] "Done with 201"
[1] "Done with 202"
[1] "Done with 203"
[1] "Done with 204"
[1] "Done with 205"
[1] "Done with 206"
[1] "Done with 207"
[1] "Done with 208"
[1] "Done with 209"
[1] "Done with 210"
[1] "Done with 211"
[1] "Done with 212"
[1] "Done with 213"
[1] "Done with 214"
[1] "Done with 215"
[1] "Done with 216"
[1] "Done with 217"
[1] "Done with 218"
[1] "Done with 219"
[1] "Done with 220"
[1] "Done with 221"
[1] "Done with 222"
[1] "Done with 223"
[1] "Done with 224"
[1] "Done with 225"
[1] "Done with 226"
[1] "Done with 227"
[1] "Done with 228"
[1] "Done with 229"
[1] "Done with 230"
[1] "Done with 231"
[1] "Done with 232"
[1] "Done with 233"
[1] "Done with 234"
[1] "Done with 235"
[1] "Done with 236"
[1] "Done with 237"
[1] "Done with 238"
[1] "Done with 239"
[1] "Done with 240"
[1] "Done with 241"
[1] "Done with 242"
[1] "Done with 243"
[1] "Done with 244"
[1] "Done with 245"
[1] "Done with 246"
[1] "Done with 247"
[1] "Done with 248"
[1] "Done with 249"
[1] "Done with 250"
[1] "Done with 251"
[1] "Done with 252"
[1] "Done with 253"
[1] "Done with 254"
[1] "Done with 255"
[1] "Done with 256"
[1] "Done with 257"
[1] "Done with 258"
[1] "Done with 259"
[1] "Done with 260"
[1] "Done with 261"
[1] "Done with 262"
[1] "Done with 263"
[1] "Done with 264"
[1] "Done with 265"
[1] "Done with 266"
[1] "Done with 267"
[1] "Done with 268"
[1] "Done with 269"
[1] "Done with 270"
