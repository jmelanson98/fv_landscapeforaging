
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model1b629d627a5bda__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 64> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 27, column 2 to column 25)",
  25 :   " (in 'anon_model', line 28, column 2 to column 21)",
  26 :   " (in 'anon_model', line 29, column 2 to column 22)",
  27 :   " (in 'anon_model', line 30, column 2 to column 26)",
  28 :   " (in 'anon_model', line 33, column 2 to column 54)",
  29 :   " (in 'anon_model', line 34, column 2 to column 54)",
  30 :   " (in 'anon_model', line 37, column 2 to column 41)",
  31 :   " (in 'anon_model', line 38, column 2 to column 49)",
  32 :   " (in 'anon_model', line 43, column 2 to column 33)",
  33 :   " (in 'anon_model', line 44, column 2 to column 21)",
  34 :   " (in 'anon_model', line 45, column 2 to column 23)",
  35 :   " (in 'anon_model', line 47, column 2 to column 21)",
  36 :   " (in 'anon_model', line 52, column 4 to column 29)",
  37 :   " (in 'anon_model', line 53, column 4 to column 36)",
  38 :   " (in 'anon_model', line 54, column 4 to column 30)",
  39 :   " (in 'anon_model', line 55, column 11 to column 17)",
  40 :   " (in 'anon_model', line 55, column 4 to column 30)",
  41 :   " (in 'anon_model', line 56, column 14 to column 20)",
  42 :   " (in 'anon_model', line 56, column 4 to column 22)",
  43 :   " (in 'anon_model', line 65, column 6 to column 46)",
  44 :   " (in 'anon_model', line 68, column 6 to column 31)",
  45 :   " (in 'anon_model', line 69, column 6 to line 70, column 60)",
  46 :   " (in 'anon_model', line 74, column 6 to column 70)",
  47 :   " (in 'anon_model', line 77, column 6 to column 85)",
  48 :   " (in 'anon_model', line 63, column 24 to line 78, column 5)",
  49 :   " (in 'anon_model', line 63, column 4 to line 78, column 5)",
  50 :   " (in 'anon_model', line 80, column 11 to column 17)",
  51 :   " (in 'anon_model', line 80, column 4 to column 53)",
  52 :   " (in 'anon_model', line 81, column 4 to column 37)",
  53 :   " (in 'anon_model', line 51, column 17 to line 82, column 3)",
  54 :   " (in 'anon_model', line 51, column 2 to line 82, column 3)",
  55 :   " (in 'anon_model', line 4, column 2 to column 17)",
  56 :   " (in 'anon_model', line 5, column 2 to column 17)",
  57 :   " (in 'anon_model', line 6, column 2 to column 27)",
  58 :   " (in 'anon_model', line 7, column 2 to column 25)",
  59 :   " (in 'anon_model', line 8, column 9 to column 20)",
  60 :   " (in 'anon_model', line 8, column 2 to column 34)",
  61 :   " (in 'anon_model', line 9, column 20 to column 31)",
  62 :   " (in 'anon_model', line 9, column 2 to column 33)",
  63 :   " (in 'anon_model', line 10, column 18 to column 19)",
  64 :   " (in 'anon_model', line 10, column 2 to column 21)",
  65 :   " (in 'anon_model', line 11, column 14 to column 15)",
  66 :   " (in 'anon_model', line 11, column 2 to column 17)",
  67 :   " (in 'anon_model', line 12, column 18 to column 19)",
  68 :   " (in 'anon_model', line 12, column 2 to column 21)",
  69 :   " (in 'anon_model', line 13, column 14 to column 15)",
  70 :   " (in 'anon_model', line 13, column 2 to column 17)",
  71 :   " (in 'anon_model', line 14, column 10 to column 11)",
  72 :   " (in 'anon_model', line 14, column 2 to column 13)",
  73 :   " (in 'anon_model', line 15, column 13 to column 22)",
  74 :   " (in 'anon_model', line 15, column 2 to column 24)",
  75 :   " (in 'anon_model', line 16, column 2 to column 15)",
  76 :   " (in 'anon_model', line 17, column 2 to column 15)",
  77 :   " (in 'anon_model', line 18, column 2 to column 15)",
  78 :   " (in 'anon_model', line 19, column 2 to column 15)",
  79 :   " (in 'anon_model', line 22, column 2 to column 18)",
  80 :   " (in 'anon_model', line 23, column 2 to column 22)",
  81 :   " (in 'anon_model', line 24, column 2 to column 20)",
  82 :   " (in 'anon_model', line 27, column 18 to column 19)",
  83 :   " (in 'anon_model', line 30, column 9 to column 20)",
  84 :   " (in 'anon_model', line 33, column 8 to column 9)",
  85 :   " (in 'anon_model', line 34, column 8 to column 9)",
  86 :   " (in 'anon_model', line 38, column 9 to column 20)"};
  87 : class model1b629d627a5bda_ final : public model_base_crtp<model1b629d627a5bda_> {
  88 : private:
  89 :   int C;
  90 :   int L;
  91 :   int total_traps;
  92 :   int total_obs;
  93 :   Eigen::Matrix<double,-1,-1> trap_pos_data__;
  94 :   std::vector<int> sample_effort;
  95 :   std::vector<int> traps_start;
  96 :   std::vector<int> traps_n;
  97 :   std::vector<int> colony_land;
  98 :   std::vector<int> y_start;
  99 :   std::vector<int> y_n;
 100 :   std::vector<int> y_flat;
 101 :   double upper_y;
 102 :   double upper_x;
 103 :   double lower_y;
 104 :   double lower_x;
 105 :   double Rmax;
 106 :   double steepness;
 107 :   double penalty;
 108 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap_pos{nullptr, 0, 0};
 109 : public:
 110 :   ~model1b629d627a5bda_() {}
 111 :   model1b629d627a5bda_(stan::io::var_context& context__, unsigned int
 112 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
 113 :       : model_base_crtp(0) {
 114 :     int current_statement__ = 0;
 115 :     using local_scalar_t__ = double;
 116 :     boost::ecuyer1988 base_rng__ =
 117 :       stan::services::util::create_rng(random_seed__, 0);
 118 :     // suppress unused var warning
 119 :     (void) base_rng__;
 120 :     static constexpr const char* function__ =
 121 :       "model1b629d627a5bda__namespace::model1b629d627a5bda_";
 122 :     // suppress unused var warning
 123 :     (void) function__;
 124 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 125 :     // suppress unused var warning
 126 :     (void) DUMMY_VAR__;
 127 :     try {
 128 :       int pos__ = std::numeric_limits<int>::min();
 129 :       pos__ = 1;
 130 :       current_statement__ = 32;
 131 :       context__.validate_dims("data initialization", "C", "int",
 132 :         std::vector<size_t>{});
 133 :       C = std::numeric_limits<int>::min();
 134 :       current_statement__ = 32;
 135 :       C = context__.vals_i("C")[(1 - 1)];
 136 :       current_statement__ = 32;
 137 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 138 :       current_statement__ = 33;
 139 :       context__.validate_dims("data initialization", "L", "int",
 140 :         std::vector<size_t>{});
 141 :       L = std::numeric_limits<int>::min();
 142 :       current_statement__ = 33;
 143 :       L = context__.vals_i("L")[(1 - 1)];
 144 :       current_statement__ = 33;
 145 :       stan::math::check_greater_or_equal(function__, "L", L, 1);
 146 :       current_statement__ = 34;
 147 :       context__.validate_dims("data initialization", "total_traps", "int",
 148 :         std::vector<size_t>{});
 149 :       total_traps = std::numeric_limits<int>::min();
 150 :       current_statement__ = 34;
 151 :       total_traps = context__.vals_i("total_traps")[(1 - 1)];
 152 :       current_statement__ = 34;
 153 :       stan::math::check_greater_or_equal(function__, "total_traps",
 154 :         total_traps, 1);
 155 :       current_statement__ = 35;
 156 :       context__.validate_dims("data initialization", "total_obs", "int",
 157 :         std::vector<size_t>{});
 158 :       total_obs = std::numeric_limits<int>::min();
 159 :       current_statement__ = 35;
 160 :       total_obs = context__.vals_i("total_obs")[(1 - 1)];
 161 :       current_statement__ = 35;
 162 :       stan::math::check_greater_or_equal(function__, "total_obs", total_obs,
 163 :         0);
 164 :       current_statement__ = 36;
 165 :       stan::math::validate_non_negative_index("trap_pos", "total_traps",
 166 :         total_traps);
 167 :       current_statement__ = 37;
 168 :       context__.validate_dims("data initialization", "trap_pos", "double",
 169 :         std::vector<size_t>{static_cast<size_t>(total_traps),
 170 :           static_cast<size_t>(2)});
 171 :       trap_pos_data__ = Eigen::Matrix<double,-1,-1>::Constant(total_traps, 2,
 172 :                           std::numeric_limits<double>::quiet_NaN());
 173 :       new (&trap_pos)
 174 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_pos_data__.data(),
 175 :         total_traps, 2);
 176 :       {
 177 :         std::vector<local_scalar_t__> trap_pos_flat__;
 178 :         current_statement__ = 37;
 179 :         trap_pos_flat__ = context__.vals_r("trap_pos");
 180 :         current_statement__ = 37;
 181 :         pos__ = 1;
 182 :         current_statement__ = 37;
 183 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 184 :           current_statement__ = 37;
 185 :           for (int sym2__ = 1; sym2__ <= total_traps; ++sym2__) {
 186 :             current_statement__ = 37;
 187 :             stan::model::assign(trap_pos, trap_pos_flat__[(pos__ - 1)],
 188 :               "assigning variable trap_pos", stan::model::index_uni(sym2__),
 189 :               stan::model::index_uni(sym1__));
 190 :             current_statement__ = 37;
 191 :             pos__ = (pos__ + 1);
 192 :           }
 193 :         }
 194 :       }
 195 :       current_statement__ = 38;
 196 :       stan::math::validate_non_negative_index("sample_effort", "total_traps",
 197 :         total_traps);
 198 :       current_statement__ = 39;
 199 :       context__.validate_dims("data initialization", "sample_effort", "int",
 200 :         std::vector<size_t>{static_cast<size_t>(total_traps)});
 201 :       sample_effort = std::vector<int>(total_traps,
 202 :                         std::numeric_limits<int>::min());
 203 :       current_statement__ = 39;
 204 :       sample_effort = context__.vals_i("sample_effort");
 205 :       current_statement__ = 40;
 206 :       stan::math::validate_non_negative_index("traps_start", "L", L);
 207 :       current_statement__ = 41;
 208 :       context__.validate_dims("data initialization", "traps_start", "int",
 209 :         std::vector<size_t>{static_cast<size_t>(L)});
 210 :       traps_start = std::vector<int>(L, std::numeric_limits<int>::min());
 211 :       current_statement__ = 41;
 212 :       traps_start = context__.vals_i("traps_start");
 213 :       current_statement__ = 42;
 214 :       stan::math::validate_non_negative_index("traps_n", "L", L);
 215 :       current_statement__ = 43;
 216 :       context__.validate_dims("data initialization", "traps_n", "int",
 217 :         std::vector<size_t>{static_cast<size_t>(L)});
 218 :       traps_n = std::vector<int>(L, std::numeric_limits<int>::min());
 219 :       current_statement__ = 43;
 220 :       traps_n = context__.vals_i("traps_n");
 221 :       current_statement__ = 44;
 222 :       stan::math::validate_non_negative_index("colony_land", "C", C);
 223 :       current_statement__ = 45;
 224 :       context__.validate_dims("data initialization", "colony_land", "int",
 225 :         std::vector<size_t>{static_cast<size_t>(C)});
 226 :       colony_land = std::vector<int>(C, std::numeric_limits<int>::min());
 227 :       current_statement__ = 45;
 228 :       colony_land = context__.vals_i("colony_land");
 229 :       current_statement__ = 46;
 230 :       stan::math::validate_non_negative_index("y_start", "C", C);
 231 :       current_statement__ = 47;
 232 :       context__.validate_dims("data initialization", "y_start", "int",
 233 :         std::vector<size_t>{static_cast<size_t>(C)});
 234 :       y_start = std::vector<int>(C, std::numeric_limits<int>::min());
 235 :       current_statement__ = 47;
 236 :       y_start = context__.vals_i("y_start");
 237 :       current_statement__ = 48;
 238 :       stan::math::validate_non_negative_index("y_n", "C", C);
 239 :       current_statement__ = 49;
 240 :       context__.validate_dims("data initialization", "y_n", "int",
 241 :         std::vector<size_t>{static_cast<size_t>(C)});
 242 :       y_n = std::vector<int>(C, std::numeric_limits<int>::min());
 243 :       current_statement__ = 49;
 244 :       y_n = context__.vals_i("y_n");
 245 :       current_statement__ = 50;
 246 :       stan::math::validate_non_negative_index("y_flat", "total_obs",
 247 :         total_obs);
 248 :       current_statement__ = 51;
 249 :       context__.validate_dims("data initialization", "y_flat", "int",
 250 :         std::vector<size_t>{static_cast<size_t>(total_obs)});
 251 :       y_flat = std::vector<int>(total_obs, std::numeric_limits<int>::min());
 252 :       current_statement__ = 51;
 253 :       y_flat = context__.vals_i("y_flat");
 254 :       current_statement__ = 52;
 255 :       context__.validate_dims("data initialization", "upper_y", "double",
 256 :         std::vector<size_t>{});
 257 :       upper_y = std::numeric_limits<double>::quiet_NaN();
 258 :       current_statement__ = 52;
 259 :       upper_y = context__.vals_r("upper_y")[(1 - 1)];
 260 :       current_statement__ = 53;
 261 :       context__.validate_dims("data initialization", "upper_x", "double",
 262 :         std::vector<size_t>{});
 263 :       upper_x = std::numeric_limits<double>::quiet_NaN();
 264 :       current_statement__ = 53;
 265 :       upper_x = context__.vals_r("upper_x")[(1 - 1)];
 266 :       current_statement__ = 54;
 267 :       context__.validate_dims("data initialization", "lower_y", "double",
 268 :         std::vector<size_t>{});
 269 :       lower_y = std::numeric_limits<double>::quiet_NaN();
 270 :       current_statement__ = 54;
 271 :       lower_y = context__.vals_r("lower_y")[(1 - 1)];
 272 :       current_statement__ = 55;
 273 :       context__.validate_dims("data initialization", "lower_x", "double",
 274 :         std::vector<size_t>{});
 275 :       lower_x = std::numeric_limits<double>::quiet_NaN();
 276 :       current_statement__ = 55;
 277 :       lower_x = context__.vals_r("lower_x")[(1 - 1)];
 278 :       current_statement__ = 56;
 279 :       Rmax = std::numeric_limits<double>::quiet_NaN();
 280 :       current_statement__ = 56;
 281 :       Rmax = 2.0;
 282 :       current_statement__ = 57;
 283 :       steepness = std::numeric_limits<double>::quiet_NaN();
 284 :       current_statement__ = 57;
 285 :       steepness = 10;
 286 :       current_statement__ = 58;
 287 :       penalty = std::numeric_limits<double>::quiet_NaN();
 288 :       current_statement__ = 58;
 289 :       penalty = 10;
 290 :       current_statement__ = 59;
 291 :       stan::math::validate_non_negative_index("rho", "L", L);
 292 :       current_statement__ = 60;
 293 :       stan::math::validate_non_negative_index("eps", "total_traps",
 294 :         total_traps);
 295 :       current_statement__ = 61;
 296 :       stan::math::validate_non_negative_index("delta_x", "C", C);
 297 :       current_statement__ = 62;
 298 :       stan::math::validate_non_negative_index("delta_y", "C", C);
 299 :       current_statement__ = 63;
 300 :       stan::math::validate_non_negative_index("eps_scale", "total_traps",
 301 :         total_traps);
 302 :     } catch (const std::exception& e) {
 303 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 304 :     }
 305 :     num_params_r__ = L + 1 + 1 + total_traps + C + C;
 306 :   }
 307 :   inline std::string model_name() const final {
 308 :     return "model1b629d627a5bda_";
 309 :   }
 310 :   inline std::vector<std::string> model_compile_info() const noexcept {
 311 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 312 :              "stancflags = --"};
 313 :   }
 314 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 315 :             stan::require_vector_like_t<VecR>* = nullptr,
 316 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 317 :   inline stan::scalar_type_t<VecR>
 318 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 319 :                 pstream__ = nullptr) const {
 320 :     using T__ = stan::scalar_type_t<VecR>;
 321 :     using local_scalar_t__ = T__;
 322 :     T__ lp__(0.0);
 323 :     stan::math::accumulator<T__> lp_accum__;
 324 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 325 :     int current_statement__ = 0;
 326 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 327 :     // suppress unused var warning
 328 :     (void) DUMMY_VAR__;
 329 :     static constexpr const char* function__ =
 330 :       "model1b629d627a5bda__namespace::log_prob";
 331 :     // suppress unused var warning
 332 :     (void) function__;
 333 :     try {
 334 :       Eigen::Matrix<local_scalar_t__,-1,1> rho =
 335 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L, DUMMY_VAR__);
 336 :       current_statement__ = 1;
 337 :       rho = in__.template read_constrain_lb<
 338 :               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, L);
 339 :       local_scalar_t__ beta = DUMMY_VAR__;
 340 :       current_statement__ = 2;
 341 :       beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 342 :                lp__);
 343 :       local_scalar_t__ sigma = DUMMY_VAR__;
 344 :       current_statement__ = 3;
 345 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 346 :                 jacobian__>(0, lp__);
 347 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 348 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(total_traps,
 349 :           DUMMY_VAR__);
 350 :       current_statement__ = 4;
 351 :       eps = in__.template read<
 352 :               Eigen::Matrix<local_scalar_t__,-1,1>>(total_traps);
 353 :       std::vector<local_scalar_t__> delta_x =
 354 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 355 :       current_statement__ = 5;
 356 :       delta_x = in__.template read_constrain_lub<
 357 :                   std::vector<local_scalar_t__>, jacobian__>(lower_x,
 358 :                   upper_x, lp__, C);
 359 :       std::vector<local_scalar_t__> delta_y =
 360 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 361 :       current_statement__ = 6;
 362 :       delta_y = in__.template read_constrain_lub<
 363 :                   std::vector<local_scalar_t__>, jacobian__>(lower_y,
 364 :                   upper_y, lp__, C);
 365 :       local_scalar_t__ sigma_sqrt = DUMMY_VAR__;
 366 :       current_statement__ = 7;
 367 :       sigma_sqrt = stan::math::sqrt(sigma);
 368 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 369 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(total_traps,
 370 :           DUMMY_VAR__);
 371 :       current_statement__ = 8;
 372 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 373 :         "assigning variable eps_scale");
 374 :       current_statement__ = 7;
 375 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 376 :         sigma_sqrt, 0);
 377 :       {
 378 :         current_statement__ = 9;
 379 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho,
 380 :                          stan::math::log(0.5), 0.5));
 381 :         current_statement__ = 10;
 382 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(beta, 0, 1));
 383 :         current_statement__ = 11;
 384 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 1));
 385 :         current_statement__ = 12;
 386 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 387 :         current_statement__ = 31;
 388 :         for (int i = 1; i <= C; ++i) {
 389 :           int lid = std::numeric_limits<int>::min();
 390 :           current_statement__ = 13;
 391 :           lid = stan::model::rvalue(colony_land, "colony_land",
 392 :                   stan::model::index_uni(i));
 393 :           int start_tr = std::numeric_limits<int>::min();
 394 :           current_statement__ = 14;
 395 :           start_tr = stan::model::rvalue(traps_start, "traps_start",
 396 :                        stan::model::index_uni(lid));
 397 :           int num_tr = std::numeric_limits<int>::min();
 398 :           current_statement__ = 15;
 399 :           num_tr = stan::model::rvalue(traps_n, "traps_n",
 400 :                      stan::model::index_uni(lid));
 401 :           current_statement__ = 16;
 402 :           stan::math::validate_non_negative_index("lambda_row", "num_tr",
 403 :             num_tr);
 404 :           Eigen::Matrix<local_scalar_t__,-1,1> lambda_row =
 405 :             Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_tr,
 406 :               DUMMY_VAR__);
 407 :           current_statement__ = 18;
 408 :           stan::math::validate_non_negative_index("y_seg", "num_tr", num_tr);
 409 :           std::vector<int> y_seg =
 410 :             std::vector<int>(num_tr, std::numeric_limits<int>::min());
 411 :           current_statement__ = 26;
 412 :           for (int t = 1; t <= num_tr; ++t) {
 413 :             current_statement__ = 20;
 414 :             stan::model::assign(y_seg,
 415 :               stan::model::rvalue(y_flat, "y_flat",
 416 :                 stan::model::index_uni(
 417 :                   ((stan::model::rvalue(y_start, "y_start",
 418 :                       stan::model::index_uni(i)) + t) - 1))),
 419 :               "assigning variable y_seg", stan::model::index_uni(t));
 420 :             int k = std::numeric_limits<int>::min();
 421 :             current_statement__ = 21;
 422 :             k = ((start_tr + t) - 1);
 423 :             local_scalar_t__ dis = DUMMY_VAR__;
 424 :             current_statement__ = 22;
 425 :             dis = stan::math::sqrt(
 426 :                     (stan::math::square(
 427 :                        (stan::model::rvalue(delta_x, "delta_x",
 428 :                           stan::model::index_uni(i)) -
 429 :                        stan::model::rvalue(trap_pos, "trap_pos",
 430 :                          stan::model::index_uni(k), stan::model::index_uni(1))))
 431 :                     +
 432 :                     stan::math::square(
 433 :                       (stan::model::rvalue(delta_y, "delta_y",
 434 :                          stan::model::index_uni(i)) -
 435 :                       stan::model::rvalue(trap_pos, "trap_pos",
 436 :                         stan::model::index_uni(k), stan::model::index_uni(2))))));
 437 :             current_statement__ = 23;
 438 :             lp_accum__.add((stan::model::rvalue(y_seg, "y_seg",
 439 :                               stan::model::index_uni(t)) * (-penalty *
 440 :               stan::math::log1p_exp(((dis - Rmax) * steepness)))));
 441 :             current_statement__ = 24;
 442 :             stan::model::assign(lambda_row, (((-0.5 *
 443 :               stan::math::pow((dis /
 444 :                 stan::model::rvalue(rho, "rho", stan::model::index_uni(lid))),
 445 :                 2)) + (beta *
 446 :               stan::model::rvalue(sample_effort, "sample_effort",
 447 :                 stan::model::index_uni(k)))) +
 448 :               stan::model::rvalue(eps_scale, "eps_scale",
 449 :                 stan::model::index_uni(k))), "assigning variable lambda_row",
 450 :               stan::model::index_uni(t));
 451 :           }
 452 :           current_statement__ = 27;
 453 :           stan::math::validate_non_negative_index("multi_probs", "num_tr",
 454 :             num_tr);
 455 :           Eigen::Matrix<local_scalar_t__,-1,1> multi_probs =
 456 :             Eigen::Matrix<local_scalar_t__,-1,1>::Constant(num_tr,
 457 :               DUMMY_VAR__);
 458 :           current_statement__ = 28;
 459 :           stan::model::assign(multi_probs, stan::math::softmax(lambda_row),
 460 :             "assigning variable multi_probs");
 461 :           current_statement__ = 29;
 462 :           lp_accum__.add(stan::math::multinomial_lpmf<propto__>(y_seg,
 463 :                            multi_probs));
 464 :         }
 465 :       }
 466 :     } catch (const std::exception& e) {
 467 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 468 :     }
 469 :     lp_accum__.add(lp__);
 470 :     return lp_accum__.sum();
 471 :   }
 472 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 473 :             stan::require_vector_like_vt<std::is_floating_point,
 474 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 475 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 476 :             VecVar>* = nullptr>
 477 :   inline void
 478 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 479 :                    VecVar& vars__, const bool
 480 :                    emit_transformed_parameters__ = true, const bool
 481 :                    emit_generated_quantities__ = true, std::ostream*
 482 :                    pstream__ = nullptr) const {
 483 :     using local_scalar_t__ = double;
 484 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 485 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 486 :     static constexpr bool propto__ = true;
 487 :     // suppress unused var warning
 488 :     (void) propto__;
 489 :     double lp__ = 0.0;
 490 :     // suppress unused var warning
 491 :     (void) lp__;
 492 :     int current_statement__ = 0;
 493 :     stan::math::accumulator<double> lp_accum__;
 494 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 495 :     // suppress unused var warning
 496 :     (void) DUMMY_VAR__;
 497 :     constexpr bool jacobian__ = false;
 498 :     static constexpr const char* function__ =
 499 :       "model1b629d627a5bda__namespace::write_array";
 500 :     // suppress unused var warning
 501 :     (void) function__;
 502 :     try {
 503 :       Eigen::Matrix<double,-1,1> rho =
 504 :         Eigen::Matrix<double,-1,1>::Constant(L,
 505 :           std::numeric_limits<double>::quiet_NaN());
 506 :       current_statement__ = 1;
 507 :       rho = in__.template read_constrain_lb<
 508 :               Eigen::Matrix<local_scalar_t__,-1,1>, jacobian__>(0, lp__, L);
 509 :       double beta = std::numeric_limits<double>::quiet_NaN();
 510 :       current_statement__ = 2;
 511 :       beta = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 512 :                lp__);
 513 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 514 :       current_statement__ = 3;
 515 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 516 :                 jacobian__>(0, lp__);
 517 :       Eigen::Matrix<double,-1,1> eps =
 518 :         Eigen::Matrix<double,-1,1>::Constant(total_traps,
 519 :           std::numeric_limits<double>::quiet_NaN());
 520 :       current_statement__ = 4;
 521 :       eps = in__.template read<
 522 :               Eigen::Matrix<local_scalar_t__,-1,1>>(total_traps);
 523 :       std::vector<double> delta_x =
 524 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 525 :       current_statement__ = 5;
 526 :       delta_x = in__.template read_constrain_lub<
 527 :                   std::vector<local_scalar_t__>, jacobian__>(lower_x,
 528 :                   upper_x, lp__, C);
 529 :       std::vector<double> delta_y =
 530 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 531 :       current_statement__ = 6;
 532 :       delta_y = in__.template read_constrain_lub<
 533 :                   std::vector<local_scalar_t__>, jacobian__>(lower_y,
 534 :                   upper_y, lp__, C);
 535 :       double sigma_sqrt = std::numeric_limits<double>::quiet_NaN();
 536 :       Eigen::Matrix<double,-1,1> eps_scale =
 537 :         Eigen::Matrix<double,-1,1>::Constant(total_traps,
 538 :           std::numeric_limits<double>::quiet_NaN());
 539 :       out__.write(rho);
 540 :       out__.write(beta);
 541 :       out__.write(sigma);
 542 :       out__.write(eps);
 543 :       out__.write(delta_x);
 544 :       out__.write(delta_y);
 545 :       if (stan::math::logical_negation(
 546 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 547 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 548 :         return ;
 549 :       }
 550 :       current_statement__ = 7;
 551 :       sigma_sqrt = stan::math::sqrt(sigma);
 552 :       current_statement__ = 8;
 553 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 554 :         "assigning variable eps_scale");
 555 :       current_statement__ = 7;
 556 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 557 :         sigma_sqrt, 0);
 558 :       if (emit_transformed_parameters__) {
 559 :         out__.write(sigma_sqrt);
 560 :         out__.write(eps_scale);
 561 :       }
 562 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 563 :         return ;
 564 :       }
 565 :     } catch (const std::exception& e) {
 566 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 567 :     }
 568 :   }
 569 :   template <typename VecVar, typename VecI,
 570 :             stan::require_vector_t<VecVar>* = nullptr,
 571 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 572 :   inline void
 573 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 574 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 575 :     using local_scalar_t__ = double;
 576 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 577 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 578 :     int current_statement__ = 0;
 579 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 580 :     // suppress unused var warning
 581 :     (void) DUMMY_VAR__;
 582 :     try {
 583 :       int pos__ = std::numeric_limits<int>::min();
 584 :       pos__ = 1;
 585 :       Eigen::Matrix<local_scalar_t__,-1,1> rho =
 586 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L, DUMMY_VAR__);
 587 :       current_statement__ = 1;
 588 :       stan::model::assign(rho,
 589 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(L),
 590 :         "assigning variable rho");
 591 :       out__.write_free_lb(0, rho);
 592 :       local_scalar_t__ beta = DUMMY_VAR__;
 593 :       current_statement__ = 2;
 594 :       beta = in__.read<local_scalar_t__>();
 595 :       out__.write_free_lb(0, beta);
 596 :       local_scalar_t__ sigma = DUMMY_VAR__;
 597 :       current_statement__ = 3;
 598 :       sigma = in__.read<local_scalar_t__>();
 599 :       out__.write_free_lb(0, sigma);
 600 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 601 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(total_traps,
 602 :           DUMMY_VAR__);
 603 :       current_statement__ = 4;
 604 :       stan::model::assign(eps,
 605 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(total_traps),
 606 :         "assigning variable eps");
 607 :       out__.write(eps);
 608 :       std::vector<local_scalar_t__> delta_x =
 609 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 610 :       current_statement__ = 5;
 611 :       stan::model::assign(delta_x,
 612 :         in__.read<std::vector<local_scalar_t__>>(C),
 613 :         "assigning variable delta_x");
 614 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 615 :       std::vector<local_scalar_t__> delta_y =
 616 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 617 :       current_statement__ = 6;
 618 :       stan::model::assign(delta_y,
 619 :         in__.read<std::vector<local_scalar_t__>>(C),
 620 :         "assigning variable delta_y");
 621 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 622 :     } catch (const std::exception& e) {
 623 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 624 :     }
 625 :   }
 626 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 627 :   inline void
 628 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 629 :                        vars__, std::ostream* pstream__ = nullptr) const {
 630 :     using local_scalar_t__ = double;
 631 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 632 :     int current_statement__ = 0;
 633 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 634 :     // suppress unused var warning
 635 :     (void) DUMMY_VAR__;
 636 :     try {
 637 :       current_statement__ = 1;
 638 :       context__.validate_dims("parameter initialization", "rho", "double",
 639 :         std::vector<size_t>{static_cast<size_t>(L)});
 640 :       current_statement__ = 2;
 641 :       context__.validate_dims("parameter initialization", "beta", "double",
 642 :         std::vector<size_t>{});
 643 :       current_statement__ = 3;
 644 :       context__.validate_dims("parameter initialization", "sigma", "double",
 645 :         std::vector<size_t>{});
 646 :       current_statement__ = 4;
 647 :       context__.validate_dims("parameter initialization", "eps", "double",
 648 :         std::vector<size_t>{static_cast<size_t>(total_traps)});
 649 :       current_statement__ = 5;
 650 :       context__.validate_dims("parameter initialization", "delta_x",
 651 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 652 :       current_statement__ = 6;
 653 :       context__.validate_dims("parameter initialization", "delta_y",
 654 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 655 :       int pos__ = std::numeric_limits<int>::min();
 656 :       pos__ = 1;
 657 :       Eigen::Matrix<local_scalar_t__,-1,1> rho =
 658 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L, DUMMY_VAR__);
 659 :       {
 660 :         std::vector<local_scalar_t__> rho_flat__;
 661 :         current_statement__ = 1;
 662 :         rho_flat__ = context__.vals_r("rho");
 663 :         current_statement__ = 1;
 664 :         pos__ = 1;
 665 :         current_statement__ = 1;
 666 :         for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
 667 :           current_statement__ = 1;
 668 :           stan::model::assign(rho, rho_flat__[(pos__ - 1)],
 669 :             "assigning variable rho", stan::model::index_uni(sym1__));
 670 :           current_statement__ = 1;
 671 :           pos__ = (pos__ + 1);
 672 :         }
 673 :       }
 674 :       out__.write_free_lb(0, rho);
 675 :       local_scalar_t__ beta = DUMMY_VAR__;
 676 :       current_statement__ = 2;
 677 :       beta = context__.vals_r("beta")[(1 - 1)];
 678 :       out__.write_free_lb(0, beta);
 679 :       local_scalar_t__ sigma = DUMMY_VAR__;
 680 :       current_statement__ = 3;
 681 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 682 :       out__.write_free_lb(0, sigma);
 683 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 684 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(total_traps,
 685 :           DUMMY_VAR__);
 686 :       {
 687 :         std::vector<local_scalar_t__> eps_flat__;
 688 :         current_statement__ = 4;
 689 :         eps_flat__ = context__.vals_r("eps");
 690 :         current_statement__ = 4;
 691 :         pos__ = 1;
 692 :         current_statement__ = 4;
 693 :         for (int sym1__ = 1; sym1__ <= total_traps; ++sym1__) {
 694 :           current_statement__ = 4;
 695 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 696 :             "assigning variable eps", stan::model::index_uni(sym1__));
 697 :           current_statement__ = 4;
 698 :           pos__ = (pos__ + 1);
 699 :         }
 700 :       }
 701 :       out__.write(eps);
 702 :       std::vector<local_scalar_t__> delta_x =
 703 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 704 :       current_statement__ = 5;
 705 :       delta_x = context__.vals_r("delta_x");
 706 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 707 :       std::vector<local_scalar_t__> delta_y =
 708 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 709 :       current_statement__ = 6;
 710 :       delta_y = context__.vals_r("delta_y");
 711 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 712 :     } catch (const std::exception& e) {
 713 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 714 :     }
 715 :   }
 716 :   inline void
 717 :   get_param_names(std::vector<std::string>& names__, const bool
 718 :                   emit_transformed_parameters__ = true, const bool
 719 :                   emit_generated_quantities__ = true) const {
 720 :     names__ = std::vector<std::string>{"rho", "beta", "sigma", "eps",
 721 :                 "delta_x", "delta_y"};
 722 :     if (emit_transformed_parameters__) {
 723 :       std::vector<std::string> temp{"sigma_sqrt", "eps_scale"};
 724 :       names__.reserve(names__.size() + temp.size());
 725 :       names__.insert(names__.end(), temp.begin(), temp.end());
 726 :     }
 727 :     if (emit_generated_quantities__) {}
 728 :   }
 729 :   inline void
 730 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 731 :            emit_transformed_parameters__ = true, const bool
 732 :            emit_generated_quantities__ = true) const {
 733 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{static_cast<
 734 :                                                                     size_t>(L)},
 735 :                 std::vector<size_t>{}, std::vector<size_t>{},
 736 :                 std::vector<size_t>{static_cast<size_t>(total_traps)},
 737 :                 std::vector<size_t>{static_cast<size_t>(C)},
 738 :                 std::vector<size_t>{static_cast<size_t>(C)}};
 739 :     if (emit_transformed_parameters__) {
 740 :       std::vector<std::vector<size_t>>
 741 :         temp{std::vector<size_t>{},
 742 :              std::vector<size_t>{static_cast<size_t>(total_traps)}};
 743 :       dimss__.reserve(dimss__.size() + temp.size());
 744 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 745 :     }
 746 :     if (emit_generated_quantities__) {}
 747 :   }
 748 :   inline void
 749 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 750 :                           emit_transformed_parameters__ = true, bool
 751 :                           emit_generated_quantities__ = true) const final {
 752 :     for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
 753 :       param_names__.emplace_back(std::string() + "rho" + '.' +
 754 :         std::to_string(sym1__));
 755 :     }
 756 :     param_names__.emplace_back(std::string() + "beta");
 757 :     param_names__.emplace_back(std::string() + "sigma");
 758 :     for (int sym1__ = 1; sym1__ <= total_traps; ++sym1__) {
 759 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 760 :         std::to_string(sym1__));
 761 :     }
 762 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 763 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 764 :         std::to_string(sym1__));
 765 :     }
 766 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 767 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 768 :         std::to_string(sym1__));
 769 :     }
 770 :     if (emit_transformed_parameters__) {
 771 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
 772 :       for (int sym1__ = 1; sym1__ <= total_traps; ++sym1__) {
 773 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 774 :           std::to_string(sym1__));
 775 :       }
 776 :     }
 777 :     if (emit_generated_quantities__) {}
 778 :   }
 779 :   inline void
 780 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 781 :                             emit_transformed_parameters__ = true, bool
 782 :                             emit_generated_quantities__ = true) const final {
 783 :     for (int sym1__ = 1; sym1__ <= L; ++sym1__) {
 784 :       param_names__.emplace_back(std::string() + "rho" + '.' +
 785 :         std::to_string(sym1__));
 786 :     }
 787 :     param_names__.emplace_back(std::string() + "beta");
 788 :     param_names__.emplace_back(std::string() + "sigma");
 789 :     for (int sym1__ = 1; sym1__ <= total_traps; ++sym1__) {
 790 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 791 :         std::to_string(sym1__));
 792 :     }
 793 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 794 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 795 :         std::to_string(sym1__));
 796 :     }
 797 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 798 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 799 :         std::to_string(sym1__));
 800 :     }
 801 :     if (emit_transformed_parameters__) {
 802 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
 803 :       for (int sym1__ = 1; sym1__ <= total_traps; ++sym1__) {
 804 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 805 :           std::to_string(sym1__));
 806 :       }
 807 :     }
 808 :     if (emit_generated_quantities__) {}
 809 :   }
 810 :   inline std::string get_constrained_sizedtypes() const {
 811 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(L) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(total_traps) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(total_traps) + "},\"block\":\"transformed_parameters\"}]");
 812 :   }
 813 :   inline std::string get_unconstrained_sizedtypes() const {
 814 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(L) + "},\"block\":\"parameters\"},{\"name\":\"beta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(total_traps) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(total_traps) + "},\"block\":\"transformed_parameters\"}]");
 815 :   }
 816 :   // Begin method overload boilerplate
 817 :   template <typename RNG> inline void
 818 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 819 :               Eigen::Matrix<double,-1,1>& vars, const bool
 820 :               emit_transformed_parameters = true, const bool
 821 :               emit_generated_quantities = true, std::ostream*
 822 :               pstream = nullptr) const {
 823 :     const size_t num_params__ = (((((L + 1) + 1) + total_traps) + C) + C);
 824 :     const size_t num_transformed = emit_transformed_parameters * ((1 +
 825 :       total_traps));
 826 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 827 :     const size_t num_to_write = num_params__ + num_transformed +
 828 :       num_gen_quantities;
 829 :     std::vector<int> params_i;
 830 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 831 :              std::numeric_limits<double>::quiet_NaN());
 832 :     write_array_impl(base_rng, params_r, params_i, vars,
 833 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 834 :   }
 835 :   template <typename RNG> inline void
 836 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 837 :               params_i, std::vector<double>& vars, bool
 838 :               emit_transformed_parameters = true, bool
 839 :               emit_generated_quantities = true, std::ostream*
 840 :               pstream = nullptr) const {
 841 :     const size_t num_params__ = (((((L + 1) + 1) + total_traps) + C) + C);
 842 :     const size_t num_transformed = emit_transformed_parameters * ((1 +
 843 :       total_traps));
 844 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 845 :     const size_t num_to_write = num_params__ + num_transformed +
 846 :       num_gen_quantities;
 847 :     vars = std::vector<double>(num_to_write,
 848 :              std::numeric_limits<double>::quiet_NaN());
 849 :     write_array_impl(base_rng, params_r, params_i, vars,
 850 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 851 :   }
 852 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 853 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 854 :     Eigen::Matrix<int,-1,1> params_i;
 855 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 856 :   }
 857 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 858 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 859 :            std::ostream* pstream = nullptr) const {
 860 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 861 :   }
 862 :   inline void
 863 :   transform_inits(const stan::io::var_context& context,
 864 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 865 :                   pstream = nullptr) const final {
 866 :     std::vector<double> params_r_vec(params_r.size());
 867 :     std::vector<int> params_i;
 868 :     transform_inits(context, params_i, params_r_vec, pstream);
 869 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 870 :                  params_r_vec.size());
 871 :   }
 872 :   inline void
 873 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 874 :                   params_i, std::vector<double>& vars, std::ostream*
 875 :                   pstream__ = nullptr) const {
 876 :     vars.resize(num_params_r__);
 877 :     transform_inits_impl(context, vars, pstream__);
 878 :   }
 879 :   inline void
 880 :   unconstrain_array(const std::vector<double>& params_constrained,
 881 :                     std::vector<double>& params_unconstrained, std::ostream*
 882 :                     pstream = nullptr) const {
 883 :     const std::vector<int> params_i;
 884 :     params_unconstrained = std::vector<double>(num_params_r__,
 885 :                              std::numeric_limits<double>::quiet_NaN());
 886 :     unconstrain_array_impl(params_constrained, params_i,
 887 :       params_unconstrained, pstream);
 888 :   }
 889 :   inline void
 890 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 891 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
 892 :                     std::ostream* pstream = nullptr) const {
 893 :     const std::vector<int> params_i;
 894 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
 895 :                              std::numeric_limits<double>::quiet_NaN());
 896 :     unconstrain_array_impl(params_constrained, params_i,
 897 :       params_unconstrained, pstream);
 898 :   }
 899 : };
 900 : }
 901 : using stan_model = model1b629d627a5bda__namespace::model1b629d627a5bda_;
 902 : #ifndef USING_R
 903 : // Boilerplate
 904 : stan::model::model_base&
 905 : new_model(stan::io::var_context& data_context, unsigned int seed,
 906 :           std::ostream* msg_stream) {
 907 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
 908 :   return *m;
 909 : }
 910 : stan::math::profile_map& get_stan_profile_data() {
 911 :   return model1b629d627a5bda__namespace::profiles__;
 912 : }
 913 : #endif
 914 : #endif
 915 : 
 916 : RCPP_MODULE(stan_fit4model1b629d627a5bda__mod) {
 917 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
 918 :       "stan_fit4model1b629d627a5bda_")
 919 : 
 920 :       .constructor<SEXP, SEXP, SEXP>()
 921 : 
 922 :       .method(
 923 :           "call_sampler",
 924 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
 925 :       .method(
 926 :           "param_names",
 927 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
 928 :       .method("param_names_oi",
 929 :               &rstan::stan_fit<stan_model,
 930 :                                boost::random::ecuyer1988>::param_names_oi)
 931 :       .method("param_fnames_oi",
 932 :               &rstan::stan_fit<stan_model,
 933 :                                boost::random::ecuyer1988>::param_fnames_oi)
 934 :       .method(
 935 :           "param_dims",
 936 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
 937 :       .method("param_dims_oi",
 938 :               &rstan::stan_fit<stan_model,
 939 :                                boost::random::ecuyer1988>::param_dims_oi)
 940 :       .method("update_param_oi",
 941 :               &rstan::stan_fit<stan_model,
 942 :                                boost::random::ecuyer1988>::update_param_oi)
 943 :       .method("param_oi_tidx",
 944 :               &rstan::stan_fit<stan_model,
 945 :                                boost::random::ecuyer1988>::param_oi_tidx)
 946 :       .method("grad_log_prob",
 947 :               &rstan::stan_fit<stan_model,
 948 :                                boost::random::ecuyer1988>::grad_log_prob)
 949 :       .method("log_prob",
 950 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
 951 :       .method("unconstrain_pars",
 952 :               &rstan::stan_fit<stan_model,
 953 :                                boost::random::ecuyer1988>::unconstrain_pars)
 954 :       .method("constrain_pars",
 955 :               &rstan::stan_fit<stan_model,
 956 :                                boost::random::ecuyer1988>::constrain_pars)
 957 :       .method(
 958 :           "num_pars_unconstrained",
 959 :           &rstan::stan_fit<stan_model,
 960 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
 961 :       .method(
 962 :           "unconstrained_param_names",
 963 :           &rstan::stan_fit<
 964 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
 965 :       .method(
 966 :           "constrained_param_names",
 967 :           &rstan::stan_fit<stan_model,
 968 :                            boost::random::ecuyer1988>::constrained_param_names)
 969 :       .method("standalone_gqs",
 970 :               &rstan::stan_fit<stan_model,
 971 :                                boost::random::ecuyer1988>::standalone_gqs);
 972 : }
 973 : 
 974 : 
 975 : // declarations
 976 : extern "C" {
 977 : SEXP file1b629d79e0592( ) ;
 978 : }
 979 : 
 980 : // definition
 981 : SEXP file1b629d79e0592() {
 982 :  return Rcpp::wrap("anon_model");
 983 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file1b629d79e0592.so' OBJECTS='file1b629d79e0592.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file1b629d79e0592.cpp -o file1b629d79e0592.o
if test  "zfile1b629d79e0592.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file1b629d79e0592.so file1b629d79e0592.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file1b629d79e0592.so file1b629d79e0592.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.


COMPILING MODEL 'SAMPLINGanon_model FOR MODEL '' NOW.
anon_model' NOW (CHAIN 
1STARTING SAMPLER FOR MODEL ').
anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Gradient evaluated at the initial value is not finite.
Chain 1:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 1: Rejecting initial value:
Chain 1:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 1:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Gradient evaluated at the initial value is not finite.
Chain 2:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 3: 
Chain 3: Gradient evaluation took 0.029273 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 292.73 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 1: 
Chain 1: Gradient evaluation took 0.020387 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 203.87 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: 
Chain 2: Gradient evaluation took 0.020702 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 207.02 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: 
Chain 4: Gradient evaluation took 0.029935 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 299.35 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 3: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 2: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 1: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 4: Iteration:    1 / 4000 [  0%]  (Warmup)
