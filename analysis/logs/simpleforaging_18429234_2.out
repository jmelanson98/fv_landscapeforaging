
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model1be2ed6a46e000__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 72> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 20, column 2 to column 20)",
  25 :   " (in 'anon_model', line 21, column 2 to column 13)",
  26 :   " (in 'anon_model', line 22, column 2 to column 22)",
  27 :   " (in 'anon_model', line 23, column 2 to column 16)",
  28 :   " (in 'anon_model', line 26, column 2 to column 46)",
  29 :   " (in 'anon_model', line 27, column 2 to column 46)",
  30 :   " (in 'anon_model', line 31, column 2 to column 24)",
  31 :   " (in 'anon_model', line 32, column 2 to column 24)",
  32 :   " (in 'anon_model', line 39, column 2 to column 40)",
  33 :   " (in 'anon_model', line 34, column 4 to column 32)",
  34 :   " (in 'anon_model', line 35, column 4 to column 100)",
  35 :   " (in 'anon_model', line 36, column 4 to column 100)",
  36 :   " (in 'anon_model', line 33, column 17 to line 37, column 3)",
  37 :   " (in 'anon_model', line 33, column 2 to line 37, column 3)",
  38 :   " (in 'anon_model', line 43, column 2 to column 33)",
  39 :   " (in 'anon_model', line 44, column 2 to column 22)",
  40 :   " (in 'anon_model', line 45, column 2 to column 23)",
  41 :   " (in 'anon_model', line 46, column 2 to column 21)",
  42 :   " (in 'anon_model', line 53, column 4 to column 26)",
  43 :   " (in 'anon_model', line 54, column 4 to column 28)",
  44 :   " (in 'anon_model', line 57, column 13 to column 19)",
  45 :   " (in 'anon_model', line 57, column 4 to column 53)",
  46 :   " (in 'anon_model', line 58, column 11 to column 17)",
  47 :   " (in 'anon_model', line 58, column 4 to column 54)",
  48 :   " (in 'anon_model', line 59, column 11 to column 17)",
  49 :   " (in 'anon_model', line 59, column 4 to column 74)",
  50 :   " (in 'anon_model', line 60, column 10 to column 16)",
  51 :   " (in 'anon_model', line 60, column 4 to column 50)",
  52 :   " (in 'anon_model', line 61, column 4 to column 29)",
  53 :   " (in 'anon_model', line 62, column 11 to column 17)",
  54 :   " (in 'anon_model', line 62, column 4 to column 62)",
  55 :   " (in 'anon_model', line 65, column 11 to column 17)",
  56 :   " (in 'anon_model', line 65, column 4 to line 66, column 57)",
  57 :   " (in 'anon_model', line 67, column 11 to column 17)",
  58 :   " (in 'anon_model', line 67, column 4 to column 96)",
  59 :   " (in 'anon_model', line 70, column 11 to column 17)",
  60 :   " (in 'anon_model', line 70, column 4 to column 52)",
  61 :   " (in 'anon_model', line 71, column 4 to column 36)",
  62 :   " (in 'anon_model', line 51, column 17 to line 72, column 5)",
  63 :   " (in 'anon_model', line 51, column 2 to line 72, column 5)",
  64 :   " (in 'anon_model', line 48, column 2 to line 73, column 3)",
  65 :   " (in 'anon_model', line 4, column 2 to column 17)",
  66 :   " (in 'anon_model', line 5, column 2 to column 17)",
  67 :   " (in 'anon_model', line 6, column 2 to column 17)",
  68 :   " (in 'anon_model', line 7, column 2 to column 17)",
  69 :   " (in 'anon_model', line 8, column 13 to column 14)",
  70 :   " (in 'anon_model', line 8, column 2 to column 16)",
  71 :   " (in 'anon_model', line 9, column 14 to column 15)",
  72 :   " (in 'anon_model', line 9, column 2 to column 17)",
  73 :   " (in 'anon_model', line 10, column 15 to column 16)",
  74 :   " (in 'anon_model', line 10, column 2 to column 18)",
  75 :   " (in 'anon_model', line 11, column 9 to column 10)",
  76 :   " (in 'anon_model', line 11, column 2 to column 24)",
  77 :   " (in 'anon_model', line 12, column 9 to column 10)",
  78 :   " (in 'anon_model', line 12, column 2 to column 26)",
  79 :   " (in 'anon_model', line 13, column 16 to column 17)",
  80 :   " (in 'anon_model', line 13, column 2 to column 19)",
  81 :   " (in 'anon_model', line 14, column 14 to column 15)",
  82 :   " (in 'anon_model', line 14, column 2 to column 17)",
  83 :   " (in 'anon_model', line 15, column 12 to column 13)",
  84 :   " (in 'anon_model', line 15, column 2 to column 15)",
  85 :   " (in 'anon_model', line 16, column 9 to column 10)",
  86 :   " (in 'anon_model', line 16, column 2 to column 15)",
  87 :   " (in 'anon_model', line 17, column 9 to column 10)",
  88 :   " (in 'anon_model', line 17, column 2 to column 21)",
  89 :   " (in 'anon_model', line 23, column 9 to column 10)",
  90 :   " (in 'anon_model', line 26, column 8 to column 9)",
  91 :   " (in 'anon_model', line 27, column 8 to column 9)",
  92 :   " (in 'anon_model', line 31, column 8 to column 9)",
  93 :   " (in 'anon_model', line 32, column 8 to column 9)",
  94 :   " (in 'anon_model', line 39, column 9 to column 10)"};
  95 : class model1be2ed6a46e000_ final : public model_base_crtp<model1be2ed6a46e000_> {
  96 : private:
  97 :   int C;
  98 :   int K;
  99 :   int O;
 100 :   int L;
 101 :   std::vector<int> starts;
 102 :   std::vector<int> lengths;
 103 :   std::vector<int> col_site;
 104 :   Eigen::Matrix<double,-1,-1> trap_pos_data__;
 105 :   Eigen::Matrix<double,-1,1> sample_effort_data__;
 106 :   std::vector<int> colony_id;
 107 :   std::vector<int> trap_id;
 108 :   std::vector<int> y_obs;
 109 :   Eigen::Matrix<double,-1,1> yn_data__;
 110 :   Eigen::Matrix<double,-1,-1> bounds_data__;
 111 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap_pos{nullptr, 0, 0};
 112 :   Eigen::Map<Eigen::Matrix<double,-1,1>> sample_effort{nullptr, 0};
 113 :   Eigen::Map<Eigen::Matrix<double,-1,1>> yn{nullptr, 0};
 114 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> bounds{nullptr, 0, 0};
 115 : public:
 116 :   ~model1be2ed6a46e000_() {}
 117 :   model1be2ed6a46e000_(stan::io::var_context& context__, unsigned int
 118 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
 119 :       : model_base_crtp(0) {
 120 :     int current_statement__ = 0;
 121 :     using local_scalar_t__ = double;
 122 :     boost::ecuyer1988 base_rng__ =
 123 :       stan::services::util::create_rng(random_seed__, 0);
 124 :     // suppress unused var warning
 125 :     (void) base_rng__;
 126 :     static constexpr const char* function__ =
 127 :       "model1be2ed6a46e000__namespace::model1be2ed6a46e000_";
 128 :     // suppress unused var warning
 129 :     (void) function__;
 130 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 131 :     // suppress unused var warning
 132 :     (void) DUMMY_VAR__;
 133 :     try {
 134 :       int pos__ = std::numeric_limits<int>::min();
 135 :       pos__ = 1;
 136 :       current_statement__ = 42;
 137 :       context__.validate_dims("data initialization", "C", "int",
 138 :         std::vector<size_t>{});
 139 :       C = std::numeric_limits<int>::min();
 140 :       current_statement__ = 42;
 141 :       C = context__.vals_i("C")[(1 - 1)];
 142 :       current_statement__ = 42;
 143 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 144 :       current_statement__ = 43;
 145 :       context__.validate_dims("data initialization", "K", "int",
 146 :         std::vector<size_t>{});
 147 :       K = std::numeric_limits<int>::min();
 148 :       current_statement__ = 43;
 149 :       K = context__.vals_i("K")[(1 - 1)];
 150 :       current_statement__ = 43;
 151 :       stan::math::check_greater_or_equal(function__, "K", K, 1);
 152 :       current_statement__ = 44;
 153 :       context__.validate_dims("data initialization", "O", "int",
 154 :         std::vector<size_t>{});
 155 :       O = std::numeric_limits<int>::min();
 156 :       current_statement__ = 44;
 157 :       O = context__.vals_i("O")[(1 - 1)];
 158 :       current_statement__ = 44;
 159 :       stan::math::check_greater_or_equal(function__, "O", O, 1);
 160 :       current_statement__ = 45;
 161 :       context__.validate_dims("data initialization", "L", "int",
 162 :         std::vector<size_t>{});
 163 :       L = std::numeric_limits<int>::min();
 164 :       current_statement__ = 45;
 165 :       L = context__.vals_i("L")[(1 - 1)];
 166 :       current_statement__ = 45;
 167 :       stan::math::check_greater_or_equal(function__, "L", L, 1);
 168 :       current_statement__ = 46;
 169 :       stan::math::validate_non_negative_index("starts", "C", C);
 170 :       current_statement__ = 47;
 171 :       context__.validate_dims("data initialization", "starts", "int",
 172 :         std::vector<size_t>{static_cast<size_t>(C)});
 173 :       starts = std::vector<int>(C, std::numeric_limits<int>::min());
 174 :       current_statement__ = 47;
 175 :       starts = context__.vals_i("starts");
 176 :       current_statement__ = 48;
 177 :       stan::math::validate_non_negative_index("lengths", "C", C);
 178 :       current_statement__ = 49;
 179 :       context__.validate_dims("data initialization", "lengths", "int",
 180 :         std::vector<size_t>{static_cast<size_t>(C)});
 181 :       lengths = std::vector<int>(C, std::numeric_limits<int>::min());
 182 :       current_statement__ = 49;
 183 :       lengths = context__.vals_i("lengths");
 184 :       current_statement__ = 50;
 185 :       stan::math::validate_non_negative_index("col_site", "C", C);
 186 :       current_statement__ = 51;
 187 :       context__.validate_dims("data initialization", "col_site", "int",
 188 :         std::vector<size_t>{static_cast<size_t>(C)});
 189 :       col_site = std::vector<int>(C, std::numeric_limits<int>::min());
 190 :       current_statement__ = 51;
 191 :       col_site = context__.vals_i("col_site");
 192 :       current_statement__ = 52;
 193 :       stan::math::validate_non_negative_index("trap_pos", "O", O);
 194 :       current_statement__ = 53;
 195 :       context__.validate_dims("data initialization", "trap_pos", "double",
 196 :         std::vector<size_t>{static_cast<size_t>(O), static_cast<size_t>(2)});
 197 :       trap_pos_data__ = Eigen::Matrix<double,-1,-1>::Constant(O, 2,
 198 :                           std::numeric_limits<double>::quiet_NaN());
 199 :       new (&trap_pos)
 200 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_pos_data__.data(), O, 2);
 201 :       {
 202 :         std::vector<local_scalar_t__> trap_pos_flat__;
 203 :         current_statement__ = 53;
 204 :         trap_pos_flat__ = context__.vals_r("trap_pos");
 205 :         current_statement__ = 53;
 206 :         pos__ = 1;
 207 :         current_statement__ = 53;
 208 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 209 :           current_statement__ = 53;
 210 :           for (int sym2__ = 1; sym2__ <= O; ++sym2__) {
 211 :             current_statement__ = 53;
 212 :             stan::model::assign(trap_pos, trap_pos_flat__[(pos__ - 1)],
 213 :               "assigning variable trap_pos", stan::model::index_uni(sym2__),
 214 :               stan::model::index_uni(sym1__));
 215 :             current_statement__ = 53;
 216 :             pos__ = (pos__ + 1);
 217 :           }
 218 :         }
 219 :       }
 220 :       current_statement__ = 54;
 221 :       stan::math::validate_non_negative_index("sample_effort", "O", O);
 222 :       current_statement__ = 55;
 223 :       context__.validate_dims("data initialization", "sample_effort",
 224 :         "double", std::vector<size_t>{static_cast<size_t>(O)});
 225 :       sample_effort_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 226 :                                std::numeric_limits<double>::quiet_NaN());
 227 :       new (&sample_effort)
 228 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(sample_effort_data__.data(),
 229 :         O);
 230 :       {
 231 :         std::vector<local_scalar_t__> sample_effort_flat__;
 232 :         current_statement__ = 55;
 233 :         sample_effort_flat__ = context__.vals_r("sample_effort");
 234 :         current_statement__ = 55;
 235 :         pos__ = 1;
 236 :         current_statement__ = 55;
 237 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 238 :           current_statement__ = 55;
 239 :           stan::model::assign(sample_effort, sample_effort_flat__[(pos__ -
 240 :             1)], "assigning variable sample_effort",
 241 :             stan::model::index_uni(sym1__));
 242 :           current_statement__ = 55;
 243 :           pos__ = (pos__ + 1);
 244 :         }
 245 :       }
 246 :       current_statement__ = 56;
 247 :       stan::math::validate_non_negative_index("colony_id", "O", O);
 248 :       current_statement__ = 57;
 249 :       context__.validate_dims("data initialization", "colony_id", "int",
 250 :         std::vector<size_t>{static_cast<size_t>(O)});
 251 :       colony_id = std::vector<int>(O, std::numeric_limits<int>::min());
 252 :       current_statement__ = 57;
 253 :       colony_id = context__.vals_i("colony_id");
 254 :       current_statement__ = 58;
 255 :       stan::math::validate_non_negative_index("trap_id", "O", O);
 256 :       current_statement__ = 59;
 257 :       context__.validate_dims("data initialization", "trap_id", "int",
 258 :         std::vector<size_t>{static_cast<size_t>(O)});
 259 :       trap_id = std::vector<int>(O, std::numeric_limits<int>::min());
 260 :       current_statement__ = 59;
 261 :       trap_id = context__.vals_i("trap_id");
 262 :       current_statement__ = 60;
 263 :       stan::math::validate_non_negative_index("y_obs", "O", O);
 264 :       current_statement__ = 61;
 265 :       context__.validate_dims("data initialization", "y_obs", "int",
 266 :         std::vector<size_t>{static_cast<size_t>(O)});
 267 :       y_obs = std::vector<int>(O, std::numeric_limits<int>::min());
 268 :       current_statement__ = 61;
 269 :       y_obs = context__.vals_i("y_obs");
 270 :       current_statement__ = 62;
 271 :       stan::math::validate_non_negative_index("yn", "O", O);
 272 :       current_statement__ = 63;
 273 :       context__.validate_dims("data initialization", "yn", "double",
 274 :         std::vector<size_t>{static_cast<size_t>(O)});
 275 :       yn_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 276 :                     std::numeric_limits<double>::quiet_NaN());
 277 :       new (&yn) Eigen::Map<Eigen::Matrix<double,-1,1>>(yn_data__.data(), O);
 278 :       {
 279 :         std::vector<local_scalar_t__> yn_flat__;
 280 :         current_statement__ = 63;
 281 :         yn_flat__ = context__.vals_r("yn");
 282 :         current_statement__ = 63;
 283 :         pos__ = 1;
 284 :         current_statement__ = 63;
 285 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 286 :           current_statement__ = 63;
 287 :           stan::model::assign(yn, yn_flat__[(pos__ - 1)],
 288 :             "assigning variable yn", stan::model::index_uni(sym1__));
 289 :           current_statement__ = 63;
 290 :           pos__ = (pos__ + 1);
 291 :         }
 292 :       }
 293 :       current_statement__ = 64;
 294 :       stan::math::validate_non_negative_index("bounds", "L", L);
 295 :       current_statement__ = 65;
 296 :       context__.validate_dims("data initialization", "bounds", "double",
 297 :         std::vector<size_t>{static_cast<size_t>(L), static_cast<size_t>(4)});
 298 :       bounds_data__ = Eigen::Matrix<double,-1,-1>::Constant(L, 4,
 299 :                         std::numeric_limits<double>::quiet_NaN());
 300 :       new (&bounds)
 301 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(bounds_data__.data(), L, 4);
 302 :       {
 303 :         std::vector<local_scalar_t__> bounds_flat__;
 304 :         current_statement__ = 65;
 305 :         bounds_flat__ = context__.vals_r("bounds");
 306 :         current_statement__ = 65;
 307 :         pos__ = 1;
 308 :         current_statement__ = 65;
 309 :         for (int sym1__ = 1; sym1__ <= 4; ++sym1__) {
 310 :           current_statement__ = 65;
 311 :           for (int sym2__ = 1; sym2__ <= L; ++sym2__) {
 312 :             current_statement__ = 65;
 313 :             stan::model::assign(bounds, bounds_flat__[(pos__ - 1)],
 314 :               "assigning variable bounds", stan::model::index_uni(sym2__),
 315 :               stan::model::index_uni(sym1__));
 316 :             current_statement__ = 65;
 317 :             pos__ = (pos__ + 1);
 318 :           }
 319 :         }
 320 :       }
 321 :       current_statement__ = 66;
 322 :       stan::math::validate_non_negative_index("eps", "K", K);
 323 :       current_statement__ = 67;
 324 :       stan::math::validate_non_negative_index("delta_x_raw", "C", C);
 325 :       current_statement__ = 68;
 326 :       stan::math::validate_non_negative_index("delta_y_raw", "C", C);
 327 :       current_statement__ = 69;
 328 :       stan::math::validate_non_negative_index("delta_x", "C", C);
 329 :       current_statement__ = 70;
 330 :       stan::math::validate_non_negative_index("delta_y", "C", C);
 331 :       current_statement__ = 71;
 332 :       stan::math::validate_non_negative_index("eps_scale", "K", K);
 333 :     } catch (const std::exception& e) {
 334 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 335 :     }
 336 :     num_params_r__ = 1 + 1 + 1 + K + C + C;
 337 :   }
 338 :   inline std::string model_name() const final {
 339 :     return "model1be2ed6a46e000_";
 340 :   }
 341 :   inline std::vector<std::string> model_compile_info() const noexcept {
 342 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 343 :              "stancflags = --"};
 344 :   }
 345 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 346 :             stan::require_vector_like_t<VecR>* = nullptr,
 347 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 348 :   inline stan::scalar_type_t<VecR>
 349 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 350 :                 pstream__ = nullptr) const {
 351 :     using T__ = stan::scalar_type_t<VecR>;
 352 :     using local_scalar_t__ = T__;
 353 :     T__ lp__(0.0);
 354 :     stan::math::accumulator<T__> lp_accum__;
 355 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 356 :     int current_statement__ = 0;
 357 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 358 :     // suppress unused var warning
 359 :     (void) DUMMY_VAR__;
 360 :     static constexpr const char* function__ =
 361 :       "model1be2ed6a46e000__namespace::log_prob";
 362 :     // suppress unused var warning
 363 :     (void) function__;
 364 :     try {
 365 :       local_scalar_t__ rho = DUMMY_VAR__;
 366 :       current_statement__ = 1;
 367 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 368 :               lp__);
 369 :       local_scalar_t__ alpha = DUMMY_VAR__;
 370 :       current_statement__ = 2;
 371 :       alpha = in__.template read<local_scalar_t__>();
 372 :       local_scalar_t__ sigma = DUMMY_VAR__;
 373 :       current_statement__ = 3;
 374 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 375 :                 jacobian__>(0, lp__);
 376 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 377 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 378 :       current_statement__ = 4;
 379 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 380 :       std::vector<local_scalar_t__> delta_x_raw =
 381 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 382 :       current_statement__ = 5;
 383 :       delta_x_raw = in__.template read_constrain_lub<
 384 :                       std::vector<local_scalar_t__>, jacobian__>(0, 1, lp__,
 385 :                       C);
 386 :       std::vector<local_scalar_t__> delta_y_raw =
 387 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 388 :       current_statement__ = 6;
 389 :       delta_y_raw = in__.template read_constrain_lub<
 390 :                       std::vector<local_scalar_t__>, jacobian__>(0, 1, lp__,
 391 :                       C);
 392 :       std::vector<local_scalar_t__> delta_x =
 393 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 394 :       std::vector<local_scalar_t__> delta_y =
 395 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 396 :       current_statement__ = 14;
 397 :       for (int i = 1; i <= C; ++i) {
 398 :         int landscape = std::numeric_limits<int>::min();
 399 :         current_statement__ = 10;
 400 :         landscape = stan::model::rvalue(col_site, "col_site",
 401 :                       stan::model::index_uni(i));
 402 :         current_statement__ = 11;
 403 :         stan::model::assign(delta_x,
 404 :           (stan::model::rvalue(bounds, "bounds",
 405 :              stan::model::index_uni(landscape), stan::model::index_uni(1)) +
 406 :           ((stan::model::rvalue(bounds, "bounds",
 407 :               stan::model::index_uni(landscape), stan::model::index_uni(2)) -
 408 :           stan::model::rvalue(bounds, "bounds",
 409 :             stan::model::index_uni(landscape), stan::model::index_uni(1))) *
 410 :           stan::model::rvalue(delta_x_raw, "delta_x_raw",
 411 :             stan::model::index_uni(i)))), "assigning variable delta_x",
 412 :           stan::model::index_uni(i));
 413 :         current_statement__ = 12;
 414 :         stan::model::assign(delta_y,
 415 :           (stan::model::rvalue(bounds, "bounds",
 416 :              stan::model::index_uni(landscape), stan::model::index_uni(3)) +
 417 :           ((stan::model::rvalue(bounds, "bounds",
 418 :               stan::model::index_uni(landscape), stan::model::index_uni(4)) -
 419 :           stan::model::rvalue(bounds, "bounds",
 420 :             stan::model::index_uni(landscape), stan::model::index_uni(3))) *
 421 :           stan::model::rvalue(delta_y_raw, "delta_y_raw",
 422 :             stan::model::index_uni(i)))), "assigning variable delta_y",
 423 :           stan::model::index_uni(i));
 424 :       }
 425 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 426 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 427 :       current_statement__ = 9;
 428 :       stan::model::assign(eps_scale,
 429 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 430 :         "assigning variable eps_scale");
 431 :       {
 432 :         current_statement__ = 15;
 433 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho,
 434 :                          stan::math::log(0.5), 0.5));
 435 :         current_statement__ = 16;
 436 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 0, 1));
 437 :         current_statement__ = 17;
 438 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 1));
 439 :         current_statement__ = 18;
 440 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 441 :         {
 442 :           current_statement__ = 40;
 443 :           for (int c = 1; c <= C; ++c) {
 444 :             int start = std::numeric_limits<int>::min();
 445 :             current_statement__ = 19;
 446 :             start = stan::model::rvalue(starts, "starts",
 447 :                       stan::model::index_uni(c));
 448 :             int length = std::numeric_limits<int>::min();
 449 :             current_statement__ = 20;
 450 :             length = stan::model::rvalue(lengths, "lengths",
 451 :                        stan::model::index_uni(c));
 452 :             current_statement__ = 21;
 453 :             stan::math::validate_non_negative_index("y_ik", "length", length);
 454 :             std::vector<int> y_ik =
 455 :               std::vector<int>(length, std::numeric_limits<int>::min());
 456 :             current_statement__ = 22;
 457 :             stan::model::assign(y_ik,
 458 :               stan::model::rvalue(y_obs, "y_obs",
 459 :                 stan::model::index_min_max(start, ((start + length) - 1))),
 460 :               "assigning variable y_ik");
 461 :             current_statement__ = 23;
 462 :             stan::math::validate_non_negative_index("yn_ik", "length", length);
 463 :             Eigen::Matrix<local_scalar_t__,-1,1> yn_ik =
 464 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 465 :                 DUMMY_VAR__);
 466 :             current_statement__ = 24;
 467 :             stan::model::assign(yn_ik,
 468 :               stan::model::rvalue(yn, "yn",
 469 :                 stan::model::index_min_max(start, ((start + length) - 1))),
 470 :               "assigning variable yn_ik");
 471 :             current_statement__ = 25;
 472 :             stan::math::validate_non_negative_index("sample_effort_ik",
 473 :               "length", length);
 474 :             Eigen::Matrix<local_scalar_t__,-1,1> sample_effort_ik =
 475 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 476 :                 DUMMY_VAR__);
 477 :             current_statement__ = 26;
 478 :             stan::model::assign(sample_effort_ik,
 479 :               stan::model::rvalue(sample_effort, "sample_effort",
 480 :                 stan::model::index_min_max(start, ((start + length) - 1))),
 481 :               "assigning variable sample_effort_ik");
 482 :             current_statement__ = 27;
 483 :             stan::math::validate_non_negative_index("k", "length", length);
 484 :             std::vector<int> k =
 485 :               std::vector<int>(length, std::numeric_limits<int>::min());
 486 :             current_statement__ = 28;
 487 :             stan::model::assign(k,
 488 :               stan::model::rvalue(trap_id, "trap_id",
 489 :                 stan::model::index_min_max(start, ((start + length) - 1))),
 490 :               "assigning variable k");
 491 :             int i = std::numeric_limits<int>::min();
 492 :             current_statement__ = 29;
 493 :             i = stan::model::rvalue(colony_id, "colony_id",
 494 :                   stan::model::index_uni(start));
 495 :             current_statement__ = 30;
 496 :             stan::math::validate_non_negative_index("trap_i", "length",
 497 :               length);
 498 :             Eigen::Matrix<local_scalar_t__,-1,-1> trap_i =
 499 :               Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(length, 2,
 500 :                 DUMMY_VAR__);
 501 :             current_statement__ = 31;
 502 :             stan::model::assign(trap_i,
 503 :               stan::model::rvalue(trap_pos, "trap_pos",
 504 :                 stan::model::index_min_max(start, ((start + length) - 1)),
 505 :                 stan::model::index_omni()), "assigning variable trap_i");
 506 :             current_statement__ = 32;
 507 :             stan::math::validate_non_negative_index("dis", "length", length);
 508 :             Eigen::Matrix<local_scalar_t__,-1,1> dis =
 509 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 510 :                 DUMMY_VAR__);
 511 :             current_statement__ = 33;
 512 :             stan::model::assign(dis,
 513 :               stan::math::sqrt(
 514 :                 stan::math::add(
 515 :                   stan::math::square(
 516 :                     stan::math::subtract(
 517 :                       stan::model::rvalue(delta_x, "delta_x",
 518 :                         stan::model::index_uni(i)),
 519 :                       stan::model::rvalue(trap_i, "trap_i",
 520 :                         stan::model::index_omni(), stan::model::index_uni(1)))),
 521 :                   stan::math::square(
 522 :                     stan::math::subtract(
 523 :                       stan::model::rvalue(delta_y, "delta_y",
 524 :                         stan::model::index_uni(i)),
 525 :                       stan::model::rvalue(trap_i, "trap_i",
 526 :                         stan::model::index_omni(), stan::model::index_uni(2)))))),
 527 :               "assigning variable dis");
 528 :             current_statement__ = 34;
 529 :             stan::math::validate_non_negative_index("lambda_ik", "length",
 530 :               length);
 531 :             Eigen::Matrix<local_scalar_t__,-1,1> lambda_ik =
 532 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 533 :                 DUMMY_VAR__);
 534 :             current_statement__ = 35;
 535 :             stan::model::assign(lambda_ik,
 536 :               stan::math::add(
 537 :                 stan::math::add(
 538 :                   stan::math::subtract(alpha,
 539 :                     stan::math::multiply(0.5,
 540 :                       stan::math::pow(stan::math::divide(dis, rho), 2))),
 541 :                   stan::model::rvalue(eps_scale, "eps_scale",
 542 :                     stan::model::index_multi(k))),
 543 :                 stan::math::log(sample_effort_ik)),
 544 :               "assigning variable lambda_ik");
 545 :             current_statement__ = 36;
 546 :             stan::math::validate_non_negative_index("multi_probs", "length",
 547 :               length);
 548 :             Eigen::Matrix<local_scalar_t__,-1,1> multi_probs =
 549 :               Eigen::Matrix<local_scalar_t__,-1,1>::Constant(length,
 550 :                 DUMMY_VAR__);
 551 :             current_statement__ = 37;
 552 :             stan::model::assign(multi_probs, stan::math::softmax(lambda_ik),
 553 :               "assigning variable multi_probs");
 554 :             current_statement__ = 38;
 555 :             lp_accum__.add(stan::math::multinomial_lpmf<propto__>(y_ik,
 556 :                              multi_probs));
 557 :           }
 558 :         }
 559 :       }
 560 :     } catch (const std::exception& e) {
 561 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 562 :     }
 563 :     lp_accum__.add(lp__);
 564 :     return lp_accum__.sum();
 565 :   }
 566 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 567 :             stan::require_vector_like_vt<std::is_floating_point,
 568 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 569 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 570 :             VecVar>* = nullptr>
 571 :   inline void
 572 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 573 :                    VecVar& vars__, const bool
 574 :                    emit_transformed_parameters__ = true, const bool
 575 :                    emit_generated_quantities__ = true, std::ostream*
 576 :                    pstream__ = nullptr) const {
 577 :     using local_scalar_t__ = double;
 578 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 579 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 580 :     static constexpr bool propto__ = true;
 581 :     // suppress unused var warning
 582 :     (void) propto__;
 583 :     double lp__ = 0.0;
 584 :     // suppress unused var warning
 585 :     (void) lp__;
 586 :     int current_statement__ = 0;
 587 :     stan::math::accumulator<double> lp_accum__;
 588 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 589 :     // suppress unused var warning
 590 :     (void) DUMMY_VAR__;
 591 :     constexpr bool jacobian__ = false;
 592 :     static constexpr const char* function__ =
 593 :       "model1be2ed6a46e000__namespace::write_array";
 594 :     // suppress unused var warning
 595 :     (void) function__;
 596 :     try {
 597 :       double rho = std::numeric_limits<double>::quiet_NaN();
 598 :       current_statement__ = 1;
 599 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 600 :               lp__);
 601 :       double alpha = std::numeric_limits<double>::quiet_NaN();
 602 :       current_statement__ = 2;
 603 :       alpha = in__.template read<local_scalar_t__>();
 604 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 605 :       current_statement__ = 3;
 606 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 607 :                 jacobian__>(0, lp__);
 608 :       Eigen::Matrix<double,-1,1> eps =
 609 :         Eigen::Matrix<double,-1,1>::Constant(K,
 610 :           std::numeric_limits<double>::quiet_NaN());
 611 :       current_statement__ = 4;
 612 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 613 :       std::vector<double> delta_x_raw =
 614 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 615 :       current_statement__ = 5;
 616 :       delta_x_raw = in__.template read_constrain_lub<
 617 :                       std::vector<local_scalar_t__>, jacobian__>(0, 1, lp__,
 618 :                       C);
 619 :       std::vector<double> delta_y_raw =
 620 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 621 :       current_statement__ = 6;
 622 :       delta_y_raw = in__.template read_constrain_lub<
 623 :                       std::vector<local_scalar_t__>, jacobian__>(0, 1, lp__,
 624 :                       C);
 625 :       std::vector<double> delta_x =
 626 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 627 :       std::vector<double> delta_y =
 628 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 629 :       Eigen::Matrix<double,-1,1> eps_scale =
 630 :         Eigen::Matrix<double,-1,1>::Constant(K,
 631 :           std::numeric_limits<double>::quiet_NaN());
 632 :       out__.write(rho);
 633 :       out__.write(alpha);
 634 :       out__.write(sigma);
 635 :       out__.write(eps);
 636 :       out__.write(delta_x_raw);
 637 :       out__.write(delta_y_raw);
 638 :       if (stan::math::logical_negation(
 639 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 640 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 641 :         return ;
 642 :       }
 643 :       current_statement__ = 14;
 644 :       for (int i = 1; i <= C; ++i) {
 645 :         int landscape = std::numeric_limits<int>::min();
 646 :         current_statement__ = 10;
 647 :         landscape = stan::model::rvalue(col_site, "col_site",
 648 :                       stan::model::index_uni(i));
 649 :         current_statement__ = 11;
 650 :         stan::model::assign(delta_x,
 651 :           (stan::model::rvalue(bounds, "bounds",
 652 :              stan::model::index_uni(landscape), stan::model::index_uni(1)) +
 653 :           ((stan::model::rvalue(bounds, "bounds",
 654 :               stan::model::index_uni(landscape), stan::model::index_uni(2)) -
 655 :           stan::model::rvalue(bounds, "bounds",
 656 :             stan::model::index_uni(landscape), stan::model::index_uni(1))) *
 657 :           stan::model::rvalue(delta_x_raw, "delta_x_raw",
 658 :             stan::model::index_uni(i)))), "assigning variable delta_x",
 659 :           stan::model::index_uni(i));
 660 :         current_statement__ = 12;
 661 :         stan::model::assign(delta_y,
 662 :           (stan::model::rvalue(bounds, "bounds",
 663 :              stan::model::index_uni(landscape), stan::model::index_uni(3)) +
 664 :           ((stan::model::rvalue(bounds, "bounds",
 665 :               stan::model::index_uni(landscape), stan::model::index_uni(4)) -
 666 :           stan::model::rvalue(bounds, "bounds",
 667 :             stan::model::index_uni(landscape), stan::model::index_uni(3))) *
 668 :           stan::model::rvalue(delta_y_raw, "delta_y_raw",
 669 :             stan::model::index_uni(i)))), "assigning variable delta_y",
 670 :           stan::model::index_uni(i));
 671 :       }
 672 :       current_statement__ = 9;
 673 :       stan::model::assign(eps_scale,
 674 :         stan::math::multiply(eps, stan::math::sqrt(sigma)),
 675 :         "assigning variable eps_scale");
 676 :       if (emit_transformed_parameters__) {
 677 :         out__.write(delta_x);
 678 :         out__.write(delta_y);
 679 :         out__.write(eps_scale);
 680 :       }
 681 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 682 :         return ;
 683 :       }
 684 :     } catch (const std::exception& e) {
 685 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 686 :     }
 687 :   }
 688 :   template <typename VecVar, typename VecI,
 689 :             stan::require_vector_t<VecVar>* = nullptr,
 690 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 691 :   inline void
 692 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 693 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 694 :     using local_scalar_t__ = double;
 695 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 696 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 697 :     int current_statement__ = 0;
 698 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 699 :     // suppress unused var warning
 700 :     (void) DUMMY_VAR__;
 701 :     try {
 702 :       int pos__ = std::numeric_limits<int>::min();
 703 :       pos__ = 1;
 704 :       local_scalar_t__ rho = DUMMY_VAR__;
 705 :       current_statement__ = 1;
 706 :       rho = in__.read<local_scalar_t__>();
 707 :       out__.write_free_lb(0, rho);
 708 :       local_scalar_t__ alpha = DUMMY_VAR__;
 709 :       current_statement__ = 2;
 710 :       alpha = in__.read<local_scalar_t__>();
 711 :       out__.write(alpha);
 712 :       local_scalar_t__ sigma = DUMMY_VAR__;
 713 :       current_statement__ = 3;
 714 :       sigma = in__.read<local_scalar_t__>();
 715 :       out__.write_free_lb(0, sigma);
 716 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 717 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 718 :       current_statement__ = 4;
 719 :       stan::model::assign(eps,
 720 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 721 :         "assigning variable eps");
 722 :       out__.write(eps);
 723 :       std::vector<local_scalar_t__> delta_x_raw =
 724 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 725 :       current_statement__ = 5;
 726 :       stan::model::assign(delta_x_raw,
 727 :         in__.read<std::vector<local_scalar_t__>>(C),
 728 :         "assigning variable delta_x_raw");
 729 :       out__.write_free_lub(0, 1, delta_x_raw);
 730 :       std::vector<local_scalar_t__> delta_y_raw =
 731 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 732 :       current_statement__ = 6;
 733 :       stan::model::assign(delta_y_raw,
 734 :         in__.read<std::vector<local_scalar_t__>>(C),
 735 :         "assigning variable delta_y_raw");
 736 :       out__.write_free_lub(0, 1, delta_y_raw);
 737 :     } catch (const std::exception& e) {
 738 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 739 :     }
 740 :   }
 741 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 742 :   inline void
 743 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 744 :                        vars__, std::ostream* pstream__ = nullptr) const {
 745 :     using local_scalar_t__ = double;
 746 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 747 :     int current_statement__ = 0;
 748 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 749 :     // suppress unused var warning
 750 :     (void) DUMMY_VAR__;
 751 :     try {
 752 :       current_statement__ = 1;
 753 :       context__.validate_dims("parameter initialization", "rho", "double",
 754 :         std::vector<size_t>{});
 755 :       current_statement__ = 2;
 756 :       context__.validate_dims("parameter initialization", "alpha", "double",
 757 :         std::vector<size_t>{});
 758 :       current_statement__ = 3;
 759 :       context__.validate_dims("parameter initialization", "sigma", "double",
 760 :         std::vector<size_t>{});
 761 :       current_statement__ = 4;
 762 :       context__.validate_dims("parameter initialization", "eps", "double",
 763 :         std::vector<size_t>{static_cast<size_t>(K)});
 764 :       current_statement__ = 5;
 765 :       context__.validate_dims("parameter initialization", "delta_x_raw",
 766 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 767 :       current_statement__ = 6;
 768 :       context__.validate_dims("parameter initialization", "delta_y_raw",
 769 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 770 :       int pos__ = std::numeric_limits<int>::min();
 771 :       pos__ = 1;
 772 :       local_scalar_t__ rho = DUMMY_VAR__;
 773 :       current_statement__ = 1;
 774 :       rho = context__.vals_r("rho")[(1 - 1)];
 775 :       out__.write_free_lb(0, rho);
 776 :       local_scalar_t__ alpha = DUMMY_VAR__;
 777 :       current_statement__ = 2;
 778 :       alpha = context__.vals_r("alpha")[(1 - 1)];
 779 :       out__.write(alpha);
 780 :       local_scalar_t__ sigma = DUMMY_VAR__;
 781 :       current_statement__ = 3;
 782 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 783 :       out__.write_free_lb(0, sigma);
 784 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 785 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 786 :       {
 787 :         std::vector<local_scalar_t__> eps_flat__;
 788 :         current_statement__ = 4;
 789 :         eps_flat__ = context__.vals_r("eps");
 790 :         current_statement__ = 4;
 791 :         pos__ = 1;
 792 :         current_statement__ = 4;
 793 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 794 :           current_statement__ = 4;
 795 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 796 :             "assigning variable eps", stan::model::index_uni(sym1__));
 797 :           current_statement__ = 4;
 798 :           pos__ = (pos__ + 1);
 799 :         }
 800 :       }
 801 :       out__.write(eps);
 802 :       std::vector<local_scalar_t__> delta_x_raw =
 803 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 804 :       current_statement__ = 5;
 805 :       delta_x_raw = context__.vals_r("delta_x_raw");
 806 :       out__.write_free_lub(0, 1, delta_x_raw);
 807 :       std::vector<local_scalar_t__> delta_y_raw =
 808 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 809 :       current_statement__ = 6;
 810 :       delta_y_raw = context__.vals_r("delta_y_raw");
 811 :       out__.write_free_lub(0, 1, delta_y_raw);
 812 :     } catch (const std::exception& e) {
 813 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 814 :     }
 815 :   }
 816 :   inline void
 817 :   get_param_names(std::vector<std::string>& names__, const bool
 818 :                   emit_transformed_parameters__ = true, const bool
 819 :                   emit_generated_quantities__ = true) const {
 820 :     names__ = std::vector<std::string>{"rho", "alpha", "sigma", "eps",
 821 :                 "delta_x_raw", "delta_y_raw"};
 822 :     if (emit_transformed_parameters__) {
 823 :       std::vector<std::string> temp{"delta_x", "delta_y", "eps_scale"};
 824 :       names__.reserve(names__.size() + temp.size());
 825 :       names__.insert(names__.end(), temp.begin(), temp.end());
 826 :     }
 827 :     if (emit_generated_quantities__) {}
 828 :   }
 829 :   inline void
 830 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 831 :            emit_transformed_parameters__ = true, const bool
 832 :            emit_generated_quantities__ = true) const {
 833 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 834 :                 std::vector<size_t>{}, std::vector<size_t>{},
 835 :                 std::vector<size_t>{static_cast<size_t>(K)},
 836 :                 std::vector<size_t>{static_cast<size_t>(C)},
 837 :                 std::vector<size_t>{static_cast<size_t>(C)}};
 838 :     if (emit_transformed_parameters__) {
 839 :       std::vector<std::vector<size_t>>
 840 :         temp{std::vector<size_t>{static_cast<size_t>(C)},
 841 :              std::vector<size_t>{static_cast<size_t>(C)},
 842 :              std::vector<size_t>{static_cast<size_t>(K)}};
 843 :       dimss__.reserve(dimss__.size() + temp.size());
 844 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 845 :     }
 846 :     if (emit_generated_quantities__) {}
 847 :   }
 848 :   inline void
 849 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 850 :                           emit_transformed_parameters__ = true, bool
 851 :                           emit_generated_quantities__ = true) const final {
 852 :     param_names__.emplace_back(std::string() + "rho");
 853 :     param_names__.emplace_back(std::string() + "alpha");
 854 :     param_names__.emplace_back(std::string() + "sigma");
 855 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 856 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 857 :         std::to_string(sym1__));
 858 :     }
 859 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 860 :       param_names__.emplace_back(std::string() + "delta_x_raw" + '.' +
 861 :         std::to_string(sym1__));
 862 :     }
 863 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 864 :       param_names__.emplace_back(std::string() + "delta_y_raw" + '.' +
 865 :         std::to_string(sym1__));
 866 :     }
 867 :     if (emit_transformed_parameters__) {
 868 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 869 :         param_names__.emplace_back(std::string() + "delta_x" + '.' +
 870 :           std::to_string(sym1__));
 871 :       }
 872 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 873 :         param_names__.emplace_back(std::string() + "delta_y" + '.' +
 874 :           std::to_string(sym1__));
 875 :       }
 876 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 877 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 878 :           std::to_string(sym1__));
 879 :       }
 880 :     }
 881 :     if (emit_generated_quantities__) {}
 882 :   }
 883 :   inline void
 884 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 885 :                             emit_transformed_parameters__ = true, bool
 886 :                             emit_generated_quantities__ = true) const final {
 887 :     param_names__.emplace_back(std::string() + "rho");
 888 :     param_names__.emplace_back(std::string() + "alpha");
 889 :     param_names__.emplace_back(std::string() + "sigma");
 890 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 891 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 892 :         std::to_string(sym1__));
 893 :     }
 894 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 895 :       param_names__.emplace_back(std::string() + "delta_x_raw" + '.' +
 896 :         std::to_string(sym1__));
 897 :     }
 898 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 899 :       param_names__.emplace_back(std::string() + "delta_y_raw" + '.' +
 900 :         std::to_string(sym1__));
 901 :     }
 902 :     if (emit_transformed_parameters__) {
 903 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 904 :         param_names__.emplace_back(std::string() + "delta_x" + '.' +
 905 :           std::to_string(sym1__));
 906 :       }
 907 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 908 :         param_names__.emplace_back(std::string() + "delta_y" + '.' +
 909 :           std::to_string(sym1__));
 910 :       }
 911 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 912 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 913 :           std::to_string(sym1__));
 914 :       }
 915 :     }
 916 :     if (emit_generated_quantities__) {}
 917 :   }
 918 :   inline std::string get_constrained_sizedtypes() const {
 919 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 920 :   }
 921 :   inline std::string get_unconstrained_sizedtypes() const {
 922 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y_raw\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 923 :   }
 924 :   // Begin method overload boilerplate
 925 :   template <typename RNG> inline void
 926 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 927 :               Eigen::Matrix<double,-1,1>& vars, const bool
 928 :               emit_transformed_parameters = true, const bool
 929 :               emit_generated_quantities = true, std::ostream*
 930 :               pstream = nullptr) const {
 931 :     const size_t num_params__ = (((((1 + 1) + 1) + K) + C) + C);
 932 :     const size_t num_transformed = emit_transformed_parameters * (((C + C) +
 933 :       K));
 934 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 935 :     const size_t num_to_write = num_params__ + num_transformed +
 936 :       num_gen_quantities;
 937 :     std::vector<int> params_i;
 938 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 939 :              std::numeric_limits<double>::quiet_NaN());
 940 :     write_array_impl(base_rng, params_r, params_i, vars,
 941 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 942 :   }
 943 :   template <typename RNG> inline void
 944 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 945 :               params_i, std::vector<double>& vars, bool
 946 :               emit_transformed_parameters = true, bool
 947 :               emit_generated_quantities = true, std::ostream*
 948 :               pstream = nullptr) const {
 949 :     const size_t num_params__ = (((((1 + 1) + 1) + K) + C) + C);
 950 :     const size_t num_transformed = emit_transformed_parameters * (((C + C) +
 951 :       K));
 952 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 953 :     const size_t num_to_write = num_params__ + num_transformed +
 954 :       num_gen_quantities;
 955 :     vars = std::vector<double>(num_to_write,
 956 :              std::numeric_limits<double>::quiet_NaN());
 957 :     write_array_impl(base_rng, params_r, params_i, vars,
 958 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 959 :   }
 960 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 961 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 962 :     Eigen::Matrix<int,-1,1> params_i;
 963 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 964 :   }
 965 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 966 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 967 :            std::ostream* pstream = nullptr) const {
 968 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 969 :   }
 970 :   inline void
 971 :   transform_inits(const stan::io::var_context& context,
 972 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 973 :                   pstream = nullptr) const final {
 974 :     std::vector<double> params_r_vec(params_r.size());
 975 :     std::vector<int> params_i;
 976 :     transform_inits(context, params_i, params_r_vec, pstream);
 977 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 978 :                  params_r_vec.size());
 979 :   }
 980 :   inline void
 981 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 982 :                   params_i, std::vector<double>& vars, std::ostream*
 983 :                   pstream__ = nullptr) const {
 984 :     vars.resize(num_params_r__);
 985 :     transform_inits_impl(context, vars, pstream__);
 986 :   }
 987 :   inline void
 988 :   unconstrain_array(const std::vector<double>& params_constrained,
 989 :                     std::vector<double>& params_unconstrained, std::ostream*
 990 :                     pstream = nullptr) const {
 991 :     const std::vector<int> params_i;
 992 :     params_unconstrained = std::vector<double>(num_params_r__,
 993 :                              std::numeric_limits<double>::quiet_NaN());
 994 :     unconstrain_array_impl(params_constrained, params_i,
 995 :       params_unconstrained, pstream);
 996 :   }
 997 :   inline void
 998 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 999 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
1000 :                     std::ostream* pstream = nullptr) const {
1001 :     const std::vector<int> params_i;
1002 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
1003 :                              std::numeric_limits<double>::quiet_NaN());
1004 :     unconstrain_array_impl(params_constrained, params_i,
1005 :       params_unconstrained, pstream);
1006 :   }
1007 : };
1008 : }
1009 : using stan_model = model1be2ed6a46e000__namespace::model1be2ed6a46e000_;
1010 : #ifndef USING_R
1011 : // Boilerplate
1012 : stan::model::model_base&
1013 : new_model(stan::io::var_context& data_context, unsigned int seed,
1014 :           std::ostream* msg_stream) {
1015 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
1016 :   return *m;
1017 : }
1018 : stan::math::profile_map& get_stan_profile_data() {
1019 :   return model1be2ed6a46e000__namespace::profiles__;
1020 : }
1021 : #endif
1022 : #endif
1023 : 
1024 : RCPP_MODULE(stan_fit4model1be2ed6a46e000__mod) {
1025 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
1026 :       "stan_fit4model1be2ed6a46e000_")
1027 : 
1028 :       .constructor<SEXP, SEXP, SEXP>()
1029 : 
1030 :       .method(
1031 :           "call_sampler",
1032 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
1033 :       .method(
1034 :           "param_names",
1035 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
1036 :       .method("param_names_oi",
1037 :               &rstan::stan_fit<stan_model,
1038 :                                boost::random::ecuyer1988>::param_names_oi)
1039 :       .method("param_fnames_oi",
1040 :               &rstan::stan_fit<stan_model,
1041 :                                boost::random::ecuyer1988>::param_fnames_oi)
1042 :       .method(
1043 :           "param_dims",
1044 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
1045 :       .method("param_dims_oi",
1046 :               &rstan::stan_fit<stan_model,
1047 :                                boost::random::ecuyer1988>::param_dims_oi)
1048 :       .method("update_param_oi",
1049 :               &rstan::stan_fit<stan_model,
1050 :                                boost::random::ecuyer1988>::update_param_oi)
1051 :       .method("param_oi_tidx",
1052 :               &rstan::stan_fit<stan_model,
1053 :                                boost::random::ecuyer1988>::param_oi_tidx)
1054 :       .method("grad_log_prob",
1055 :               &rstan::stan_fit<stan_model,
1056 :                                boost::random::ecuyer1988>::grad_log_prob)
1057 :       .method("log_prob",
1058 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
1059 :       .method("unconstrain_pars",
1060 :               &rstan::stan_fit<stan_model,
1061 :                                boost::random::ecuyer1988>::unconstrain_pars)
1062 :       .method("constrain_pars",
1063 :               &rstan::stan_fit<stan_model,
1064 :                                boost::random::ecuyer1988>::constrain_pars)
1065 :       .method(
1066 :           "num_pars_unconstrained",
1067 :           &rstan::stan_fit<stan_model,
1068 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
1069 :       .method(
1070 :           "unconstrained_param_names",
1071 :           &rstan::stan_fit<
1072 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
1073 :       .method(
1074 :           "constrained_param_names",
1075 :           &rstan::stan_fit<stan_model,
1076 :                            boost::random::ecuyer1988>::constrained_param_names)
1077 :       .method("standalone_gqs",
1078 :               &rstan::stan_fit<stan_model,
1079 :                                boost::random::ecuyer1988>::standalone_gqs);
1080 : }
1081 : 
1082 : 
1083 : // declarations
1084 : extern "C" {
1085 : SEXP file1be2ed48e459e9( ) ;
1086 : }
1087 : 
1088 : // definition
1089 : SEXP file1be2ed48e459e9() {
1090 :  return Rcpp::wrap("anon_model");
1091 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file1be2ed48e459e9.so' OBJECTS='file1be2ed48e459e9.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file1be2ed48e459e9.cpp -o file1be2ed48e459e9.o
if test  "zfile1be2ed48e459e9.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file1be2ed48e459e9.so file1be2ed48e459e9.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file1be2ed48e459e9.so file1be2ed48e459e9.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).
Chain 1: 
Chain 1: Gradient evaluation took 0.05295 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 529.5 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: 
Chain 2: Gradient evaluation took 0.051953 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 519.53 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 4: 
Chain 4: Gradient evaluation took 0.051047 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 510.47 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 3: 
Chain 3: Gradient evaluation took 0.050629 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 506.29 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 1: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 2: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 4: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 4: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 4: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 3: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 1: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 2: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 4: Iteration: 1200 / 4000 [ 30%]  (Warmup)
Chain 3: Iteration: 1200 / 4000 [ 30%]  (Warmup)
Chain 1: Iteration: 1200 / 4000 [ 30%]  (Warmup)
Chain 2: Iteration: 1200 / 4000 [ 30%]  (Warmup)
Chain 3: Iteration: 1600 / 4000 [ 40%]  (Warmup)
Chain 4: Iteration: 1600 / 4000 [ 40%]  (Warmup)
Chain 1: Iteration: 1600 / 4000 [ 40%]  (Warmup)
Chain 2: Iteration: 1600 / 4000 [ 40%]  (Warmup)
Chain 3: Iteration: 2000 / 4000 [ 50%]  (Warmup)
Chain 3: Iteration: 2001 / 4000 [ 50%]  (Sampling)
Chain 1: Iteration: 2000 / 4000 [ 50%]  (Warmup)
Chain 1: Iteration: 2001 / 4000 [ 50%]  (Sampling)
Chain 4: Iteration: 2000 / 4000 [ 50%]  (Warmup)
Chain 4: Iteration: 2001 / 4000 [ 50%]  (Sampling)
Chain 2: Iteration: 2000 / 4000 [ 50%]  (Warmup)
Chain 2: Iteration: 2001 / 4000 [ 50%]  (Sampling)
Chain 3: Iteration: 2400 / 4000 [ 60%]  (Sampling)
Chain 1: Iteration: 2400 / 4000 [ 60%]  (Sampling)
Chain 4: Iteration: 2400 / 4000 [ 60%]  (Sampling)
Chain 2: Iteration: 2400 / 4000 [ 60%]  (Sampling)
Chain 3: Iteration: 2800 / 4000 [ 70%]  (Sampling)
Chain 1: Iteration: 2800 / 4000 [ 70%]  (Sampling)
Chain 4: Iteration: 2800 / 4000 [ 70%]  (Sampling)
Chain 2: Iteration: 2800 / 4000 [ 70%]  (Sampling)
Chain 3: Iteration: 3200 / 4000 [ 80%]  (Sampling)
Chain 4: Iteration: 3200 / 4000 [ 80%]  (Sampling)
Chain 1: Iteration: 3200 / 4000 [ 80%]  (Sampling)
Chain 2: Iteration: 3200 / 4000 [ 80%]  (Sampling)
Chain 3: Iteration: 3600 / 4000 [ 90%]  (Sampling)
Chain 4: Iteration: 3600 / 4000 [ 90%]  (Sampling)
Chain 1: Iteration: 3600 / 4000 [ 90%]  (Sampling)
Chain 2: Iteration: 3600 / 4000 [ 90%]  (Sampling)
Chain 3: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 5458.91 seconds (Warm-up)
Chain 3:                2693.01 seconds (Sampling)
Chain 3:                8151.93 seconds (Total)
Chain 3: 
Chain 4: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 5527.01 seconds (Warm-up)
Chain 4:                2687.34 seconds (Sampling)
Chain 4:                8214.35 seconds (Total)
Chain 4: 
Chain 1: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 5520.93 seconds (Warm-up)
Chain 1:                2700.75 seconds (Sampling)
Chain 1:                8221.68 seconds (Total)
Chain 1: 
Chain 2: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 5661.8 seconds (Warm-up)
Chain 2:                2683.93 seconds (Sampling)
Chain 2:                8345.74 seconds (Total)
Chain 2: 
