
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model31a47c1700fbaa__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 75> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 23, column 2 to column 20)",
  25 :   " (in 'anon_model', line 24, column 2 to column 13)",
  26 :   " (in 'anon_model', line 25, column 2 to column 22)",
  27 :   " (in 'anon_model', line 26, column 2 to column 20)",
  28 :   " (in 'anon_model', line 27, column 2 to column 31)",
  29 :   " (in 'anon_model', line 28, column 2 to column 16)",
  30 :   " (in 'anon_model', line 31, column 2 to column 54)",
  31 :   " (in 'anon_model', line 32, column 2 to column 54)",
  32 :   " (in 'anon_model', line 76, column 2 to column 42)",
  33 :   " (in 'anon_model', line 80, column 9 to column 10)",
  34 :   " (in 'anon_model', line 80, column 2 to column 18)",
  35 :   " (in 'anon_model', line 83, column 9 to column 10)",
  36 :   " (in 'anon_model', line 83, column 2 to column 40)",
  37 :   " (in 'anon_model', line 86, column 2 to column 30)",
  38 :   " (in 'anon_model', line 87, column 2 to column 36)",
  39 :   " (in 'anon_model', line 93, column 4 to line 94, column 71)",
  40 :   " (in 'anon_model', line 95, column 4 to column 89)",
  41 :   " (in 'anon_model', line 104, column 6 to column 20)",
  42 :   " (in 'anon_model', line 103, column 11 to line 105, column 5)",
  43 :   " (in 'anon_model', line 101, column 12 to column 56)",
  44 :   " (in 'anon_model', line 100, column 15 to line 102, column 11)",
  45 :   " (in 'anon_model', line 99, column 12 to column 25)",
  46 :   " (in 'anon_model', line 98, column 30 to line 100, column 11)",
  47 :   " (in 'anon_model', line 98, column 6 to line 102, column 11)",
  48 :   " (in 'anon_model', line 97, column 31 to line 103, column 5)",
  49 :   " (in 'anon_model', line 97, column 4 to line 105, column 5)",
  50 :   " (in 'anon_model', line 107, column 4 to column 41)",
  51 :   " (in 'anon_model', line 90, column 16 to line 108, column 9)",
  52 :   " (in 'anon_model', line 90, column 2 to line 108, column 9)",
  53 :   " (in 'anon_model', line 78, column 2 to line 109, column 3)",
  54 :   " (in 'anon_model', line 36, column 2 to column 33)",
  55 :   " (in 'anon_model', line 37, column 2 to column 22)",
  56 :   " (in 'anon_model', line 38, column 2 to column 23)",
  57 :   " (in 'anon_model', line 39, column 2 to column 21)",
  58 :   " (in 'anon_model', line 40, column 2 to column 30)",
  59 :   " (in 'anon_model', line 45, column 9 to column 10)",
  60 :   " (in 'anon_model', line 45, column 2 to column 40)",
  61 :   " (in 'anon_model', line 48, column 2 to column 30)",
  62 :   " (in 'anon_model', line 49, column 2 to column 36)",
  63 :   " (in 'anon_model', line 55, column 4 to line 56, column 71)",
  64 :   " (in 'anon_model', line 57, column 4 to column 89)",
  65 :   " (in 'anon_model', line 66, column 6 to column 77)",
  66 :   " (in 'anon_model', line 69, column 6 to column 59)",
  67 :   " (in 'anon_model', line 65, column 11 to line 70, column 5)",
  68 :   " (in 'anon_model', line 61, column 6 to line 64, column 8)",
  69 :   " (in 'anon_model', line 60, column 23 to line 65, column 5)",
  70 :   " (in 'anon_model', line 60, column 4 to line 70, column 5)",
  71 :   " (in 'anon_model', line 52, column 16 to line 71, column 3)",
  72 :   " (in 'anon_model', line 52, column 2 to line 71, column 3)",
  73 :   " (in 'anon_model', line 43, column 2 to line 72, column 3)",
  74 :   " (in 'anon_model', line 4, column 2 to column 17)",
  75 :   " (in 'anon_model', line 5, column 2 to column 17)",
  76 :   " (in 'anon_model', line 6, column 2 to column 17)",
  77 :   " (in 'anon_model', line 7, column 9 to column 10)",
  78 :   " (in 'anon_model', line 7, column 2 to column 26)",
  79 :   " (in 'anon_model', line 8, column 9 to column 10)",
  80 :   " (in 'anon_model', line 8, column 2 to column 23)",
  81 :   " (in 'anon_model', line 9, column 16 to column 17)",
  82 :   " (in 'anon_model', line 9, column 2 to column 19)",
  83 :   " (in 'anon_model', line 10, column 14 to column 15)",
  84 :   " (in 'anon_model', line 10, column 2 to column 17)",
  85 :   " (in 'anon_model', line 11, column 12 to column 13)",
  86 :   " (in 'anon_model', line 11, column 2 to column 15)",
  87 :   " (in 'anon_model', line 12, column 2 to column 15)",
  88 :   " (in 'anon_model', line 13, column 2 to column 15)",
  89 :   " (in 'anon_model', line 14, column 2 to column 15)",
  90 :   " (in 'anon_model', line 15, column 2 to column 15)",
  91 :   " (in 'anon_model', line 18, column 2 to column 18)",
  92 :   " (in 'anon_model', line 19, column 2 to column 22)",
  93 :   " (in 'anon_model', line 20, column 2 to column 20)",
  94 :   " (in 'anon_model', line 28, column 9 to column 10)",
  95 :   " (in 'anon_model', line 31, column 8 to column 9)",
  96 :   " (in 'anon_model', line 32, column 8 to column 9)",
  97 :   " (in 'anon_model', line 76, column 9 to column 10)"};
  98 : class model31a47c1700fbaa_ final : public model_base_crtp<model31a47c1700fbaa_> {
  99 : private:
 100 :   int C;
 101 :   int K;
 102 :   int O;
 103 :   Eigen::Matrix<double,-1,1> sample_effort_data__;
 104 :   Eigen::Matrix<double,-1,-1> trap_pos_data__;
 105 :   std::vector<int> colony_id;
 106 :   std::vector<int> trap_id;
 107 :   std::vector<int> y_obs;
 108 :   double upper_y;
 109 :   double upper_x;
 110 :   double lower_y;
 111 :   double lower_x;
 112 :   double Rmax;
 113 :   double steepness;
 114 :   double penalty;
 115 :   Eigen::Map<Eigen::Matrix<double,-1,1>> sample_effort{nullptr, 0};
 116 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap_pos{nullptr, 0, 0};
 117 : public:
 118 :   ~model31a47c1700fbaa_() {}
 119 :   model31a47c1700fbaa_(stan::io::var_context& context__, unsigned int
 120 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
 121 :       : model_base_crtp(0) {
 122 :     int current_statement__ = 0;
 123 :     using local_scalar_t__ = double;
 124 :     boost::ecuyer1988 base_rng__ =
 125 :       stan::services::util::create_rng(random_seed__, 0);
 126 :     // suppress unused var warning
 127 :     (void) base_rng__;
 128 :     static constexpr const char* function__ =
 129 :       "model31a47c1700fbaa__namespace::model31a47c1700fbaa_";
 130 :     // suppress unused var warning
 131 :     (void) function__;
 132 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 133 :     // suppress unused var warning
 134 :     (void) DUMMY_VAR__;
 135 :     try {
 136 :       int pos__ = std::numeric_limits<int>::min();
 137 :       pos__ = 1;
 138 :       current_statement__ = 51;
 139 :       context__.validate_dims("data initialization", "C", "int",
 140 :         std::vector<size_t>{});
 141 :       C = std::numeric_limits<int>::min();
 142 :       current_statement__ = 51;
 143 :       C = context__.vals_i("C")[(1 - 1)];
 144 :       current_statement__ = 51;
 145 :       stan::math::check_greater_or_equal(function__, "C", C, 0);
 146 :       current_statement__ = 52;
 147 :       context__.validate_dims("data initialization", "K", "int",
 148 :         std::vector<size_t>{});
 149 :       K = std::numeric_limits<int>::min();
 150 :       current_statement__ = 52;
 151 :       K = context__.vals_i("K")[(1 - 1)];
 152 :       current_statement__ = 52;
 153 :       stan::math::check_greater_or_equal(function__, "K", K, 0);
 154 :       current_statement__ = 53;
 155 :       context__.validate_dims("data initialization", "O", "int",
 156 :         std::vector<size_t>{});
 157 :       O = std::numeric_limits<int>::min();
 158 :       current_statement__ = 53;
 159 :       O = context__.vals_i("O")[(1 - 1)];
 160 :       current_statement__ = 53;
 161 :       stan::math::check_greater_or_equal(function__, "O", O, 0);
 162 :       current_statement__ = 54;
 163 :       stan::math::validate_non_negative_index("sample_effort", "O", O);
 164 :       current_statement__ = 55;
 165 :       context__.validate_dims("data initialization", "sample_effort",
 166 :         "double", std::vector<size_t>{static_cast<size_t>(O)});
 167 :       sample_effort_data__ = Eigen::Matrix<double,-1,1>::Constant(O,
 168 :                                std::numeric_limits<double>::quiet_NaN());
 169 :       new (&sample_effort)
 170 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(sample_effort_data__.data(),
 171 :         O);
 172 :       {
 173 :         std::vector<local_scalar_t__> sample_effort_flat__;
 174 :         current_statement__ = 55;
 175 :         sample_effort_flat__ = context__.vals_r("sample_effort");
 176 :         current_statement__ = 55;
 177 :         pos__ = 1;
 178 :         current_statement__ = 55;
 179 :         for (int sym1__ = 1; sym1__ <= O; ++sym1__) {
 180 :           current_statement__ = 55;
 181 :           stan::model::assign(sample_effort, sample_effort_flat__[(pos__ -
 182 :             1)], "assigning variable sample_effort",
 183 :             stan::model::index_uni(sym1__));
 184 :           current_statement__ = 55;
 185 :           pos__ = (pos__ + 1);
 186 :         }
 187 :       }
 188 :       current_statement__ = 56;
 189 :       stan::math::validate_non_negative_index("trap_pos", "O", O);
 190 :       current_statement__ = 57;
 191 :       context__.validate_dims("data initialization", "trap_pos", "double",
 192 :         std::vector<size_t>{static_cast<size_t>(O), static_cast<size_t>(2)});
 193 :       trap_pos_data__ = Eigen::Matrix<double,-1,-1>::Constant(O, 2,
 194 :                           std::numeric_limits<double>::quiet_NaN());
 195 :       new (&trap_pos)
 196 :         Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_pos_data__.data(), O, 2);
 197 :       {
 198 :         std::vector<local_scalar_t__> trap_pos_flat__;
 199 :         current_statement__ = 57;
 200 :         trap_pos_flat__ = context__.vals_r("trap_pos");
 201 :         current_statement__ = 57;
 202 :         pos__ = 1;
 203 :         current_statement__ = 57;
 204 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 205 :           current_statement__ = 57;
 206 :           for (int sym2__ = 1; sym2__ <= O; ++sym2__) {
 207 :             current_statement__ = 57;
 208 :             stan::model::assign(trap_pos, trap_pos_flat__[(pos__ - 1)],
 209 :               "assigning variable trap_pos", stan::model::index_uni(sym2__),
 210 :               stan::model::index_uni(sym1__));
 211 :             current_statement__ = 57;
 212 :             pos__ = (pos__ + 1);
 213 :           }
 214 :         }
 215 :       }
 216 :       current_statement__ = 58;
 217 :       stan::math::validate_non_negative_index("colony_id", "O", O);
 218 :       current_statement__ = 59;
 219 :       context__.validate_dims("data initialization", "colony_id", "int",
 220 :         std::vector<size_t>{static_cast<size_t>(O)});
 221 :       colony_id = std::vector<int>(O, std::numeric_limits<int>::min());
 222 :       current_statement__ = 59;
 223 :       colony_id = context__.vals_i("colony_id");
 224 :       current_statement__ = 60;
 225 :       stan::math::validate_non_negative_index("trap_id", "O", O);
 226 :       current_statement__ = 61;
 227 :       context__.validate_dims("data initialization", "trap_id", "int",
 228 :         std::vector<size_t>{static_cast<size_t>(O)});
 229 :       trap_id = std::vector<int>(O, std::numeric_limits<int>::min());
 230 :       current_statement__ = 61;
 231 :       trap_id = context__.vals_i("trap_id");
 232 :       current_statement__ = 62;
 233 :       stan::math::validate_non_negative_index("y_obs", "O", O);
 234 :       current_statement__ = 63;
 235 :       context__.validate_dims("data initialization", "y_obs", "int",
 236 :         std::vector<size_t>{static_cast<size_t>(O)});
 237 :       y_obs = std::vector<int>(O, std::numeric_limits<int>::min());
 238 :       current_statement__ = 63;
 239 :       y_obs = context__.vals_i("y_obs");
 240 :       current_statement__ = 64;
 241 :       context__.validate_dims("data initialization", "upper_y", "double",
 242 :         std::vector<size_t>{});
 243 :       upper_y = std::numeric_limits<double>::quiet_NaN();
 244 :       current_statement__ = 64;
 245 :       upper_y = context__.vals_r("upper_y")[(1 - 1)];
 246 :       current_statement__ = 65;
 247 :       context__.validate_dims("data initialization", "upper_x", "double",
 248 :         std::vector<size_t>{});
 249 :       upper_x = std::numeric_limits<double>::quiet_NaN();
 250 :       current_statement__ = 65;
 251 :       upper_x = context__.vals_r("upper_x")[(1 - 1)];
 252 :       current_statement__ = 66;
 253 :       context__.validate_dims("data initialization", "lower_y", "double",
 254 :         std::vector<size_t>{});
 255 :       lower_y = std::numeric_limits<double>::quiet_NaN();
 256 :       current_statement__ = 66;
 257 :       lower_y = context__.vals_r("lower_y")[(1 - 1)];
 258 :       current_statement__ = 67;
 259 :       context__.validate_dims("data initialization", "lower_x", "double",
 260 :         std::vector<size_t>{});
 261 :       lower_x = std::numeric_limits<double>::quiet_NaN();
 262 :       current_statement__ = 67;
 263 :       lower_x = context__.vals_r("lower_x")[(1 - 1)];
 264 :       current_statement__ = 68;
 265 :       Rmax = std::numeric_limits<double>::quiet_NaN();
 266 :       current_statement__ = 68;
 267 :       Rmax = 2.0;
 268 :       current_statement__ = 69;
 269 :       steepness = std::numeric_limits<double>::quiet_NaN();
 270 :       current_statement__ = 69;
 271 :       steepness = 10;
 272 :       current_statement__ = 70;
 273 :       penalty = std::numeric_limits<double>::quiet_NaN();
 274 :       current_statement__ = 70;
 275 :       penalty = 10;
 276 :       current_statement__ = 71;
 277 :       stan::math::validate_non_negative_index("eps", "K", K);
 278 :       current_statement__ = 72;
 279 :       stan::math::validate_non_negative_index("delta_x", "C", C);
 280 :       current_statement__ = 73;
 281 :       stan::math::validate_non_negative_index("delta_y", "C", C);
 282 :       current_statement__ = 74;
 283 :       stan::math::validate_non_negative_index("sibspercol", "C", C);
 284 :     } catch (const std::exception& e) {
 285 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 286 :     }
 287 :     num_params_r__ = 1 + 1 + 1 + 1 + 1 + K + C + C;
 288 :   }
 289 :   inline std::string model_name() const final {
 290 :     return "model31a47c1700fbaa_";
 291 :   }
 292 :   inline std::vector<std::string> model_compile_info() const noexcept {
 293 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 294 :              "stancflags = --"};
 295 :   }
 296 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 297 :             stan::require_vector_like_t<VecR>* = nullptr,
 298 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 299 :   inline stan::scalar_type_t<VecR>
 300 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 301 :                 pstream__ = nullptr) const {
 302 :     using T__ = stan::scalar_type_t<VecR>;
 303 :     using local_scalar_t__ = T__;
 304 :     T__ lp__(0.0);
 305 :     stan::math::accumulator<T__> lp_accum__;
 306 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 307 :     int current_statement__ = 0;
 308 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 309 :     // suppress unused var warning
 310 :     (void) DUMMY_VAR__;
 311 :     static constexpr const char* function__ =
 312 :       "model31a47c1700fbaa__namespace::log_prob";
 313 :     // suppress unused var warning
 314 :     (void) function__;
 315 :     try {
 316 :       local_scalar_t__ rho = DUMMY_VAR__;
 317 :       current_statement__ = 1;
 318 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 319 :               lp__);
 320 :       local_scalar_t__ alpha = DUMMY_VAR__;
 321 :       current_statement__ = 2;
 322 :       alpha = in__.template read<local_scalar_t__>();
 323 :       local_scalar_t__ sigma = DUMMY_VAR__;
 324 :       current_statement__ = 3;
 325 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 326 :                 jacobian__>(0, lp__);
 327 :       local_scalar_t__ phi = DUMMY_VAR__;
 328 :       current_statement__ = 4;
 329 :       phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 330 :               lp__);
 331 :       local_scalar_t__ theta = DUMMY_VAR__;
 332 :       current_statement__ = 5;
 333 :       theta = in__.template read_constrain_lub<local_scalar_t__,
 334 :                 jacobian__>(0, 1, lp__);
 335 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 336 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 337 :       current_statement__ = 6;
 338 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 339 :       std::vector<local_scalar_t__> delta_x =
 340 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 341 :       current_statement__ = 7;
 342 :       delta_x = in__.template read_constrain_lub<
 343 :                   std::vector<local_scalar_t__>, jacobian__>(lower_x,
 344 :                   upper_x, lp__, C);
 345 :       std::vector<local_scalar_t__> delta_y =
 346 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 347 :       current_statement__ = 8;
 348 :       delta_y = in__.template read_constrain_lub<
 349 :                   std::vector<local_scalar_t__>, jacobian__>(lower_y,
 350 :                   upper_y, lp__, C);
 351 :       {
 352 :         current_statement__ = 31;
 353 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho,
 354 :                          stan::math::log(0.5), 0.5));
 355 :         current_statement__ = 32;
 356 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 0, 1));
 357 :         current_statement__ = 33;
 358 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, 1));
 359 :         current_statement__ = 34;
 360 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 361 :         current_statement__ = 35;
 362 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(phi,
 363 :                          stan::math::log(10), 1));
 364 :         {
 365 :           current_statement__ = 36;
 366 :           stan::math::validate_non_negative_index("eps_scale", "K", K);
 367 :           Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 368 :             Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 369 :           current_statement__ = 37;
 370 :           stan::model::assign(eps_scale,
 371 :             stan::math::multiply(eps, stan::math::sqrt(sigma)),
 372 :             "assigning variable eps_scale");
 373 :           local_scalar_t__ log_theta = DUMMY_VAR__;
 374 :           current_statement__ = 38;
 375 :           log_theta = stan::math::log(theta);
 376 :           local_scalar_t__ log_not_theta = DUMMY_VAR__;
 377 :           current_statement__ = 39;
 378 :           log_not_theta = stan::math::log((1 - theta));
 379 :           current_statement__ = 49;
 380 :           for (int n = 1; n <= O; ++n) {
 381 :             local_scalar_t__ dis = DUMMY_VAR__;
 382 :             current_statement__ = 40;
 383 :             dis = stan::math::sqrt(
 384 :                     (stan::math::square(
 385 :                        (stan::model::rvalue(delta_x, "delta_x",
 386 :                           stan::model::index_uni(
 387 :                             stan::model::rvalue(colony_id, "colony_id",
 388 :                               stan::model::index_uni(n)))) -
 389 :                        stan::model::rvalue(trap_pos, "trap_pos",
 390 :                          stan::model::index_uni(n), stan::model::index_uni(1))))
 391 :                     +
 392 :                     stan::math::square(
 393 :                       (stan::model::rvalue(delta_y, "delta_y",
 394 :                          stan::model::index_uni(
 395 :                            stan::model::rvalue(colony_id, "colony_id",
 396 :                              stan::model::index_uni(n)))) -
 397 :                       stan::model::rvalue(trap_pos, "trap_pos",
 398 :                         stan::model::index_uni(n), stan::model::index_uni(2))))));
 399 :             local_scalar_t__ eta = DUMMY_VAR__;
 400 :             current_statement__ = 41;
 401 :             eta = (((alpha - (0.5 * stan::math::pow((dis / rho), 2))) +
 402 :               stan::model::rvalue(eps_scale, "eps_scale",
 403 :                 stan::model::index_uni(
 404 :                   stan::model::rvalue(trap_id, "trap_id",
 405 :                     stan::model::index_uni(n)))))
 406 :               +
 407 :               stan::math::log(
 408 :                 stan::model::rvalue(sample_effort, "sample_effort",
 409 :                   stan::model::index_uni(n))));
 410 :             current_statement__ = 47;
 411 :             if (stan::math::logical_eq(
 412 :                   stan::model::rvalue(y_obs, "y_obs",
 413 :                     stan::model::index_uni(n)), 0)) {
 414 :               current_statement__ = 45;
 415 :               lp_accum__.add(stan::math::log_sum_exp(log_theta,
 416 :                                (log_not_theta +
 417 :                                stan::math::neg_binomial_2_log_lpmf<false>(0,
 418 :                                  eta, phi))));
 419 :             } else {
 420 :               current_statement__ = 42;
 421 :               lp_accum__.add((log_not_theta +
 422 :                 stan::math::neg_binomial_2_log_lpmf<false>(
 423 :                   stan::model::rvalue(y_obs, "y_obs",
 424 :                     stan::model::index_uni(n)), eta, phi)));
 425 :               current_statement__ = 43;
 426 :               lp_accum__.add((-penalty *
 427 :                 stan::math::log1p_exp(((dis - Rmax) * steepness))));
 428 :             }
 429 :           }
 430 :         }
 431 :       }
 432 :     } catch (const std::exception& e) {
 433 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 434 :     }
 435 :     lp_accum__.add(lp__);
 436 :     return lp_accum__.sum();
 437 :   }
 438 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 439 :             stan::require_vector_like_vt<std::is_floating_point,
 440 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 441 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 442 :             VecVar>* = nullptr>
 443 :   inline void
 444 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 445 :                    VecVar& vars__, const bool
 446 :                    emit_transformed_parameters__ = true, const bool
 447 :                    emit_generated_quantities__ = true, std::ostream*
 448 :                    pstream__ = nullptr) const {
 449 :     using local_scalar_t__ = double;
 450 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 451 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 452 :     static constexpr bool propto__ = true;
 453 :     // suppress unused var warning
 454 :     (void) propto__;
 455 :     double lp__ = 0.0;
 456 :     // suppress unused var warning
 457 :     (void) lp__;
 458 :     int current_statement__ = 0;
 459 :     stan::math::accumulator<double> lp_accum__;
 460 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 461 :     // suppress unused var warning
 462 :     (void) DUMMY_VAR__;
 463 :     constexpr bool jacobian__ = false;
 464 :     static constexpr const char* function__ =
 465 :       "model31a47c1700fbaa__namespace::write_array";
 466 :     // suppress unused var warning
 467 :     (void) function__;
 468 :     try {
 469 :       double rho = std::numeric_limits<double>::quiet_NaN();
 470 :       current_statement__ = 1;
 471 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 472 :               lp__);
 473 :       double alpha = std::numeric_limits<double>::quiet_NaN();
 474 :       current_statement__ = 2;
 475 :       alpha = in__.template read<local_scalar_t__>();
 476 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 477 :       current_statement__ = 3;
 478 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 479 :                 jacobian__>(0, lp__);
 480 :       double phi = std::numeric_limits<double>::quiet_NaN();
 481 :       current_statement__ = 4;
 482 :       phi = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 483 :               lp__);
 484 :       double theta = std::numeric_limits<double>::quiet_NaN();
 485 :       current_statement__ = 5;
 486 :       theta = in__.template read_constrain_lub<local_scalar_t__,
 487 :                 jacobian__>(0, 1, lp__);
 488 :       Eigen::Matrix<double,-1,1> eps =
 489 :         Eigen::Matrix<double,-1,1>::Constant(K,
 490 :           std::numeric_limits<double>::quiet_NaN());
 491 :       current_statement__ = 6;
 492 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 493 :       std::vector<double> delta_x =
 494 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 495 :       current_statement__ = 7;
 496 :       delta_x = in__.template read_constrain_lub<
 497 :                   std::vector<local_scalar_t__>, jacobian__>(lower_x,
 498 :                   upper_x, lp__, C);
 499 :       std::vector<double> delta_y =
 500 :         std::vector<double>(C, std::numeric_limits<double>::quiet_NaN());
 501 :       current_statement__ = 8;
 502 :       delta_y = in__.template read_constrain_lub<
 503 :                   std::vector<local_scalar_t__>, jacobian__>(lower_y,
 504 :                   upper_y, lp__, C);
 505 :       out__.write(rho);
 506 :       out__.write(alpha);
 507 :       out__.write(sigma);
 508 :       out__.write(phi);
 509 :       out__.write(theta);
 510 :       out__.write(eps);
 511 :       out__.write(delta_x);
 512 :       out__.write(delta_y);
 513 :       if (stan::math::logical_negation(
 514 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 515 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 516 :         return ;
 517 :       }
 518 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 519 :         return ;
 520 :       }
 521 :       Eigen::Matrix<double,-1,1> sibspercol =
 522 :         Eigen::Matrix<double,-1,1>::Constant(C,
 523 :           std::numeric_limits<double>::quiet_NaN());
 524 :       current_statement__ = 9;
 525 :       stan::model::assign(sibspercol, stan::math::rep_vector(0, C),
 526 :         "assigning variable sibspercol");
 527 :       {
 528 :         current_statement__ = 10;
 529 :         stan::math::validate_non_negative_index("ypred", "O", O);
 530 :         Eigen::Matrix<double,-1,1> ypred =
 531 :           Eigen::Matrix<double,-1,1>::Constant(O,
 532 :             std::numeric_limits<double>::quiet_NaN());
 533 :         current_statement__ = 12;
 534 :         stan::math::validate_non_negative_index("eps_scale", "K", K);
 535 :         Eigen::Matrix<double,-1,1> eps_scale =
 536 :           Eigen::Matrix<double,-1,1>::Constant(K,
 537 :             std::numeric_limits<double>::quiet_NaN());
 538 :         current_statement__ = 13;
 539 :         stan::model::assign(eps_scale,
 540 :           stan::math::multiply(eps, stan::math::sqrt(sigma)),
 541 :           "assigning variable eps_scale");
 542 :         double log_theta = std::numeric_limits<double>::quiet_NaN();
 543 :         current_statement__ = 14;
 544 :         log_theta = stan::math::log(theta);
 545 :         double log_not_theta = std::numeric_limits<double>::quiet_NaN();
 546 :         current_statement__ = 15;
 547 :         log_not_theta = stan::math::log((1 - theta));
 548 :         current_statement__ = 29;
 549 :         for (int n = 1; n <= O; ++n) {
 550 :           double dis = std::numeric_limits<double>::quiet_NaN();
 551 :           current_statement__ = 16;
 552 :           dis = stan::math::sqrt(
 553 :                   (stan::math::square(
 554 :                      (stan::model::rvalue(delta_x, "delta_x",
 555 :                         stan::model::index_uni(
 556 :                           stan::model::rvalue(colony_id, "colony_id",
 557 :                             stan::model::index_uni(n)))) -
 558 :                      stan::model::rvalue(trap_pos, "trap_pos",
 559 :                        stan::model::index_uni(n), stan::model::index_uni(1))))
 560 :                   +
 561 :                   stan::math::square(
 562 :                     (stan::model::rvalue(delta_y, "delta_y",
 563 :                        stan::model::index_uni(
 564 :                          stan::model::rvalue(colony_id, "colony_id",
 565 :                            stan::model::index_uni(n)))) -
 566 :                     stan::model::rvalue(trap_pos, "trap_pos",
 567 :                       stan::model::index_uni(n), stan::model::index_uni(2))))));
 568 :           double eta = std::numeric_limits<double>::quiet_NaN();
 569 :           current_statement__ = 17;
 570 :           eta = (((alpha - (0.5 * stan::math::pow((dis / rho), 2))) +
 571 :             stan::model::rvalue(eps_scale, "eps_scale",
 572 :               stan::model::index_uni(
 573 :                 stan::model::rvalue(trap_id, "trap_id",
 574 :                   stan::model::index_uni(n)))))
 575 :             +
 576 :             stan::math::log(
 577 :               stan::model::rvalue(sample_effort, "sample_effort",
 578 :                 stan::model::index_uni(n))));
 579 :           current_statement__ = 26;
 580 :           if ((stan::math::primitive_value(stan::math::logical_lt(eta, 10))
 581 :               &&
 582 :               stan::math::primitive_value(stan::math::logical_gt(eta, -10)))) {
 583 :             current_statement__ = 24;
 584 :             if (stan::math::bernoulli_rng(theta, base_rng__)) {
 585 :               current_statement__ = 22;
 586 :               stan::model::assign(ypred, 0, "assigning variable ypred",
 587 :                 stan::model::index_uni(n));
 588 :             } else {
 589 :               current_statement__ = 20;
 590 :               stan::model::assign(ypred,
 591 :                 stan::math::neg_binomial_2_log_rng(eta, phi, base_rng__),
 592 :                 "assigning variable ypred", stan::model::index_uni(n));
 593 :             }
 594 :           } else {
 595 :             current_statement__ = 18;
 596 :             stan::model::assign(ypred, -1, "assigning variable ypred",
 597 :               stan::model::index_uni(n));
 598 :           }
 599 :           current_statement__ = 27;
 600 :           stan::model::assign(sibspercol,
 601 :             (stan::model::rvalue(sibspercol, "sibspercol",
 602 :                stan::model::index_uni(
 603 :                  stan::model::rvalue(colony_id, "colony_id",
 604 :                    stan::model::index_uni(n)))) +
 605 :             stan::model::rvalue(ypred, "ypred", stan::model::index_uni(n))),
 606 :             "assigning variable sibspercol",
 607 :             stan::model::index_uni(
 608 :               stan::model::rvalue(colony_id, "colony_id",
 609 :                 stan::model::index_uni(n))));
 610 :         }
 611 :       }
 612 :       out__.write(sibspercol);
 613 :     } catch (const std::exception& e) {
 614 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 615 :     }
 616 :   }
 617 :   template <typename VecVar, typename VecI,
 618 :             stan::require_vector_t<VecVar>* = nullptr,
 619 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 620 :   inline void
 621 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 622 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 623 :     using local_scalar_t__ = double;
 624 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 625 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 626 :     int current_statement__ = 0;
 627 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 628 :     // suppress unused var warning
 629 :     (void) DUMMY_VAR__;
 630 :     try {
 631 :       int pos__ = std::numeric_limits<int>::min();
 632 :       pos__ = 1;
 633 :       local_scalar_t__ rho = DUMMY_VAR__;
 634 :       current_statement__ = 1;
 635 :       rho = in__.read<local_scalar_t__>();
 636 :       out__.write_free_lb(0, rho);
 637 :       local_scalar_t__ alpha = DUMMY_VAR__;
 638 :       current_statement__ = 2;
 639 :       alpha = in__.read<local_scalar_t__>();
 640 :       out__.write(alpha);
 641 :       local_scalar_t__ sigma = DUMMY_VAR__;
 642 :       current_statement__ = 3;
 643 :       sigma = in__.read<local_scalar_t__>();
 644 :       out__.write_free_lb(0, sigma);
 645 :       local_scalar_t__ phi = DUMMY_VAR__;
 646 :       current_statement__ = 4;
 647 :       phi = in__.read<local_scalar_t__>();
 648 :       out__.write_free_lb(0, phi);
 649 :       local_scalar_t__ theta = DUMMY_VAR__;
 650 :       current_statement__ = 5;
 651 :       theta = in__.read<local_scalar_t__>();
 652 :       out__.write_free_lub(0, 1, theta);
 653 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 654 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 655 :       current_statement__ = 6;
 656 :       stan::model::assign(eps,
 657 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 658 :         "assigning variable eps");
 659 :       out__.write(eps);
 660 :       std::vector<local_scalar_t__> delta_x =
 661 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 662 :       current_statement__ = 7;
 663 :       stan::model::assign(delta_x,
 664 :         in__.read<std::vector<local_scalar_t__>>(C),
 665 :         "assigning variable delta_x");
 666 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 667 :       std::vector<local_scalar_t__> delta_y =
 668 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 669 :       current_statement__ = 8;
 670 :       stan::model::assign(delta_y,
 671 :         in__.read<std::vector<local_scalar_t__>>(C),
 672 :         "assigning variable delta_y");
 673 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 674 :     } catch (const std::exception& e) {
 675 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 676 :     }
 677 :   }
 678 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 679 :   inline void
 680 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 681 :                        vars__, std::ostream* pstream__ = nullptr) const {
 682 :     using local_scalar_t__ = double;
 683 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 684 :     int current_statement__ = 0;
 685 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 686 :     // suppress unused var warning
 687 :     (void) DUMMY_VAR__;
 688 :     try {
 689 :       current_statement__ = 1;
 690 :       context__.validate_dims("parameter initialization", "rho", "double",
 691 :         std::vector<size_t>{});
 692 :       current_statement__ = 2;
 693 :       context__.validate_dims("parameter initialization", "alpha", "double",
 694 :         std::vector<size_t>{});
 695 :       current_statement__ = 3;
 696 :       context__.validate_dims("parameter initialization", "sigma", "double",
 697 :         std::vector<size_t>{});
 698 :       current_statement__ = 4;
 699 :       context__.validate_dims("parameter initialization", "phi", "double",
 700 :         std::vector<size_t>{});
 701 :       current_statement__ = 5;
 702 :       context__.validate_dims("parameter initialization", "theta", "double",
 703 :         std::vector<size_t>{});
 704 :       current_statement__ = 6;
 705 :       context__.validate_dims("parameter initialization", "eps", "double",
 706 :         std::vector<size_t>{static_cast<size_t>(K)});
 707 :       current_statement__ = 7;
 708 :       context__.validate_dims("parameter initialization", "delta_x",
 709 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 710 :       current_statement__ = 8;
 711 :       context__.validate_dims("parameter initialization", "delta_y",
 712 :         "double", std::vector<size_t>{static_cast<size_t>(C)});
 713 :       int pos__ = std::numeric_limits<int>::min();
 714 :       pos__ = 1;
 715 :       local_scalar_t__ rho = DUMMY_VAR__;
 716 :       current_statement__ = 1;
 717 :       rho = context__.vals_r("rho")[(1 - 1)];
 718 :       out__.write_free_lb(0, rho);
 719 :       local_scalar_t__ alpha = DUMMY_VAR__;
 720 :       current_statement__ = 2;
 721 :       alpha = context__.vals_r("alpha")[(1 - 1)];
 722 :       out__.write(alpha);
 723 :       local_scalar_t__ sigma = DUMMY_VAR__;
 724 :       current_statement__ = 3;
 725 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 726 :       out__.write_free_lb(0, sigma);
 727 :       local_scalar_t__ phi = DUMMY_VAR__;
 728 :       current_statement__ = 4;
 729 :       phi = context__.vals_r("phi")[(1 - 1)];
 730 :       out__.write_free_lb(0, phi);
 731 :       local_scalar_t__ theta = DUMMY_VAR__;
 732 :       current_statement__ = 5;
 733 :       theta = context__.vals_r("theta")[(1 - 1)];
 734 :       out__.write_free_lub(0, 1, theta);
 735 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 736 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 737 :       {
 738 :         std::vector<local_scalar_t__> eps_flat__;
 739 :         current_statement__ = 6;
 740 :         eps_flat__ = context__.vals_r("eps");
 741 :         current_statement__ = 6;
 742 :         pos__ = 1;
 743 :         current_statement__ = 6;
 744 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 745 :           current_statement__ = 6;
 746 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 747 :             "assigning variable eps", stan::model::index_uni(sym1__));
 748 :           current_statement__ = 6;
 749 :           pos__ = (pos__ + 1);
 750 :         }
 751 :       }
 752 :       out__.write(eps);
 753 :       std::vector<local_scalar_t__> delta_x =
 754 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 755 :       current_statement__ = 7;
 756 :       delta_x = context__.vals_r("delta_x");
 757 :       out__.write_free_lub(lower_x, upper_x, delta_x);
 758 :       std::vector<local_scalar_t__> delta_y =
 759 :         std::vector<local_scalar_t__>(C, DUMMY_VAR__);
 760 :       current_statement__ = 8;
 761 :       delta_y = context__.vals_r("delta_y");
 762 :       out__.write_free_lub(lower_y, upper_y, delta_y);
 763 :     } catch (const std::exception& e) {
 764 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 765 :     }
 766 :   }
 767 :   inline void
 768 :   get_param_names(std::vector<std::string>& names__, const bool
 769 :                   emit_transformed_parameters__ = true, const bool
 770 :                   emit_generated_quantities__ = true) const {
 771 :     names__ = std::vector<std::string>{"rho", "alpha", "sigma", "phi",
 772 :                 "theta", "eps", "delta_x", "delta_y"};
 773 :     if (emit_transformed_parameters__) {}
 774 :     if (emit_generated_quantities__) {
 775 :       std::vector<std::string> temp{"sibspercol"};
 776 :       names__.reserve(names__.size() + temp.size());
 777 :       names__.insert(names__.end(), temp.begin(), temp.end());
 778 :     }
 779 :   }
 780 :   inline void
 781 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 782 :            emit_transformed_parameters__ = true, const bool
 783 :            emit_generated_quantities__ = true) const {
 784 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 785 :                 std::vector<size_t>{}, std::vector<size_t>{},
 786 :                 std::vector<size_t>{}, std::vector<size_t>{},
 787 :                 std::vector<size_t>{static_cast<size_t>(K)},
 788 :                 std::vector<size_t>{static_cast<size_t>(C)},
 789 :                 std::vector<size_t>{static_cast<size_t>(C)}};
 790 :     if (emit_transformed_parameters__) {}
 791 :     if (emit_generated_quantities__) {
 792 :       std::vector<std::vector<size_t>>
 793 :         temp{std::vector<size_t>{static_cast<size_t>(C)}};
 794 :       dimss__.reserve(dimss__.size() + temp.size());
 795 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 796 :     }
 797 :   }
 798 :   inline void
 799 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 800 :                           emit_transformed_parameters__ = true, bool
 801 :                           emit_generated_quantities__ = true) const final {
 802 :     param_names__.emplace_back(std::string() + "rho");
 803 :     param_names__.emplace_back(std::string() + "alpha");
 804 :     param_names__.emplace_back(std::string() + "sigma");
 805 :     param_names__.emplace_back(std::string() + "phi");
 806 :     param_names__.emplace_back(std::string() + "theta");
 807 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 808 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 809 :         std::to_string(sym1__));
 810 :     }
 811 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 812 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 813 :         std::to_string(sym1__));
 814 :     }
 815 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 816 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 817 :         std::to_string(sym1__));
 818 :     }
 819 :     if (emit_transformed_parameters__) {}
 820 :     if (emit_generated_quantities__) {
 821 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 822 :         param_names__.emplace_back(std::string() + "sibspercol" + '.' +
 823 :           std::to_string(sym1__));
 824 :       }
 825 :     }
 826 :   }
 827 :   inline void
 828 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 829 :                             emit_transformed_parameters__ = true, bool
 830 :                             emit_generated_quantities__ = true) const final {
 831 :     param_names__.emplace_back(std::string() + "rho");
 832 :     param_names__.emplace_back(std::string() + "alpha");
 833 :     param_names__.emplace_back(std::string() + "sigma");
 834 :     param_names__.emplace_back(std::string() + "phi");
 835 :     param_names__.emplace_back(std::string() + "theta");
 836 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 837 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 838 :         std::to_string(sym1__));
 839 :     }
 840 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 841 :       param_names__.emplace_back(std::string() + "delta_x" + '.' +
 842 :         std::to_string(sym1__));
 843 :     }
 844 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 845 :       param_names__.emplace_back(std::string() + "delta_y" + '.' +
 846 :         std::to_string(sym1__));
 847 :     }
 848 :     if (emit_transformed_parameters__) {}
 849 :     if (emit_generated_quantities__) {
 850 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 851 :         param_names__.emplace_back(std::string() + "sibspercol" + '.' +
 852 :           std::to_string(sym1__));
 853 :       }
 854 :     }
 855 :   }
 856 :   inline std::string get_constrained_sizedtypes() const {
 857 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sibspercol\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
 858 :   }
 859 :   inline std::string get_unconstrained_sizedtypes() const {
 860 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"phi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"delta_x\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"delta_y\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"sibspercol\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
 861 :   }
 862 :   // Begin method overload boilerplate
 863 :   template <typename RNG> inline void
 864 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 865 :               Eigen::Matrix<double,-1,1>& vars, const bool
 866 :               emit_transformed_parameters = true, const bool
 867 :               emit_generated_quantities = true, std::ostream*
 868 :               pstream = nullptr) const {
 869 :     const size_t num_params__ = (((((((1 + 1) + 1) + 1) + 1) + K) + C) + C);
 870 :     const size_t num_transformed = emit_transformed_parameters * (0);
 871 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
 872 :     const size_t num_to_write = num_params__ + num_transformed +
 873 :       num_gen_quantities;
 874 :     std::vector<int> params_i;
 875 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 876 :              std::numeric_limits<double>::quiet_NaN());
 877 :     write_array_impl(base_rng, params_r, params_i, vars,
 878 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 879 :   }
 880 :   template <typename RNG> inline void
 881 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 882 :               params_i, std::vector<double>& vars, bool
 883 :               emit_transformed_parameters = true, bool
 884 :               emit_generated_quantities = true, std::ostream*
 885 :               pstream = nullptr) const {
 886 :     const size_t num_params__ = (((((((1 + 1) + 1) + 1) + 1) + K) + C) + C);
 887 :     const size_t num_transformed = emit_transformed_parameters * (0);
 888 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
 889 :     const size_t num_to_write = num_params__ + num_transformed +
 890 :       num_gen_quantities;
 891 :     vars = std::vector<double>(num_to_write,
 892 :              std::numeric_limits<double>::quiet_NaN());
 893 :     write_array_impl(base_rng, params_r, params_i, vars,
 894 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 895 :   }
 896 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 897 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 898 :     Eigen::Matrix<int,-1,1> params_i;
 899 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 900 :   }
 901 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 902 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 903 :            std::ostream* pstream = nullptr) const {
 904 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 905 :   }
 906 :   inline void
 907 :   transform_inits(const stan::io::var_context& context,
 908 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 909 :                   pstream = nullptr) const final {
 910 :     std::vector<double> params_r_vec(params_r.size());
 911 :     std::vector<int> params_i;
 912 :     transform_inits(context, params_i, params_r_vec, pstream);
 913 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 914 :                  params_r_vec.size());
 915 :   }
 916 :   inline void
 917 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 918 :                   params_i, std::vector<double>& vars, std::ostream*
 919 :                   pstream__ = nullptr) const {
 920 :     vars.resize(num_params_r__);
 921 :     transform_inits_impl(context, vars, pstream__);
 922 :   }
 923 :   inline void
 924 :   unconstrain_array(const std::vector<double>& params_constrained,
 925 :                     std::vector<double>& params_unconstrained, std::ostream*
 926 :                     pstream = nullptr) const {
 927 :     const std::vector<int> params_i;
 928 :     params_unconstrained = std::vector<double>(num_params_r__,
 929 :                              std::numeric_limits<double>::quiet_NaN());
 930 :     unconstrain_array_impl(params_constrained, params_i,
 931 :       params_unconstrained, pstream);
 932 :   }
 933 :   inline void
 934 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 935 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
 936 :                     std::ostream* pstream = nullptr) const {
 937 :     const std::vector<int> params_i;
 938 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
 939 :                              std::numeric_limits<double>::quiet_NaN());
 940 :     unconstrain_array_impl(params_constrained, params_i,
 941 :       params_unconstrained, pstream);
 942 :   }
 943 : };
 944 : }
 945 : using stan_model = model31a47c1700fbaa__namespace::model31a47c1700fbaa_;
 946 : #ifndef USING_R
 947 : // Boilerplate
 948 : stan::model::model_base&
 949 : new_model(stan::io::var_context& data_context, unsigned int seed,
 950 :           std::ostream* msg_stream) {
 951 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
 952 :   return *m;
 953 : }
 954 : stan::math::profile_map& get_stan_profile_data() {
 955 :   return model31a47c1700fbaa__namespace::profiles__;
 956 : }
 957 : #endif
 958 : #endif
 959 : 
 960 : RCPP_MODULE(stan_fit4model31a47c1700fbaa__mod) {
 961 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
 962 :       "stan_fit4model31a47c1700fbaa_")
 963 : 
 964 :       .constructor<SEXP, SEXP, SEXP>()
 965 : 
 966 :       .method(
 967 :           "call_sampler",
 968 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
 969 :       .method(
 970 :           "param_names",
 971 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
 972 :       .method("param_names_oi",
 973 :               &rstan::stan_fit<stan_model,
 974 :                                boost::random::ecuyer1988>::param_names_oi)
 975 :       .method("param_fnames_oi",
 976 :               &rstan::stan_fit<stan_model,
 977 :                                boost::random::ecuyer1988>::param_fnames_oi)
 978 :       .method(
 979 :           "param_dims",
 980 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
 981 :       .method("param_dims_oi",
 982 :               &rstan::stan_fit<stan_model,
 983 :                                boost::random::ecuyer1988>::param_dims_oi)
 984 :       .method("update_param_oi",
 985 :               &rstan::stan_fit<stan_model,
 986 :                                boost::random::ecuyer1988>::update_param_oi)
 987 :       .method("param_oi_tidx",
 988 :               &rstan::stan_fit<stan_model,
 989 :                                boost::random::ecuyer1988>::param_oi_tidx)
 990 :       .method("grad_log_prob",
 991 :               &rstan::stan_fit<stan_model,
 992 :                                boost::random::ecuyer1988>::grad_log_prob)
 993 :       .method("log_prob",
 994 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
 995 :       .method("unconstrain_pars",
 996 :               &rstan::stan_fit<stan_model,
 997 :                                boost::random::ecuyer1988>::unconstrain_pars)
 998 :       .method("constrain_pars",
 999 :               &rstan::stan_fit<stan_model,
1000 :                                boost::random::ecuyer1988>::constrain_pars)
1001 :       .method(
1002 :           "num_pars_unconstrained",
1003 :           &rstan::stan_fit<stan_model,
1004 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
1005 :       .method(
1006 :           "unconstrained_param_names",
1007 :           &rstan::stan_fit<
1008 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
1009 :       .method(
1010 :           "constrained_param_names",
1011 :           &rstan::stan_fit<stan_model,
1012 :                            boost::random::ecuyer1988>::constrained_param_names)
1013 :       .method("standalone_gqs",
1014 :               &rstan::stan_fit<stan_model,
1015 :                                boost::random::ecuyer1988>::standalone_gqs);
1016 : }
1017 : 
1018 : 
1019 : // declarations
1020 : extern "C" {
1021 : SEXP file31a47c726d93af( ) ;
1022 : }
1023 : 
1024 : // definition
1025 : SEXP file31a47c726d93af() {
1026 :  return Rcpp::wrap("anon_model");
1027 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file31a47c726d93af.so' OBJECTS='file31a47c726d93af.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file31a47c726d93af.cpp -o file31a47c726d93af.o
if test  "zfile31a47c726d93af.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file31a47c726d93af.so file31a47c726d93af.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file31a47c726d93af.so file31a47c726d93af.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi
