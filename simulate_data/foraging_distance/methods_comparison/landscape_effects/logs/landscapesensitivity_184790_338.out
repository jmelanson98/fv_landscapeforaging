[1] "Loading landscape metric raster."

TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace model3af32e1f06c7ae__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 87> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 20, column 0 to column 18)",
  25 :   " (in 'anon_model', line 21, column 0 to column 20)",
  26 :   " (in 'anon_model', line 22, column 0 to column 18)",
  27 :   " (in 'anon_model', line 23, column 0 to column 11)",
  28 :   " (in 'anon_model', line 24, column 0 to column 11)",
  29 :   " (in 'anon_model', line 25, column 0 to column 8)",
  30 :   " (in 'anon_model', line 26, column 0 to column 14)",
  31 :   " (in 'anon_model', line 27, column 0 to column 15)",
  32 :   " (in 'anon_model', line 28, column 0 to column 62)",
  33 :   " (in 'anon_model', line 31, column 2 to column 37)",
  34 :   " (in 'anon_model', line 32, column 2 to column 41)",
  35 :   " (in 'anon_model', line 33, column 2 to column 41)",
  36 :   " (in 'anon_model', line 34, column 2 to column 39)",
  37 :   " (in 'anon_model', line 73, column 2 to column 24)",
  38 :   " (in 'anon_model', line 74, column 2 to column 33)",
  39 :   " (in 'anon_model', line 78, column 11 to column 12)",
  40 :   " (in 'anon_model', line 78, column 13 to column 14)",
  41 :   " (in 'anon_model', line 78, column 4 to column 20)",
  42 :   " (in 'anon_model', line 79, column 11 to column 12)",
  43 :   " (in 'anon_model', line 79, column 13 to column 14)",
  44 :   " (in 'anon_model', line 79, column 4 to column 23)",
  45 :   " (in 'anon_model', line 80, column 11 to column 12)",
  46 :   " (in 'anon_model', line 80, column 4 to column 16)",
  47 :   " (in 'anon_model', line 81, column 4 to column 24)",
  48 :   " (in 'anon_model', line 86, column 8 to column 92)",
  49 :   " (in 'anon_model', line 87, column 8 to column 117)",
  50 :   " (in 'anon_model', line 85, column 19 to line 88, column 7)",
  51 :   " (in 'anon_model', line 85, column 6 to line 88, column 7)",
  52 :   " (in 'anon_model', line 84, column 17 to line 89, column 5)",
  53 :   " (in 'anon_model', line 84, column 4 to line 89, column 5)",
  54 :   " (in 'anon_model', line 93, column 6 to column 34)",
  55 :   " (in 'anon_model', line 92, column 18 to line 94, column 5)",
  56 :   " (in 'anon_model', line 92, column 4 to line 94, column 5)",
  57 :   " (in 'anon_model', line 99, column 6 to column 79)",
  58 :   " (in 'anon_model', line 98, column 18 to line 100, column 5)",
  59 :   " (in 'anon_model', line 98, column 4 to line 100, column 5)",
  60 :   " (in 'anon_model', line 77, column 2 to line 101, column 3)",
  61 :   " (in 'anon_model', line 41, column 7 to column 8)",
  62 :   " (in 'anon_model', line 41, column 9 to column 10)",
  63 :   " (in 'anon_model', line 41, column 0 to column 16)",
  64 :   " (in 'anon_model', line 42, column 7 to column 8)",
  65 :   " (in 'anon_model', line 42, column 9 to column 10)",
  66 :   " (in 'anon_model', line 42, column 0 to column 19)",
  67 :   " (in 'anon_model', line 43, column 7 to column 8)",
  68 :   " (in 'anon_model', line 43, column 0 to column 22)",
  69 :   " (in 'anon_model', line 45, column 0 to column 27)",
  70 :   " (in 'anon_model', line 46, column 0 to column 25)",
  71 :   " (in 'anon_model', line 47, column 0 to column 36)",
  72 :   " (in 'anon_model', line 48, column 0 to column 24)",
  73 :   " (in 'anon_model', line 49, column 0 to column 27)",
  74 :   " (in 'anon_model', line 50, column 0 to column 27)",
  75 :   " (in 'anon_model', line 52, column 0 to column 19)",
  76 :   " (in 'anon_model', line 53, column 0 to column 20)",
  77 :   " (in 'anon_model', line 57, column 6 to column 40)",
  78 :   " (in 'anon_model', line 62, column 8 to column 92)",
  79 :   " (in 'anon_model', line 63, column 8 to column 117)",
  80 :   " (in 'anon_model', line 59, column 19 to line 64, column 7)",
  81 :   " (in 'anon_model', line 59, column 6 to line 64, column 7)",
  82 :   " (in 'anon_model', line 66, column 4 to column 39)",
  83 :   " (in 'anon_model', line 69, column 4 to column 37)",
  84 :   " (in 'anon_model', line 54, column 17 to line 70, column 5)",
  85 :   " (in 'anon_model', line 54, column 4 to line 70, column 5)",
  86 :   " (in 'anon_model', line 5, column 0 to column 15)",
  87 :   " (in 'anon_model', line 6, column 0 to column 15)",
  88 :   " (in 'anon_model', line 7, column 7 to column 8)",
  89 :   " (in 'anon_model', line 7, column 0 to column 18)",
  90 :   " (in 'anon_model', line 8, column 6 to column 7)",
  91 :   " (in 'anon_model', line 8, column 9 to column 10)",
  92 :   " (in 'anon_model', line 8, column 0 to column 12)",
  93 :   " (in 'anon_model', line 9, column 0 to column 16)",
  94 :   " (in 'anon_model', line 10, column 0 to column 16)",
  95 :   " (in 'anon_model', line 11, column 7 to column 8)",
  96 :   " (in 'anon_model', line 11, column 0 to column 17)",
  97 :   " (in 'anon_model', line 12, column 7 to column 8)",
  98 :   " (in 'anon_model', line 12, column 0 to column 20)",
  99 :   " (in 'anon_model', line 13, column 0 to column 15)",
 100 :   " (in 'anon_model', line 14, column 0 to column 25)",
 101 :   " (in 'anon_model', line 15, column 0 to column 21)",
 102 :   " (in 'anon_model', line 16, column 0 to column 22)",
 103 :   " (in 'anon_model', line 17, column 0 to column 22)",
 104 :   " (in 'anon_model', line 26, column 7 to column 8)",
 105 :   " (in 'anon_model', line 27, column 7 to column 8)",
 106 :   " (in 'anon_model', line 28, column 7 to column 8)",
 107 :   " (in 'anon_model', line 33, column 9 to column 10)",
 108 :   " (in 'anon_model', line 34, column 9 to column 10)",
 109 :   " (in 'anon_model', line 73, column 9 to column 10)"};
 110 : class model3af32e1f06c7ae_ final : public model_base_crtp<model3af32e1f06c7ae_> {
 111 : private:
 112 :   int C;
 113 :   int K;
 114 :   Eigen::Matrix<double,-1,-1> trap_data__;
 115 :   std::vector<std::vector<int>> y;
 116 :   double lowerbound;
 117 :   double upperbound;
 118 :   Eigen::Matrix<double,-1,1> floral_data__;
 119 :   Eigen::Matrix<double,-1,1> landscape_data__;
 120 :   double nestrange;
 121 :   double rho_center;
 122 :   double rho_sd;
 123 :   double priorVa;
 124 :   double priorCo;
 125 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap{nullptr, 0, 0};
 126 :   Eigen::Map<Eigen::Matrix<double,-1,1>> floral{nullptr, 0};
 127 :   Eigen::Map<Eigen::Matrix<double,-1,1>> landscape{nullptr, 0};
 128 : public:
 129 :   ~model3af32e1f06c7ae_() {}
 130 :   model3af32e1f06c7ae_(stan::io::var_context& context__, unsigned int
 131 :                        random_seed__ = 0, std::ostream* pstream__ = nullptr)
 132 :       : model_base_crtp(0) {
 133 :     int current_statement__ = 0;
 134 :     using local_scalar_t__ = double;
 135 :     boost::ecuyer1988 base_rng__ =
 136 :       stan::services::util::create_rng(random_seed__, 0);
 137 :     // suppress unused var warning
 138 :     (void) base_rng__;
 139 :     static constexpr const char* function__ =
 140 :       "model3af32e1f06c7ae__namespace::model3af32e1f06c7ae_";
 141 :     // suppress unused var warning
 142 :     (void) function__;
 143 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 144 :     // suppress unused var warning
 145 :     (void) DUMMY_VAR__;
 146 :     try {
 147 :       int pos__ = std::numeric_limits<int>::min();
 148 :       pos__ = 1;
 149 :       current_statement__ = 63;
 150 :       context__.validate_dims("data initialization", "C", "int",
 151 :         std::vector<size_t>{});
 152 :       C = std::numeric_limits<int>::min();
 153 :       current_statement__ = 63;
 154 :       C = context__.vals_i("C")[(1 - 1)];
 155 :       current_statement__ = 63;
 156 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 157 :       current_statement__ = 64;
 158 :       context__.validate_dims("data initialization", "K", "int",
 159 :         std::vector<size_t>{});
 160 :       K = std::numeric_limits<int>::min();
 161 :       current_statement__ = 64;
 162 :       K = context__.vals_i("K")[(1 - 1)];
 163 :       current_statement__ = 64;
 164 :       stan::math::check_greater_or_equal(function__, "K", K, 1);
 165 :       current_statement__ = 65;
 166 :       stan::math::validate_non_negative_index("trap", "K", K);
 167 :       current_statement__ = 66;
 168 :       context__.validate_dims("data initialization", "trap", "double",
 169 :         std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(2)});
 170 :       trap_data__ = Eigen::Matrix<double,-1,-1>::Constant(K, 2,
 171 :                       std::numeric_limits<double>::quiet_NaN());
 172 :       new (&trap) Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_data__.data(),
 173 :         K, 2);
 174 :       {
 175 :         std::vector<local_scalar_t__> trap_flat__;
 176 :         current_statement__ = 66;
 177 :         trap_flat__ = context__.vals_r("trap");
 178 :         current_statement__ = 66;
 179 :         pos__ = 1;
 180 :         current_statement__ = 66;
 181 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 182 :           current_statement__ = 66;
 183 :           for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
 184 :             current_statement__ = 66;
 185 :             stan::model::assign(trap, trap_flat__[(pos__ - 1)],
 186 :               "assigning variable trap", stan::model::index_uni(sym2__),
 187 :               stan::model::index_uni(sym1__));
 188 :             current_statement__ = 66;
 189 :             pos__ = (pos__ + 1);
 190 :           }
 191 :         }
 192 :       }
 193 :       current_statement__ = 67;
 194 :       stan::math::validate_non_negative_index("y", "C", C);
 195 :       current_statement__ = 68;
 196 :       stan::math::validate_non_negative_index("y", "K", K);
 197 :       current_statement__ = 69;
 198 :       context__.validate_dims("data initialization", "y", "int",
 199 :         std::vector<size_t>{static_cast<size_t>(C), static_cast<size_t>(K)});
 200 :       y = std::vector<std::vector<int>>(C,
 201 :             std::vector<int>(K, std::numeric_limits<int>::min()));
 202 :       {
 203 :         std::vector<int> y_flat__;
 204 :         current_statement__ = 69;
 205 :         y_flat__ = context__.vals_i("y");
 206 :         current_statement__ = 69;
 207 :         pos__ = 1;
 208 :         current_statement__ = 69;
 209 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 210 :           current_statement__ = 69;
 211 :           for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 212 :             current_statement__ = 69;
 213 :             stan::model::assign(y, y_flat__[(pos__ - 1)],
 214 :               "assigning variable y", stan::model::index_uni(sym2__),
 215 :               stan::model::index_uni(sym1__));
 216 :             current_statement__ = 69;
 217 :             pos__ = (pos__ + 1);
 218 :           }
 219 :         }
 220 :       }
 221 :       current_statement__ = 70;
 222 :       context__.validate_dims("data initialization", "lowerbound", "double",
 223 :         std::vector<size_t>{});
 224 :       lowerbound = std::numeric_limits<double>::quiet_NaN();
 225 :       current_statement__ = 70;
 226 :       lowerbound = context__.vals_r("lowerbound")[(1 - 1)];
 227 :       current_statement__ = 71;
 228 :       context__.validate_dims("data initialization", "upperbound", "double",
 229 :         std::vector<size_t>{});
 230 :       upperbound = std::numeric_limits<double>::quiet_NaN();
 231 :       current_statement__ = 71;
 232 :       upperbound = context__.vals_r("upperbound")[(1 - 1)];
 233 :       current_statement__ = 72;
 234 :       stan::math::validate_non_negative_index("floral", "K", K);
 235 :       current_statement__ = 73;
 236 :       context__.validate_dims("data initialization", "floral", "double",
 237 :         std::vector<size_t>{static_cast<size_t>(K)});
 238 :       floral_data__ = Eigen::Matrix<double,-1,1>::Constant(K,
 239 :                         std::numeric_limits<double>::quiet_NaN());
 240 :       new (&floral)
 241 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(floral_data__.data(), K);
 242 :       {
 243 :         std::vector<local_scalar_t__> floral_flat__;
 244 :         current_statement__ = 73;
 245 :         floral_flat__ = context__.vals_r("floral");
 246 :         current_statement__ = 73;
 247 :         pos__ = 1;
 248 :         current_statement__ = 73;
 249 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 250 :           current_statement__ = 73;
 251 :           stan::model::assign(floral, floral_flat__[(pos__ - 1)],
 252 :             "assigning variable floral", stan::model::index_uni(sym1__));
 253 :           current_statement__ = 73;
 254 :           pos__ = (pos__ + 1);
 255 :         }
 256 :       }
 257 :       current_statement__ = 74;
 258 :       stan::math::validate_non_negative_index("landscape", "K", K);
 259 :       current_statement__ = 75;
 260 :       context__.validate_dims("data initialization", "landscape", "double",
 261 :         std::vector<size_t>{static_cast<size_t>(K)});
 262 :       landscape_data__ = Eigen::Matrix<double,-1,1>::Constant(K,
 263 :                            std::numeric_limits<double>::quiet_NaN());
 264 :       new (&landscape)
 265 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(landscape_data__.data(), K);
 266 :       {
 267 :         std::vector<local_scalar_t__> landscape_flat__;
 268 :         current_statement__ = 75;
 269 :         landscape_flat__ = context__.vals_r("landscape");
 270 :         current_statement__ = 75;
 271 :         pos__ = 1;
 272 :         current_statement__ = 75;
 273 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 274 :           current_statement__ = 75;
 275 :           stan::model::assign(landscape, landscape_flat__[(pos__ - 1)],
 276 :             "assigning variable landscape", stan::model::index_uni(sym1__));
 277 :           current_statement__ = 75;
 278 :           pos__ = (pos__ + 1);
 279 :         }
 280 :       }
 281 :       current_statement__ = 76;
 282 :       context__.validate_dims("data initialization", "nestrange", "double",
 283 :         std::vector<size_t>{});
 284 :       nestrange = std::numeric_limits<double>::quiet_NaN();
 285 :       current_statement__ = 76;
 286 :       nestrange = context__.vals_r("nestrange")[(1 - 1)];
 287 :       current_statement__ = 77;
 288 :       context__.validate_dims("data initialization", "rho_center", "double",
 289 :         std::vector<size_t>{});
 290 :       rho_center = std::numeric_limits<double>::quiet_NaN();
 291 :       current_statement__ = 77;
 292 :       rho_center = context__.vals_r("rho_center")[(1 - 1)];
 293 :       current_statement__ = 77;
 294 :       stan::math::check_greater_or_equal(function__, "rho_center",
 295 :         rho_center, 0);
 296 :       current_statement__ = 78;
 297 :       context__.validate_dims("data initialization", "rho_sd", "double",
 298 :         std::vector<size_t>{});
 299 :       rho_sd = std::numeric_limits<double>::quiet_NaN();
 300 :       current_statement__ = 78;
 301 :       rho_sd = context__.vals_r("rho_sd")[(1 - 1)];
 302 :       current_statement__ = 78;
 303 :       stan::math::check_greater_or_equal(function__, "rho_sd", rho_sd, 0);
 304 :       current_statement__ = 79;
 305 :       context__.validate_dims("data initialization", "priorVa", "double",
 306 :         std::vector<size_t>{});
 307 :       priorVa = std::numeric_limits<double>::quiet_NaN();
 308 :       current_statement__ = 79;
 309 :       priorVa = context__.vals_r("priorVa")[(1 - 1)];
 310 :       current_statement__ = 79;
 311 :       stan::math::check_greater_or_equal(function__, "priorVa", priorVa, 0);
 312 :       current_statement__ = 80;
 313 :       context__.validate_dims("data initialization", "priorCo", "double",
 314 :         std::vector<size_t>{});
 315 :       priorCo = std::numeric_limits<double>::quiet_NaN();
 316 :       current_statement__ = 80;
 317 :       priorCo = context__.vals_r("priorCo")[(1 - 1)];
 318 :       current_statement__ = 80;
 319 :       stan::math::check_greater_or_equal(function__, "priorCo", priorCo, 0);
 320 :       current_statement__ = 81;
 321 :       stan::math::validate_non_negative_index("eps", "K", K);
 322 :       current_statement__ = 82;
 323 :       stan::math::validate_non_negative_index("zeta", "C", C);
 324 :       current_statement__ = 83;
 325 :       stan::math::validate_non_negative_index("delta", "C", C);
 326 :       current_statement__ = 84;
 327 :       stan::math::validate_non_negative_index("zeta_scale", "C", C);
 328 :       current_statement__ = 85;
 329 :       stan::math::validate_non_negative_index("eps_scale", "K", K);
 330 :       current_statement__ = 86;
 331 :       stan::math::validate_non_negative_index("colony_dist", "C", C);
 332 :     } catch (const std::exception& e) {
 333 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 334 :     }
 335 :     num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + K + C + (C * 2);
 336 :   }
 337 :   inline std::string model_name() const final {
 338 :     return "model3af32e1f06c7ae_";
 339 :   }
 340 :   inline std::vector<std::string> model_compile_info() const noexcept {
 341 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 342 :              "stancflags = --"};
 343 :   }
 344 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 345 :             stan::require_vector_like_t<VecR>* = nullptr,
 346 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 347 :   inline stan::scalar_type_t<VecR>
 348 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 349 :                 pstream__ = nullptr) const {
 350 :     using T__ = stan::scalar_type_t<VecR>;
 351 :     using local_scalar_t__ = T__;
 352 :     T__ lp__(0.0);
 353 :     stan::math::accumulator<T__> lp_accum__;
 354 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 355 :     int current_statement__ = 0;
 356 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 357 :     // suppress unused var warning
 358 :     (void) DUMMY_VAR__;
 359 :     static constexpr const char* function__ =
 360 :       "model3af32e1f06c7ae__namespace::log_prob";
 361 :     // suppress unused var warning
 362 :     (void) function__;
 363 :     try {
 364 :       local_scalar_t__ rho = DUMMY_VAR__;
 365 :       current_statement__ = 1;
 366 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 367 :               lp__);
 368 :       local_scalar_t__ sigma = DUMMY_VAR__;
 369 :       current_statement__ = 2;
 370 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 371 :                 jacobian__>(0, lp__);
 372 :       local_scalar_t__ tau = DUMMY_VAR__;
 373 :       current_statement__ = 3;
 374 :       tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 375 :               lp__);
 376 :       local_scalar_t__ alpha = DUMMY_VAR__;
 377 :       current_statement__ = 4;
 378 :       alpha = in__.template read<local_scalar_t__>();
 379 :       local_scalar_t__ theta = DUMMY_VAR__;
 380 :       current_statement__ = 5;
 381 :       theta = in__.template read<local_scalar_t__>();
 382 :       local_scalar_t__ mu = DUMMY_VAR__;
 383 :       current_statement__ = 6;
 384 :       mu = in__.template read<local_scalar_t__>();
 385 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 386 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 387 :       current_statement__ = 7;
 388 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 389 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 390 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 391 :       current_statement__ = 8;
 392 :       zeta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(C);
 393 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 394 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 395 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 396 :       current_statement__ = 9;
 397 :       delta = in__.template read_constrain_lub<
 398 :                 std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
 399 :                 jacobian__>(lowerbound, upperbound, lp__, C, 2);
 400 :       local_scalar_t__ tau_sqrt = DUMMY_VAR__;
 401 :       current_statement__ = 10;
 402 :       tau_sqrt = stan::math::sqrt(tau);
 403 :       local_scalar_t__ sigma_sqrt = DUMMY_VAR__;
 404 :       current_statement__ = 11;
 405 :       sigma_sqrt = stan::math::sqrt(sigma);
 406 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta_scale =
 407 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 408 :       current_statement__ = 12;
 409 :       stan::model::assign(zeta_scale, stan::math::multiply(zeta, tau_sqrt),
 410 :         "assigning variable zeta_scale");
 411 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 412 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 413 :       current_statement__ = 13;
 414 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 415 :         "assigning variable eps_scale");
 416 :       current_statement__ = 10;
 417 :       stan::math::check_greater_or_equal(function__, "tau_sqrt", tau_sqrt, 0);
 418 :       current_statement__ = 11;
 419 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 420 :         sigma_sqrt, 0);
 421 :       {
 422 :         current_statement__ = 38;
 423 :         stan::math::validate_non_negative_index("dis", "C", C);
 424 :         current_statement__ = 39;
 425 :         stan::math::validate_non_negative_index("dis", "K", K);
 426 :         Eigen::Matrix<local_scalar_t__,-1,-1> dis =
 427 :           Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(C, K, DUMMY_VAR__);
 428 :         current_statement__ = 41;
 429 :         stan::math::validate_non_negative_index("lambda", "C", C);
 430 :         current_statement__ = 42;
 431 :         stan::math::validate_non_negative_index("lambda", "K", K);
 432 :         Eigen::Matrix<local_scalar_t__,-1,-1> lambda =
 433 :           Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(C, K, DUMMY_VAR__);
 434 :         current_statement__ = 44;
 435 :         stan::math::validate_non_negative_index("multi_probs", "K", K);
 436 :         Eigen::Matrix<local_scalar_t__,-1,1> multi_probs =
 437 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 438 :         current_statement__ = 46;
 439 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, priorVa));
 440 :         current_statement__ = 47;
 441 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, priorVa));
 442 :         current_statement__ = 48;
 443 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho, rho_center,
 444 :                          rho_sd));
 445 :         current_statement__ = 49;
 446 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, priorCo));
 447 :         current_statement__ = 50;
 448 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, 0, priorCo));
 449 :         current_statement__ = 51;
 450 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(alpha, 0, priorCo));
 451 :         current_statement__ = 52;
 452 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 453 :         current_statement__ = 53;
 454 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(zeta, 0, 1));
 455 :         current_statement__ = 62;
 456 :         for (int i = 1; i <= C; ++i) {
 457 :           current_statement__ = 54;
 458 :           lp_accum__.add(stan::math::normal_lpdf<propto__>(
 459 :                            stan::model::rvalue(delta, "delta",
 460 :                              stan::model::index_uni(i)), 750, nestrange));
 461 :           current_statement__ = 58;
 462 :           for (int k = 1; k <= K; ++k) {
 463 :             current_statement__ = 55;
 464 :             stan::model::assign(dis,
 465 :               stan::math::sqrt(
 466 :                 (stan::math::square(
 467 :                    (stan::model::rvalue(delta, "delta",
 468 :                       stan::model::index_uni(i), stan::model::index_uni(1)) -
 469 :                    stan::model::rvalue(trap, "trap",
 470 :                      stan::model::index_uni(k), stan::model::index_uni(1))))
 471 :                 +
 472 :                 stan::math::square(
 473 :                   (stan::model::rvalue(delta, "delta",
 474 :                      stan::model::index_uni(i), stan::model::index_uni(2)) -
 475 :                   stan::model::rvalue(trap, "trap",
 476 :                     stan::model::index_uni(k), stan::model::index_uni(2)))))),
 477 :               "assigning variable dis", stan::model::index_uni(i),
 478 :               stan::model::index_uni(k));
 479 :             current_statement__ = 56;
 480 :             stan::model::assign(lambda,
 481 :               (((((stan::model::rvalue(dis, "dis", stan::model::index_uni(i),
 482 :                      stan::model::index_uni(k)) / (-rho *
 483 :               stan::math::exp((alpha *
 484 :                 stan::model::rvalue(landscape, "landscape",
 485 :                   stan::model::index_uni(k)))))) + (theta *
 486 :               stan::model::rvalue(floral, "floral", stan::model::index_uni(k))))
 487 :               + mu) +
 488 :               stan::model::rvalue(zeta_scale, "zeta_scale",
 489 :                 stan::model::index_uni(i))) +
 490 :               stan::model::rvalue(eps_scale, "eps_scale",
 491 :                 stan::model::index_uni(k))), "assigning variable lambda",
 492 :               stan::model::index_uni(i), stan::model::index_uni(k));
 493 :           }
 494 :           current_statement__ = 59;
 495 :           stan::model::assign(multi_probs,
 496 :             stan::math::softmax(
 497 :               stan::math::transpose(
 498 :                 stan::model::rvalue(lambda, "lambda",
 499 :                   stan::model::index_uni(i), stan::model::index_omni()))),
 500 :             "assigning variable multi_probs");
 501 :           current_statement__ = 60;
 502 :           lp_accum__.add(stan::math::multinomial_lpmf<propto__>(
 503 :                            stan::model::rvalue(y, "y",
 504 :                              stan::model::index_uni(i),
 505 :                              stan::model::index_omni()), multi_probs));
 506 :         }
 507 :       }
 508 :     } catch (const std::exception& e) {
 509 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 510 :     }
 511 :     lp_accum__.add(lp__);
 512 :     return lp_accum__.sum();
 513 :   }
 514 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 515 :             stan::require_vector_like_vt<std::is_floating_point,
 516 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 517 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 518 :             VecVar>* = nullptr>
 519 :   inline void
 520 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 521 :                    VecVar& vars__, const bool
 522 :                    emit_transformed_parameters__ = true, const bool
 523 :                    emit_generated_quantities__ = true, std::ostream*
 524 :                    pstream__ = nullptr) const {
 525 :     using local_scalar_t__ = double;
 526 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 527 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 528 :     static constexpr bool propto__ = true;
 529 :     // suppress unused var warning
 530 :     (void) propto__;
 531 :     double lp__ = 0.0;
 532 :     // suppress unused var warning
 533 :     (void) lp__;
 534 :     int current_statement__ = 0;
 535 :     stan::math::accumulator<double> lp_accum__;
 536 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 537 :     // suppress unused var warning
 538 :     (void) DUMMY_VAR__;
 539 :     constexpr bool jacobian__ = false;
 540 :     static constexpr const char* function__ =
 541 :       "model3af32e1f06c7ae__namespace::write_array";
 542 :     // suppress unused var warning
 543 :     (void) function__;
 544 :     try {
 545 :       double rho = std::numeric_limits<double>::quiet_NaN();
 546 :       current_statement__ = 1;
 547 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 548 :               lp__);
 549 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 550 :       current_statement__ = 2;
 551 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 552 :                 jacobian__>(0, lp__);
 553 :       double tau = std::numeric_limits<double>::quiet_NaN();
 554 :       current_statement__ = 3;
 555 :       tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 556 :               lp__);
 557 :       double alpha = std::numeric_limits<double>::quiet_NaN();
 558 :       current_statement__ = 4;
 559 :       alpha = in__.template read<local_scalar_t__>();
 560 :       double theta = std::numeric_limits<double>::quiet_NaN();
 561 :       current_statement__ = 5;
 562 :       theta = in__.template read<local_scalar_t__>();
 563 :       double mu = std::numeric_limits<double>::quiet_NaN();
 564 :       current_statement__ = 6;
 565 :       mu = in__.template read<local_scalar_t__>();
 566 :       Eigen::Matrix<double,-1,1> eps =
 567 :         Eigen::Matrix<double,-1,1>::Constant(K,
 568 :           std::numeric_limits<double>::quiet_NaN());
 569 :       current_statement__ = 7;
 570 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 571 :       Eigen::Matrix<double,-1,1> zeta =
 572 :         Eigen::Matrix<double,-1,1>::Constant(C,
 573 :           std::numeric_limits<double>::quiet_NaN());
 574 :       current_statement__ = 8;
 575 :       zeta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(C);
 576 :       std::vector<Eigen::Matrix<double,-1,1>> delta =
 577 :         std::vector<Eigen::Matrix<double,-1,1>>(C,
 578 :           Eigen::Matrix<double,-1,1>::Constant(2,
 579 :             std::numeric_limits<double>::quiet_NaN()));
 580 :       current_statement__ = 9;
 581 :       delta = in__.template read_constrain_lub<
 582 :                 std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
 583 :                 jacobian__>(lowerbound, upperbound, lp__, C, 2);
 584 :       double tau_sqrt = std::numeric_limits<double>::quiet_NaN();
 585 :       double sigma_sqrt = std::numeric_limits<double>::quiet_NaN();
 586 :       Eigen::Matrix<double,-1,1> zeta_scale =
 587 :         Eigen::Matrix<double,-1,1>::Constant(C,
 588 :           std::numeric_limits<double>::quiet_NaN());
 589 :       Eigen::Matrix<double,-1,1> eps_scale =
 590 :         Eigen::Matrix<double,-1,1>::Constant(K,
 591 :           std::numeric_limits<double>::quiet_NaN());
 592 :       out__.write(rho);
 593 :       out__.write(sigma);
 594 :       out__.write(tau);
 595 :       out__.write(alpha);
 596 :       out__.write(theta);
 597 :       out__.write(mu);
 598 :       out__.write(eps);
 599 :       out__.write(zeta);
 600 :       for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 601 :         for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 602 :           out__.write(delta[(sym2__ - 1)][(sym1__ - 1)]);
 603 :         }
 604 :       }
 605 :       if (stan::math::logical_negation(
 606 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 607 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 608 :         return ;
 609 :       }
 610 :       current_statement__ = 10;
 611 :       tau_sqrt = stan::math::sqrt(tau);
 612 :       current_statement__ = 11;
 613 :       sigma_sqrt = stan::math::sqrt(sigma);
 614 :       current_statement__ = 12;
 615 :       stan::model::assign(zeta_scale, stan::math::multiply(zeta, tau_sqrt),
 616 :         "assigning variable zeta_scale");
 617 :       current_statement__ = 13;
 618 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 619 :         "assigning variable eps_scale");
 620 :       current_statement__ = 10;
 621 :       stan::math::check_greater_or_equal(function__, "tau_sqrt", tau_sqrt, 0);
 622 :       current_statement__ = 11;
 623 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 624 :         sigma_sqrt, 0);
 625 :       if (emit_transformed_parameters__) {
 626 :         out__.write(tau_sqrt);
 627 :         out__.write(sigma_sqrt);
 628 :         out__.write(zeta_scale);
 629 :         out__.write(eps_scale);
 630 :       }
 631 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 632 :         return ;
 633 :       }
 634 :       Eigen::Matrix<double,-1,1> colony_dist =
 635 :         Eigen::Matrix<double,-1,1>::Constant(C,
 636 :           std::numeric_limits<double>::quiet_NaN());
 637 :       current_statement__ = 15;
 638 :       stan::model::assign(colony_dist, stan::math::rep_vector(0, C),
 639 :         "assigning variable colony_dist");
 640 :       {
 641 :         current_statement__ = 16;
 642 :         stan::math::validate_non_negative_index("dis", "C", C);
 643 :         current_statement__ = 17;
 644 :         stan::math::validate_non_negative_index("dis", "K", K);
 645 :         Eigen::Matrix<double,-1,-1> dis =
 646 :           Eigen::Matrix<double,-1,-1>::Constant(C, K,
 647 :             std::numeric_limits<double>::quiet_NaN());
 648 :         current_statement__ = 19;
 649 :         stan::math::validate_non_negative_index("lambda", "C", C);
 650 :         current_statement__ = 20;
 651 :         stan::math::validate_non_negative_index("lambda", "K", K);
 652 :         Eigen::Matrix<double,-1,-1> lambda =
 653 :           Eigen::Matrix<double,-1,-1>::Constant(C, K,
 654 :             std::numeric_limits<double>::quiet_NaN());
 655 :         current_statement__ = 22;
 656 :         stan::math::validate_non_negative_index("V", "C", C);
 657 :         Eigen::Matrix<double,-1,1> V =
 658 :           Eigen::Matrix<double,-1,1>::Constant(C,
 659 :             std::numeric_limits<double>::quiet_NaN());
 660 :         double nugget = std::numeric_limits<double>::quiet_NaN();
 661 :         current_statement__ = 24;
 662 :         nugget = 1e-12;
 663 :         current_statement__ = 30;
 664 :         for (int i = 1; i <= C; ++i) {
 665 :           current_statement__ = 28;
 666 :           for (int k = 1; k <= K; ++k) {
 667 :             current_statement__ = 25;
 668 :             stan::model::assign(dis,
 669 :               stan::math::sqrt(
 670 :                 (stan::math::square(
 671 :                    (stan::model::rvalue(delta, "delta",
 672 :                       stan::model::index_uni(i), stan::model::index_uni(1)) -
 673 :                    stan::model::rvalue(trap, "trap",
 674 :                      stan::model::index_uni(k), stan::model::index_uni(1))))
 675 :                 +
 676 :                 stan::math::square(
 677 :                   (stan::model::rvalue(delta, "delta",
 678 :                      stan::model::index_uni(i), stan::model::index_uni(2)) -
 679 :                   stan::model::rvalue(trap, "trap",
 680 :                     stan::model::index_uni(k), stan::model::index_uni(2)))))),
 681 :               "assigning variable dis", stan::model::index_uni(i),
 682 :               stan::model::index_uni(k));
 683 :             current_statement__ = 26;
 684 :             stan::model::assign(lambda,
 685 :               (((((stan::model::rvalue(dis, "dis", stan::model::index_uni(i),
 686 :                      stan::model::index_uni(k)) / (-rho *
 687 :               stan::math::exp((alpha *
 688 :                 stan::model::rvalue(landscape, "landscape",
 689 :                   stan::model::index_uni(k)))))) + (theta *
 690 :               stan::model::rvalue(floral, "floral", stan::model::index_uni(k))))
 691 :               + mu) +
 692 :               stan::model::rvalue(zeta_scale, "zeta_scale",
 693 :                 stan::model::index_uni(i))) +
 694 :               stan::model::rvalue(eps_scale, "eps_scale",
 695 :                 stan::model::index_uni(k))), "assigning variable lambda",
 696 :               stan::model::index_uni(i), stan::model::index_uni(k));
 697 :           }
 698 :         }
 699 :         current_statement__ = 33;
 700 :         for (int i = 1; i <= C; ++i) {
 701 :           current_statement__ = 31;
 702 :           stan::model::assign(V,
 703 :             stan::math::sum(
 704 :               stan::math::exp(
 705 :                 stan::model::rvalue(lambda, "lambda",
 706 :                   stan::model::index_uni(i), stan::model::index_omni()))),
 707 :             "assigning variable V", stan::model::index_uni(i));
 708 :         }
 709 :         current_statement__ = 36;
 710 :         for (int k = 1; k <= K; ++k) {
 711 :           current_statement__ = 34;
 712 :           stan::model::assign(colony_dist,
 713 :             stan::math::add(stan::model::deep_copy(colony_dist),
 714 :               stan::math::elt_divide(
 715 :                 stan::math::elt_multiply(
 716 :                   stan::model::rvalue(dis, "dis", stan::model::index_omni(),
 717 :                     stan::model::index_uni(k)),
 718 :                   stan::math::exp(
 719 :                     stan::model::rvalue(lambda, "lambda",
 720 :                       stan::model::index_omni(), stan::model::index_uni(k)))),
 721 :                 stan::math::add(V, nugget))),
 722 :             "assigning variable colony_dist");
 723 :         }
 724 :       }
 725 :       out__.write(colony_dist);
 726 :     } catch (const std::exception& e) {
 727 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 728 :     }
 729 :   }
 730 :   template <typename VecVar, typename VecI,
 731 :             stan::require_vector_t<VecVar>* = nullptr,
 732 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 733 :   inline void
 734 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 735 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 736 :     using local_scalar_t__ = double;
 737 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 738 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 739 :     int current_statement__ = 0;
 740 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 741 :     // suppress unused var warning
 742 :     (void) DUMMY_VAR__;
 743 :     try {
 744 :       int pos__ = std::numeric_limits<int>::min();
 745 :       pos__ = 1;
 746 :       local_scalar_t__ rho = DUMMY_VAR__;
 747 :       current_statement__ = 1;
 748 :       rho = in__.read<local_scalar_t__>();
 749 :       out__.write_free_lb(0, rho);
 750 :       local_scalar_t__ sigma = DUMMY_VAR__;
 751 :       current_statement__ = 2;
 752 :       sigma = in__.read<local_scalar_t__>();
 753 :       out__.write_free_lb(0, sigma);
 754 :       local_scalar_t__ tau = DUMMY_VAR__;
 755 :       current_statement__ = 3;
 756 :       tau = in__.read<local_scalar_t__>();
 757 :       out__.write_free_lb(0, tau);
 758 :       local_scalar_t__ alpha = DUMMY_VAR__;
 759 :       current_statement__ = 4;
 760 :       alpha = in__.read<local_scalar_t__>();
 761 :       out__.write(alpha);
 762 :       local_scalar_t__ theta = DUMMY_VAR__;
 763 :       current_statement__ = 5;
 764 :       theta = in__.read<local_scalar_t__>();
 765 :       out__.write(theta);
 766 :       local_scalar_t__ mu = DUMMY_VAR__;
 767 :       current_statement__ = 6;
 768 :       mu = in__.read<local_scalar_t__>();
 769 :       out__.write(mu);
 770 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 771 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 772 :       current_statement__ = 7;
 773 :       stan::model::assign(eps,
 774 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 775 :         "assigning variable eps");
 776 :       out__.write(eps);
 777 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 778 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 779 :       current_statement__ = 8;
 780 :       stan::model::assign(zeta,
 781 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 782 :         "assigning variable zeta");
 783 :       out__.write(zeta);
 784 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 785 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 786 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 787 :       current_statement__ = 9;
 788 :       for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 789 :         current_statement__ = 9;
 790 :         for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 791 :           current_statement__ = 9;
 792 :           stan::model::assign(delta, in__.read<local_scalar_t__>(),
 793 :             "assigning variable delta", stan::model::index_uni(sym2__),
 794 :             stan::model::index_uni(sym1__));
 795 :         }
 796 :       }
 797 :       out__.write_free_lub(lowerbound, upperbound, delta);
 798 :     } catch (const std::exception& e) {
 799 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 800 :     }
 801 :   }
 802 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 803 :   inline void
 804 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 805 :                        vars__, std::ostream* pstream__ = nullptr) const {
 806 :     using local_scalar_t__ = double;
 807 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 808 :     int current_statement__ = 0;
 809 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 810 :     // suppress unused var warning
 811 :     (void) DUMMY_VAR__;
 812 :     try {
 813 :       current_statement__ = 1;
 814 :       context__.validate_dims("parameter initialization", "rho", "double",
 815 :         std::vector<size_t>{});
 816 :       current_statement__ = 2;
 817 :       context__.validate_dims("parameter initialization", "sigma", "double",
 818 :         std::vector<size_t>{});
 819 :       current_statement__ = 3;
 820 :       context__.validate_dims("parameter initialization", "tau", "double",
 821 :         std::vector<size_t>{});
 822 :       current_statement__ = 4;
 823 :       context__.validate_dims("parameter initialization", "alpha", "double",
 824 :         std::vector<size_t>{});
 825 :       current_statement__ = 5;
 826 :       context__.validate_dims("parameter initialization", "theta", "double",
 827 :         std::vector<size_t>{});
 828 :       current_statement__ = 6;
 829 :       context__.validate_dims("parameter initialization", "mu", "double",
 830 :         std::vector<size_t>{});
 831 :       current_statement__ = 7;
 832 :       context__.validate_dims("parameter initialization", "eps", "double",
 833 :         std::vector<size_t>{static_cast<size_t>(K)});
 834 :       current_statement__ = 8;
 835 :       context__.validate_dims("parameter initialization", "zeta", "double",
 836 :         std::vector<size_t>{static_cast<size_t>(C)});
 837 :       current_statement__ = 9;
 838 :       context__.validate_dims("parameter initialization", "delta", "double",
 839 :         std::vector<size_t>{static_cast<size_t>(C), static_cast<size_t>(2)});
 840 :       int pos__ = std::numeric_limits<int>::min();
 841 :       pos__ = 1;
 842 :       local_scalar_t__ rho = DUMMY_VAR__;
 843 :       current_statement__ = 1;
 844 :       rho = context__.vals_r("rho")[(1 - 1)];
 845 :       out__.write_free_lb(0, rho);
 846 :       local_scalar_t__ sigma = DUMMY_VAR__;
 847 :       current_statement__ = 2;
 848 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 849 :       out__.write_free_lb(0, sigma);
 850 :       local_scalar_t__ tau = DUMMY_VAR__;
 851 :       current_statement__ = 3;
 852 :       tau = context__.vals_r("tau")[(1 - 1)];
 853 :       out__.write_free_lb(0, tau);
 854 :       local_scalar_t__ alpha = DUMMY_VAR__;
 855 :       current_statement__ = 4;
 856 :       alpha = context__.vals_r("alpha")[(1 - 1)];
 857 :       out__.write(alpha);
 858 :       local_scalar_t__ theta = DUMMY_VAR__;
 859 :       current_statement__ = 5;
 860 :       theta = context__.vals_r("theta")[(1 - 1)];
 861 :       out__.write(theta);
 862 :       local_scalar_t__ mu = DUMMY_VAR__;
 863 :       current_statement__ = 6;
 864 :       mu = context__.vals_r("mu")[(1 - 1)];
 865 :       out__.write(mu);
 866 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 867 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 868 :       {
 869 :         std::vector<local_scalar_t__> eps_flat__;
 870 :         current_statement__ = 7;
 871 :         eps_flat__ = context__.vals_r("eps");
 872 :         current_statement__ = 7;
 873 :         pos__ = 1;
 874 :         current_statement__ = 7;
 875 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 876 :           current_statement__ = 7;
 877 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 878 :             "assigning variable eps", stan::model::index_uni(sym1__));
 879 :           current_statement__ = 7;
 880 :           pos__ = (pos__ + 1);
 881 :         }
 882 :       }
 883 :       out__.write(eps);
 884 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 885 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 886 :       {
 887 :         std::vector<local_scalar_t__> zeta_flat__;
 888 :         current_statement__ = 8;
 889 :         zeta_flat__ = context__.vals_r("zeta");
 890 :         current_statement__ = 8;
 891 :         pos__ = 1;
 892 :         current_statement__ = 8;
 893 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 894 :           current_statement__ = 8;
 895 :           stan::model::assign(zeta, zeta_flat__[(pos__ - 1)],
 896 :             "assigning variable zeta", stan::model::index_uni(sym1__));
 897 :           current_statement__ = 8;
 898 :           pos__ = (pos__ + 1);
 899 :         }
 900 :       }
 901 :       out__.write(zeta);
 902 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 903 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 904 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 905 :       {
 906 :         std::vector<local_scalar_t__> delta_flat__;
 907 :         current_statement__ = 9;
 908 :         delta_flat__ = context__.vals_r("delta");
 909 :         current_statement__ = 9;
 910 :         pos__ = 1;
 911 :         current_statement__ = 9;
 912 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 913 :           current_statement__ = 9;
 914 :           for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 915 :             current_statement__ = 9;
 916 :             stan::model::assign(delta, delta_flat__[(pos__ - 1)],
 917 :               "assigning variable delta", stan::model::index_uni(sym2__),
 918 :               stan::model::index_uni(sym1__));
 919 :             current_statement__ = 9;
 920 :             pos__ = (pos__ + 1);
 921 :           }
 922 :         }
 923 :       }
 924 :       out__.write_free_lub(lowerbound, upperbound, delta);
 925 :     } catch (const std::exception& e) {
 926 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 927 :     }
 928 :   }
 929 :   inline void
 930 :   get_param_names(std::vector<std::string>& names__, const bool
 931 :                   emit_transformed_parameters__ = true, const bool
 932 :                   emit_generated_quantities__ = true) const {
 933 :     names__ = std::vector<std::string>{"rho", "sigma", "tau", "alpha",
 934 :                 "theta", "mu", "eps", "zeta", "delta"};
 935 :     if (emit_transformed_parameters__) {
 936 :       std::vector<std::string>
 937 :         temp{"tau_sqrt", "sigma_sqrt", "zeta_scale", "eps_scale"};
 938 :       names__.reserve(names__.size() + temp.size());
 939 :       names__.insert(names__.end(), temp.begin(), temp.end());
 940 :     }
 941 :     if (emit_generated_quantities__) {
 942 :       std::vector<std::string> temp{"colony_dist"};
 943 :       names__.reserve(names__.size() + temp.size());
 944 :       names__.insert(names__.end(), temp.begin(), temp.end());
 945 :     }
 946 :   }
 947 :   inline void
 948 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 949 :            emit_transformed_parameters__ = true, const bool
 950 :            emit_generated_quantities__ = true) const {
 951 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 952 :                 std::vector<size_t>{}, std::vector<size_t>{},
 953 :                 std::vector<size_t>{}, std::vector<size_t>{},
 954 :                 std::vector<size_t>{},
 955 :                 std::vector<size_t>{static_cast<size_t>(K)},
 956 :                 std::vector<size_t>{static_cast<size_t>(C)},
 957 :                 std::vector<size_t>{static_cast<size_t>(C),
 958 :                   static_cast<size_t>(2)}};
 959 :     if (emit_transformed_parameters__) {
 960 :       std::vector<std::vector<size_t>>
 961 :         temp{std::vector<size_t>{}, std::vector<size_t>{},
 962 :              std::vector<size_t>{static_cast<size_t>(C)},
 963 :              std::vector<size_t>{static_cast<size_t>(K)}};
 964 :       dimss__.reserve(dimss__.size() + temp.size());
 965 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 966 :     }
 967 :     if (emit_generated_quantities__) {
 968 :       std::vector<std::vector<size_t>>
 969 :         temp{std::vector<size_t>{static_cast<size_t>(C)}};
 970 :       dimss__.reserve(dimss__.size() + temp.size());
 971 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 972 :     }
 973 :   }
 974 :   inline void
 975 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 976 :                           emit_transformed_parameters__ = true, bool
 977 :                           emit_generated_quantities__ = true) const final {
 978 :     param_names__.emplace_back(std::string() + "rho");
 979 :     param_names__.emplace_back(std::string() + "sigma");
 980 :     param_names__.emplace_back(std::string() + "tau");
 981 :     param_names__.emplace_back(std::string() + "alpha");
 982 :     param_names__.emplace_back(std::string() + "theta");
 983 :     param_names__.emplace_back(std::string() + "mu");
 984 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 985 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 986 :         std::to_string(sym1__));
 987 :     }
 988 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 989 :       param_names__.emplace_back(std::string() + "zeta" + '.' +
 990 :         std::to_string(sym1__));
 991 :     }
 992 :     for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 993 :       for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 994 :         param_names__.emplace_back(std::string() + "delta" + '.' +
 995 :           std::to_string(sym2__) + '.' + std::to_string(sym1__));
 996 :       }
 997 :     }
 998 :     if (emit_transformed_parameters__) {
 999 :       param_names__.emplace_back(std::string() + "tau_sqrt");
1000 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
1001 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
1002 :         param_names__.emplace_back(std::string() + "zeta_scale" + '.' +
1003 :           std::to_string(sym1__));
1004 :       }
1005 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
1006 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
1007 :           std::to_string(sym1__));
1008 :       }
1009 :     }
1010 :     if (emit_generated_quantities__) {
1011 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
1012 :         param_names__.emplace_back(std::string() + "colony_dist" + '.' +
1013 :           std::to_string(sym1__));
1014 :       }
1015 :     }
1016 :   }
1017 :   inline void
1018 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
1019 :                             emit_transformed_parameters__ = true, bool
1020 :                             emit_generated_quantities__ = true) const final {
1021 :     param_names__.emplace_back(std::string() + "rho");
1022 :     param_names__.emplace_back(std::string() + "sigma");
1023 :     param_names__.emplace_back(std::string() + "tau");
1024 :     param_names__.emplace_back(std::string() + "alpha");
1025 :     param_names__.emplace_back(std::string() + "theta");
1026 :     param_names__.emplace_back(std::string() + "mu");
1027 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
1028 :       param_names__.emplace_back(std::string() + "eps" + '.' +
1029 :         std::to_string(sym1__));
1030 :     }
1031 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
1032 :       param_names__.emplace_back(std::string() + "zeta" + '.' +
1033 :         std::to_string(sym1__));
1034 :     }
1035 :     for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
1036 :       for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
1037 :         param_names__.emplace_back(std::string() + "delta" + '.' +
1038 :           std::to_string(sym2__) + '.' + std::to_string(sym1__));
1039 :       }
1040 :     }
1041 :     if (emit_transformed_parameters__) {
1042 :       param_names__.emplace_back(std::string() + "tau_sqrt");
1043 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
1044 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
1045 :         param_names__.emplace_back(std::string() + "zeta_scale" + '.' +
1046 :           std::to_string(sym1__));
1047 :       }
1048 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
1049 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
1050 :           std::to_string(sym1__));
1051 :       }
1052 :     }
1053 :     if (emit_generated_quantities__) {
1054 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
1055 :         param_names__.emplace_back(std::string() + "colony_dist" + '.' +
1056 :           std::to_string(sym1__));
1057 :       }
1058 :     }
1059 :   }
1060 :   inline std::string get_constrained_sizedtypes() const {
1061 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"zeta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"zeta_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"},{\"name\":\"colony_dist\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
1062 :   }
1063 :   inline std::string get_unconstrained_sizedtypes() const {
1064 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"alpha\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"zeta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"zeta_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"},{\"name\":\"colony_dist\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"generated_quantities\"}]");
1065 :   }
1066 :   // Begin method overload boilerplate
1067 :   template <typename RNG> inline void
1068 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
1069 :               Eigen::Matrix<double,-1,1>& vars, const bool
1070 :               emit_transformed_parameters = true, const bool
1071 :               emit_generated_quantities = true, std::ostream*
1072 :               pstream = nullptr) const {
1073 :     const size_t num_params__ = ((((((((1 + 1) + 1) + 1) + 1) + 1) + K) + C)
1074 :       + (C * 2));
1075 :     const size_t num_transformed = emit_transformed_parameters * ((((1 + 1) +
1076 :       C) + K));
1077 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
1078 :     const size_t num_to_write = num_params__ + num_transformed +
1079 :       num_gen_quantities;
1080 :     std::vector<int> params_i;
1081 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
1082 :              std::numeric_limits<double>::quiet_NaN());
1083 :     write_array_impl(base_rng, params_r, params_i, vars,
1084 :       emit_transformed_parameters, emit_generated_quantities, pstream);
1085 :   }
1086 :   template <typename RNG> inline void
1087 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
1088 :               params_i, std::vector<double>& vars, bool
1089 :               emit_transformed_parameters = true, bool
1090 :               emit_generated_quantities = true, std::ostream*
1091 :               pstream = nullptr) const {
1092 :     const size_t num_params__ = ((((((((1 + 1) + 1) + 1) + 1) + 1) + K) + C)
1093 :       + (C * 2));
1094 :     const size_t num_transformed = emit_transformed_parameters * ((((1 + 1) +
1095 :       C) + K));
1096 :     const size_t num_gen_quantities = emit_generated_quantities * (C);
1097 :     const size_t num_to_write = num_params__ + num_transformed +
1098 :       num_gen_quantities;
1099 :     vars = std::vector<double>(num_to_write,
1100 :              std::numeric_limits<double>::quiet_NaN());
1101 :     write_array_impl(base_rng, params_r, params_i, vars,
1102 :       emit_transformed_parameters, emit_generated_quantities, pstream);
1103 :   }
1104 :   template <bool propto__, bool jacobian__, typename T_> inline T_
1105 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
1106 :     Eigen::Matrix<int,-1,1> params_i;
1107 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
1108 :   }
1109 :   template <bool propto__, bool jacobian__, typename T_> inline T_
1110 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
1111 :            std::ostream* pstream = nullptr) const {
1112 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
1113 :   }
1114 :   inline void
1115 :   transform_inits(const stan::io::var_context& context,
1116 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
1117 :                   pstream = nullptr) const final {
1118 :     std::vector<double> params_r_vec(params_r.size());
1119 :     std::vector<int> params_i;
1120 :     transform_inits(context, params_i, params_r_vec, pstream);
1121 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
1122 :                  params_r_vec.size());
1123 :   }
1124 :   inline void
1125 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
1126 :                   params_i, std::vector<double>& vars, std::ostream*
1127 :                   pstream__ = nullptr) const {
1128 :     vars.resize(num_params_r__);
1129 :     transform_inits_impl(context, vars, pstream__);
1130 :   }
1131 :   inline void
1132 :   unconstrain_array(const std::vector<double>& params_constrained,
1133 :                     std::vector<double>& params_unconstrained, std::ostream*
1134 :                     pstream = nullptr) const {
1135 :     const std::vector<int> params_i;
1136 :     params_unconstrained = std::vector<double>(num_params_r__,
1137 :                              std::numeric_limits<double>::quiet_NaN());
1138 :     unconstrain_array_impl(params_constrained, params_i,
1139 :       params_unconstrained, pstream);
1140 :   }
1141 :   inline void
1142 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
1143 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
1144 :                     std::ostream* pstream = nullptr) const {
1145 :     const std::vector<int> params_i;
1146 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
1147 :                              std::numeric_limits<double>::quiet_NaN());
1148 :     unconstrain_array_impl(params_constrained, params_i,
1149 :       params_unconstrained, pstream);
1150 :   }
1151 : };
1152 : }
1153 : using stan_model = model3af32e1f06c7ae__namespace::model3af32e1f06c7ae_;
1154 : #ifndef USING_R
1155 : // Boilerplate
1156 : stan::model::model_base&
1157 : new_model(stan::io::var_context& data_context, unsigned int seed,
1158 :           std::ostream* msg_stream) {
1159 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
1160 :   return *m;
1161 : }
1162 : stan::math::profile_map& get_stan_profile_data() {
1163 :   return model3af32e1f06c7ae__namespace::profiles__;
1164 : }
1165 : #endif
1166 : #endif
1167 : 
1168 : RCPP_MODULE(stan_fit4model3af32e1f06c7ae__mod) {
1169 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
1170 :       "stan_fit4model3af32e1f06c7ae_")
1171 : 
1172 :       .constructor<SEXP, SEXP, SEXP>()
1173 : 
1174 :       .method(
1175 :           "call_sampler",
1176 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
1177 :       .method(
1178 :           "param_names",
1179 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
1180 :       .method("param_names_oi",
1181 :               &rstan::stan_fit<stan_model,
1182 :                                boost::random::ecuyer1988>::param_names_oi)
1183 :       .method("param_fnames_oi",
1184 :               &rstan::stan_fit<stan_model,
1185 :                                boost::random::ecuyer1988>::param_fnames_oi)
1186 :       .method(
1187 :           "param_dims",
1188 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
1189 :       .method("param_dims_oi",
1190 :               &rstan::stan_fit<stan_model,
1191 :                                boost::random::ecuyer1988>::param_dims_oi)
1192 :       .method("update_param_oi",
1193 :               &rstan::stan_fit<stan_model,
1194 :                                boost::random::ecuyer1988>::update_param_oi)
1195 :       .method("param_oi_tidx",
1196 :               &rstan::stan_fit<stan_model,
1197 :                                boost::random::ecuyer1988>::param_oi_tidx)
1198 :       .method("grad_log_prob",
1199 :               &rstan::stan_fit<stan_model,
1200 :                                boost::random::ecuyer1988>::grad_log_prob)
1201 :       .method("log_prob",
1202 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
1203 :       .method("unconstrain_pars",
1204 :               &rstan::stan_fit<stan_model,
1205 :                                boost::random::ecuyer1988>::unconstrain_pars)
1206 :       .method("constrain_pars",
1207 :               &rstan::stan_fit<stan_model,
1208 :                                boost::random::ecuyer1988>::constrain_pars)
1209 :       .method(
1210 :           "num_pars_unconstrained",
1211 :           &rstan::stan_fit<stan_model,
1212 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
1213 :       .method(
1214 :           "unconstrained_param_names",
1215 :           &rstan::stan_fit<
1216 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
1217 :       .method(
1218 :           "constrained_param_names",
1219 :           &rstan::stan_fit<stan_model,
1220 :                            boost::random::ecuyer1988>::constrained_param_names)
1221 :       .method("standalone_gqs",
1222 :               &rstan::stan_fit<stan_model,
1223 :                                boost::random::ecuyer1988>::standalone_gqs);
1224 : }
1225 : 
1226 : 
1227 : // declarations
1228 : extern "C" {
1229 : SEXP file3af32e530b1eec( ) ;
1230 : }
1231 : 
1232 : // definition
1233 : SEXP file3af32e530b1eec() {
1234 :  return Rcpp::wrap("anon_model");
1235 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='file3af32e530b1eec.so' OBJECTS='file3af32e530b1eec.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v4 -fno-math-errno  -c file3af32e530b1eec.cpp -o file3af32e530b1eec.o
if test  "zfile3af32e530b1eec.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file3af32e530b1eec.so file3af32e530b1eec.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o file3af32e530b1eec.so file3af32e530b1eec.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v4/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).
Chain 1: 
Chain 1: Gradient evaluation took 0.00395 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 39.5 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Gradient evaluated at the initial value is not finite.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 3:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Gradient evaluated at the initial value is not finite.
Chain 3:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Gradient evaluated at the initial value is not finite.
Chain 2:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Gradient evaluated at the initial value is not finite.
Chain 3:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Gradient evaluated at the initial value is not finite.
Chain 2:   Stan can't start sampling from this initial value.
Chain 2: Rejecting initial value:
Chain 2:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 2:   Stan can't start sampling from this initial value.
Chain 3: Rejecting initial value:
Chain 3:   Gradient evaluated at the initial value is not finite.
Chain 3:   Stan can't start sampling from this initial value.
Chain 2: 
Chain 2: Gradient evaluation took 0.00259 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 25.9 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 3: 
Chain 3: Gradient evaluation took 0.002309 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 23.09 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Gradient evaluated at the initial value is not finite.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: Rejecting initial value:
Chain 4:   Log probability evaluates to log(0), i.e. negative infinity.
Chain 4:   Stan can't start sampling from this initial value.
Chain 4: 
Chain 4: Gradient evaluation took 0.002412 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 24.12 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 1: Iteration:    1 / 6000 [  0%]  (Warmup)
Chain 3: Iteration:    1 / 6000 [  0%]  (Warmup)
Chain 2: Iteration:    1 / 6000 [  0%]  (Warmup)
Chain 4: Iteration:    1 / 6000 [  0%]  (Warmup)
Chain 1: Iteration:  600 / 6000 [ 10%]  (Warmup)
Chain 4: Iteration:  600 / 6000 [ 10%]  (Warmup)
Chain 3: Iteration:  600 / 6000 [ 10%]  (Warmup)
Chain 2: Iteration:  600 / 6000 [ 10%]  (Warmup)
Chain 4: Iteration: 1001 / 6000 [ 16%]  (Sampling)
Chain 1: Iteration: 1001 / 6000 [ 16%]  (Sampling)
Chain 3: Iteration: 1001 / 6000 [ 16%]  (Sampling)
Chain 2: Iteration: 1001 / 6000 [ 16%]  (Sampling)
Chain 1: Iteration: 1600 / 6000 [ 26%]  (Sampling)
Chain 4: Iteration: 1600 / 6000 [ 26%]  (Sampling)
Chain 3: Iteration: 1600 / 6000 [ 26%]  (Sampling)
Chain 2: Iteration: 1600 / 6000 [ 26%]  (Sampling)
Chain 1: Iteration: 2200 / 6000 [ 36%]  (Sampling)
Chain 4: Iteration: 2200 / 6000 [ 36%]  (Sampling)
Chain 3: Iteration: 2200 / 6000 [ 36%]  (Sampling)
Chain 2: Iteration: 2200 / 6000 [ 36%]  (Sampling)
Chain 1: Iteration: 2800 / 6000 [ 46%]  (Sampling)
Chain 4: Iteration: 2800 / 6000 [ 46%]  (Sampling)
Chain 3: Iteration: 2800 / 6000 [ 46%]  (Sampling)
Chain 2: Iteration: 2800 / 6000 [ 46%]  (Sampling)
Chain 1: Iteration: 3400 / 6000 [ 56%]  (Sampling)
Chain 4: Iteration: 3400 / 6000 [ 56%]  (Sampling)
Chain 3: Iteration: 3400 / 6000 [ 56%]  (Sampling)
Chain 2: Iteration: 3400 / 6000 [ 56%]  (Sampling)
Chain 1: Iteration: 4000 / 6000 [ 66%]  (Sampling)
Chain 4: Iteration: 4000 / 6000 [ 66%]  (Sampling)
Chain 3: Iteration: 4000 / 6000 [ 66%]  (Sampling)
Chain 2: Iteration: 4000 / 6000 [ 66%]  (Sampling)
Chain 1: Iteration: 4600 / 6000 [ 76%]  (Sampling)
Chain 4: Iteration: 4600 / 6000 [ 76%]  (Sampling)
Chain 3: Iteration: 4600 / 6000 [ 76%]  (Sampling)
Chain 2: Iteration: 4600 / 6000 [ 76%]  (Sampling)
Chain 1: Iteration: 5200 / 6000 [ 86%]  (Sampling)
Chain 4: Iteration: 5200 / 6000 [ 86%]  (Sampling)
Chain 3: Iteration: 5200 / 6000 [ 86%]  (Sampling)
Chain 2: Iteration: 5200 / 6000 [ 86%]  (Sampling)
Chain 1: Iteration: 5800 / 6000 [ 96%]  (Sampling)
Chain 4: Iteration: 5800 / 6000 [ 96%]  (Sampling)
Chain 3: Iteration: 5800 / 6000 [ 96%]  (Sampling)
Chain 2: Iteration: 5800 / 6000 [ 96%]  (Sampling)
Chain 1: Iteration: 6000 / 6000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 152.762 seconds (Warm-up)
Chain 1:                477.015 seconds (Sampling)
Chain 1:                629.777 seconds (Total)
Chain 1: 
Chain 4: Iteration: 6000 / 6000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 152.645 seconds (Warm-up)
Chain 4:                481.348 seconds (Sampling)
Chain 4:                633.993 seconds (Total)
Chain 4: 
Chain 3: Iteration: 6000 / 6000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 154.172 seconds (Warm-up)
Chain 3:                483.406 seconds (Sampling)
Chain 3:                637.578 seconds (Total)
Chain 3: 
Chain 2: Iteration: 6000 / 6000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 160.003 seconds (Warm-up)
Chain 2:                484.207 seconds (Sampling)
Chain 2:                644.21 seconds (Total)
Chain 2: 
[1] "Model complete."
[1] "Model saved."

Call:
lm(formula = mean_dist ~ center_landscape, data = doubleton_colonies)

Residuals:
    Min      1Q  Median      3Q     Max 
-75.986 -33.893   1.254  26.630 138.225 

Coefficients:
                 Estimate Std. Error t value Pr(>|t|)    
(Intercept)        72.399      2.640  27.427   <2e-16 ***
center_landscape    1.644      2.976   0.552    0.581    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 41.42 on 305 degrees of freedom
Multiple R-squared:  0.0009992,	Adjusted R-squared:  -0.002276 
F-statistic: 0.3051 on 1 and 305 DF,  p-value: 0.5811

[1] TRUE
