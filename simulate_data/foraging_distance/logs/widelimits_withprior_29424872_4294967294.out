
TRANSLATING MODEL '' FROM Stan CODE TO C++ CODE NOW.
OS: x86_64, linux-gnu; rstan: 2.32.7; Rcpp: 1.0.14; inline: 0.3.21 
 >> setting environment variables: 
PKG_LIBS =  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb 
PKG_CPPFLAGS =   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1 
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : // [[Rcpp::plugins(cpp14)]]
   4 : 
   5 : 
   6 : // user includes
   7 : #include <Rcpp.h>
   8 : using namespace Rcpp;
   9 : #ifndef MODELS_HPP
  10 : #define MODELS_HPP
  11 : #define STAN__SERVICES__COMMAND_HPP
  12 : #include <rstan/rstaninc.hpp>
  13 : #ifndef USE_STANC3
  14 : #define USE_STANC3
  15 : #endif
  16 : // Code generated by stanc v2.32.2
  17 : #include <stan/model/model_header.hpp>
  18 : namespace modelb0e4552dd85b__namespace {
  19 : using stan::model::model_base_crtp;
  20 : using namespace stan::math;
  21 : stan::math::profile_map profiles__;
  22 : static constexpr std::array<const char*, 57> locations_array__ =
  23 :   {" (found before start of program)",
  24 :   " (in 'anon_model', line 21, column 0 to column 18)",
  25 :   " (in 'anon_model', line 22, column 0 to column 20)",
  26 :   " (in 'anon_model', line 23, column 0 to column 18)",
  27 :   " (in 'anon_model', line 24, column 0 to column 11)",
  28 :   " (in 'anon_model', line 25, column 0 to column 8)",
  29 :   " (in 'anon_model', line 26, column 0 to column 14)",
  30 :   " (in 'anon_model', line 27, column 0 to column 15)",
  31 :   " (in 'anon_model', line 28, column 0 to column 62)",
  32 :   " (in 'anon_model', line 31, column 2 to column 37)",
  33 :   " (in 'anon_model', line 32, column 2 to column 41)",
  34 :   " (in 'anon_model', line 33, column 2 to column 41)",
  35 :   " (in 'anon_model', line 34, column 2 to column 39)",
  36 :   " (in 'anon_model', line 41, column 7 to column 8)",
  37 :   " (in 'anon_model', line 41, column 9 to column 10)",
  38 :   " (in 'anon_model', line 41, column 0 to column 16)",
  39 :   " (in 'anon_model', line 42, column 7 to column 8)",
  40 :   " (in 'anon_model', line 42, column 9 to column 10)",
  41 :   " (in 'anon_model', line 42, column 0 to column 19)",
  42 :   " (in 'anon_model', line 44, column 0 to column 27)",
  43 :   " (in 'anon_model', line 45, column 0 to column 25)",
  44 :   " (in 'anon_model', line 46, column 0 to column 36)",
  45 :   " (in 'anon_model', line 47, column 0 to column 24)",
  46 :   " (in 'anon_model', line 48, column 0 to column 27)",
  47 :   " (in 'anon_model', line 50, column 2 to column 36)",
  48 :   " (in 'anon_model', line 49, column 14 to line 51, column 1)",
  49 :   " (in 'anon_model', line 49, column 0 to line 51, column 1)",
  50 :   " (in 'anon_model', line 53, column 0 to column 19)",
  51 :   " (in 'anon_model', line 54, column 0 to column 20)",
  52 :   " (in 'anon_model', line 58, column 4 to column 88)",
  53 :   " (in 'anon_model', line 59, column 4 to column 89)",
  54 :   " (in 'anon_model', line 60, column 4 to column 40)",
  55 :   " (in 'anon_model', line 57, column 15 to line 61, column 3)",
  56 :   " (in 'anon_model', line 57, column 2 to line 61, column 3)",
  57 :   " (in 'anon_model', line 56, column 13 to line 62, column 1)",
  58 :   " (in 'anon_model', line 56, column 0 to line 62, column 1)",
  59 :   " (in 'anon_model', line 7, column 0 to column 15)",
  60 :   " (in 'anon_model', line 8, column 0 to column 15)",
  61 :   " (in 'anon_model', line 9, column 7 to column 8)",
  62 :   " (in 'anon_model', line 9, column 0 to column 18)",
  63 :   " (in 'anon_model', line 10, column 6 to column 7)",
  64 :   " (in 'anon_model', line 10, column 9 to column 10)",
  65 :   " (in 'anon_model', line 10, column 0 to column 12)",
  66 :   " (in 'anon_model', line 11, column 0 to column 16)",
  67 :   " (in 'anon_model', line 12, column 0 to column 16)",
  68 :   " (in 'anon_model', line 13, column 0 to column 15)",
  69 :   " (in 'anon_model', line 14, column 7 to column 8)",
  70 :   " (in 'anon_model', line 14, column 0 to column 17)",
  71 :   " (in 'anon_model', line 15, column 0 to column 22)",
  72 :   " (in 'anon_model', line 16, column 0 to column 22)",
  73 :   " (in 'anon_model', line 17, column 0 to column 25)",
  74 :   " (in 'anon_model', line 18, column 0 to column 21)",
  75 :   " (in 'anon_model', line 26, column 7 to column 8)",
  76 :   " (in 'anon_model', line 27, column 7 to column 8)",
  77 :   " (in 'anon_model', line 28, column 7 to column 8)",
  78 :   " (in 'anon_model', line 33, column 9 to column 10)",
  79 :   " (in 'anon_model', line 34, column 9 to column 10)"};
  80 : class modelb0e4552dd85b_ final : public model_base_crtp<modelb0e4552dd85b_> {
  81 : private:
  82 :   int C;
  83 :   int K;
  84 :   Eigen::Matrix<double,-1,-1> trap_data__;
  85 :   std::vector<std::vector<int>> y;
  86 :   double lowerbound;
  87 :   double upperbound;
  88 :   double nestrange;
  89 :   Eigen::Matrix<double,-1,1> floral_data__;
  90 :   double priorVa;
  91 :   double priorCo;
  92 :   double rho_center;
  93 :   double rho_sd;
  94 :   Eigen::Map<Eigen::Matrix<double,-1,-1>> trap{nullptr, 0, 0};
  95 :   Eigen::Map<Eigen::Matrix<double,-1,1>> floral{nullptr, 0};
  96 : public:
  97 :   ~modelb0e4552dd85b_() {}
  98 :   modelb0e4552dd85b_(stan::io::var_context& context__, unsigned int
  99 :                      random_seed__ = 0, std::ostream* pstream__ = nullptr)
 100 :       : model_base_crtp(0) {
 101 :     int current_statement__ = 0;
 102 :     using local_scalar_t__ = double;
 103 :     boost::ecuyer1988 base_rng__ =
 104 :       stan::services::util::create_rng(random_seed__, 0);
 105 :     // suppress unused var warning
 106 :     (void) base_rng__;
 107 :     static constexpr const char* function__ =
 108 :       "modelb0e4552dd85b__namespace::modelb0e4552dd85b_";
 109 :     // suppress unused var warning
 110 :     (void) function__;
 111 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 112 :     // suppress unused var warning
 113 :     (void) DUMMY_VAR__;
 114 :     try {
 115 :       int pos__ = std::numeric_limits<int>::min();
 116 :       pos__ = 1;
 117 :       current_statement__ = 36;
 118 :       context__.validate_dims("data initialization", "C", "int",
 119 :         std::vector<size_t>{});
 120 :       C = std::numeric_limits<int>::min();
 121 :       current_statement__ = 36;
 122 :       C = context__.vals_i("C")[(1 - 1)];
 123 :       current_statement__ = 36;
 124 :       stan::math::check_greater_or_equal(function__, "C", C, 1);
 125 :       current_statement__ = 37;
 126 :       context__.validate_dims("data initialization", "K", "int",
 127 :         std::vector<size_t>{});
 128 :       K = std::numeric_limits<int>::min();
 129 :       current_statement__ = 37;
 130 :       K = context__.vals_i("K")[(1 - 1)];
 131 :       current_statement__ = 37;
 132 :       stan::math::check_greater_or_equal(function__, "K", K, 1);
 133 :       current_statement__ = 38;
 134 :       stan::math::validate_non_negative_index("trap", "K", K);
 135 :       current_statement__ = 39;
 136 :       context__.validate_dims("data initialization", "trap", "double",
 137 :         std::vector<size_t>{static_cast<size_t>(K), static_cast<size_t>(2)});
 138 :       trap_data__ = Eigen::Matrix<double,-1,-1>::Constant(K, 2,
 139 :                       std::numeric_limits<double>::quiet_NaN());
 140 :       new (&trap) Eigen::Map<Eigen::Matrix<double,-1,-1>>(trap_data__.data(),
 141 :         K, 2);
 142 :       {
 143 :         std::vector<local_scalar_t__> trap_flat__;
 144 :         current_statement__ = 39;
 145 :         trap_flat__ = context__.vals_r("trap");
 146 :         current_statement__ = 39;
 147 :         pos__ = 1;
 148 :         current_statement__ = 39;
 149 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 150 :           current_statement__ = 39;
 151 :           for (int sym2__ = 1; sym2__ <= K; ++sym2__) {
 152 :             current_statement__ = 39;
 153 :             stan::model::assign(trap, trap_flat__[(pos__ - 1)],
 154 :               "assigning variable trap", stan::model::index_uni(sym2__),
 155 :               stan::model::index_uni(sym1__));
 156 :             current_statement__ = 39;
 157 :             pos__ = (pos__ + 1);
 158 :           }
 159 :         }
 160 :       }
 161 :       current_statement__ = 40;
 162 :       stan::math::validate_non_negative_index("y", "C", C);
 163 :       current_statement__ = 41;
 164 :       stan::math::validate_non_negative_index("y", "K", K);
 165 :       current_statement__ = 42;
 166 :       context__.validate_dims("data initialization", "y", "int",
 167 :         std::vector<size_t>{static_cast<size_t>(C), static_cast<size_t>(K)});
 168 :       y = std::vector<std::vector<int>>(C,
 169 :             std::vector<int>(K, std::numeric_limits<int>::min()));
 170 :       {
 171 :         std::vector<int> y_flat__;
 172 :         current_statement__ = 42;
 173 :         y_flat__ = context__.vals_i("y");
 174 :         current_statement__ = 42;
 175 :         pos__ = 1;
 176 :         current_statement__ = 42;
 177 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 178 :           current_statement__ = 42;
 179 :           for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 180 :             current_statement__ = 42;
 181 :             stan::model::assign(y, y_flat__[(pos__ - 1)],
 182 :               "assigning variable y", stan::model::index_uni(sym2__),
 183 :               stan::model::index_uni(sym1__));
 184 :             current_statement__ = 42;
 185 :             pos__ = (pos__ + 1);
 186 :           }
 187 :         }
 188 :       }
 189 :       current_statement__ = 43;
 190 :       context__.validate_dims("data initialization", "lowerbound", "double",
 191 :         std::vector<size_t>{});
 192 :       lowerbound = std::numeric_limits<double>::quiet_NaN();
 193 :       current_statement__ = 43;
 194 :       lowerbound = context__.vals_r("lowerbound")[(1 - 1)];
 195 :       current_statement__ = 44;
 196 :       context__.validate_dims("data initialization", "upperbound", "double",
 197 :         std::vector<size_t>{});
 198 :       upperbound = std::numeric_limits<double>::quiet_NaN();
 199 :       current_statement__ = 44;
 200 :       upperbound = context__.vals_r("upperbound")[(1 - 1)];
 201 :       current_statement__ = 45;
 202 :       context__.validate_dims("data initialization", "nestrange", "double",
 203 :         std::vector<size_t>{});
 204 :       nestrange = std::numeric_limits<double>::quiet_NaN();
 205 :       current_statement__ = 45;
 206 :       nestrange = context__.vals_r("nestrange")[(1 - 1)];
 207 :       current_statement__ = 46;
 208 :       stan::math::validate_non_negative_index("floral", "K", K);
 209 :       current_statement__ = 47;
 210 :       context__.validate_dims("data initialization", "floral", "double",
 211 :         std::vector<size_t>{static_cast<size_t>(K)});
 212 :       floral_data__ = Eigen::Matrix<double,-1,1>::Constant(K,
 213 :                         std::numeric_limits<double>::quiet_NaN());
 214 :       new (&floral)
 215 :         Eigen::Map<Eigen::Matrix<double,-1,1>>(floral_data__.data(), K);
 216 :       {
 217 :         std::vector<local_scalar_t__> floral_flat__;
 218 :         current_statement__ = 47;
 219 :         floral_flat__ = context__.vals_r("floral");
 220 :         current_statement__ = 47;
 221 :         pos__ = 1;
 222 :         current_statement__ = 47;
 223 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 224 :           current_statement__ = 47;
 225 :           stan::model::assign(floral, floral_flat__[(pos__ - 1)],
 226 :             "assigning variable floral", stan::model::index_uni(sym1__));
 227 :           current_statement__ = 47;
 228 :           pos__ = (pos__ + 1);
 229 :         }
 230 :       }
 231 :       current_statement__ = 48;
 232 :       context__.validate_dims("data initialization", "priorVa", "double",
 233 :         std::vector<size_t>{});
 234 :       priorVa = std::numeric_limits<double>::quiet_NaN();
 235 :       current_statement__ = 48;
 236 :       priorVa = context__.vals_r("priorVa")[(1 - 1)];
 237 :       current_statement__ = 48;
 238 :       stan::math::check_greater_or_equal(function__, "priorVa", priorVa, 0);
 239 :       current_statement__ = 49;
 240 :       context__.validate_dims("data initialization", "priorCo", "double",
 241 :         std::vector<size_t>{});
 242 :       priorCo = std::numeric_limits<double>::quiet_NaN();
 243 :       current_statement__ = 49;
 244 :       priorCo = context__.vals_r("priorCo")[(1 - 1)];
 245 :       current_statement__ = 49;
 246 :       stan::math::check_greater_or_equal(function__, "priorCo", priorCo, 0);
 247 :       current_statement__ = 50;
 248 :       context__.validate_dims("data initialization", "rho_center", "double",
 249 :         std::vector<size_t>{});
 250 :       rho_center = std::numeric_limits<double>::quiet_NaN();
 251 :       current_statement__ = 50;
 252 :       rho_center = context__.vals_r("rho_center")[(1 - 1)];
 253 :       current_statement__ = 50;
 254 :       stan::math::check_greater_or_equal(function__, "rho_center",
 255 :         rho_center, 0);
 256 :       current_statement__ = 51;
 257 :       context__.validate_dims("data initialization", "rho_sd", "double",
 258 :         std::vector<size_t>{});
 259 :       rho_sd = std::numeric_limits<double>::quiet_NaN();
 260 :       current_statement__ = 51;
 261 :       rho_sd = context__.vals_r("rho_sd")[(1 - 1)];
 262 :       current_statement__ = 51;
 263 :       stan::math::check_greater_or_equal(function__, "rho_sd", rho_sd, 0);
 264 :       current_statement__ = 52;
 265 :       stan::math::validate_non_negative_index("eps", "K", K);
 266 :       current_statement__ = 53;
 267 :       stan::math::validate_non_negative_index("zeta", "C", C);
 268 :       current_statement__ = 54;
 269 :       stan::math::validate_non_negative_index("delta", "C", C);
 270 :       current_statement__ = 55;
 271 :       stan::math::validate_non_negative_index("zeta_scale", "C", C);
 272 :       current_statement__ = 56;
 273 :       stan::math::validate_non_negative_index("eps_scale", "K", K);
 274 :     } catch (const std::exception& e) {
 275 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 276 :     }
 277 :     num_params_r__ = 1 + 1 + 1 + 1 + 1 + K + C + (C * 2);
 278 :   }
 279 :   inline std::string model_name() const final {
 280 :     return "modelb0e4552dd85b_";
 281 :   }
 282 :   inline std::vector<std::string> model_compile_info() const noexcept {
 283 :     return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
 284 :              "stancflags = --"};
 285 :   }
 286 :   template <bool propto__, bool jacobian__, typename VecR, typename VecI,
 287 :             stan::require_vector_like_t<VecR>* = nullptr,
 288 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 289 :   inline stan::scalar_type_t<VecR>
 290 :   log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
 291 :                 pstream__ = nullptr) const {
 292 :     using T__ = stan::scalar_type_t<VecR>;
 293 :     using local_scalar_t__ = T__;
 294 :     T__ lp__(0.0);
 295 :     stan::math::accumulator<T__> lp_accum__;
 296 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 297 :     int current_statement__ = 0;
 298 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 299 :     // suppress unused var warning
 300 :     (void) DUMMY_VAR__;
 301 :     static constexpr const char* function__ =
 302 :       "modelb0e4552dd85b__namespace::log_prob";
 303 :     // suppress unused var warning
 304 :     (void) function__;
 305 :     try {
 306 :       local_scalar_t__ rho = DUMMY_VAR__;
 307 :       current_statement__ = 1;
 308 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 309 :               lp__);
 310 :       local_scalar_t__ sigma = DUMMY_VAR__;
 311 :       current_statement__ = 2;
 312 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 313 :                 jacobian__>(0, lp__);
 314 :       local_scalar_t__ tau = DUMMY_VAR__;
 315 :       current_statement__ = 3;
 316 :       tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 317 :               lp__);
 318 :       local_scalar_t__ theta = DUMMY_VAR__;
 319 :       current_statement__ = 4;
 320 :       theta = in__.template read<local_scalar_t__>();
 321 :       local_scalar_t__ mu = DUMMY_VAR__;
 322 :       current_statement__ = 5;
 323 :       mu = in__.template read<local_scalar_t__>();
 324 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 325 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 326 :       current_statement__ = 6;
 327 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 328 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 329 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 330 :       current_statement__ = 7;
 331 :       zeta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(C);
 332 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 333 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 334 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 335 :       current_statement__ = 8;
 336 :       delta = in__.template read_constrain_lub<
 337 :                 std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
 338 :                 jacobian__>(lowerbound, upperbound, lp__, C, 2);
 339 :       local_scalar_t__ tau_sqrt = DUMMY_VAR__;
 340 :       current_statement__ = 9;
 341 :       tau_sqrt = stan::math::sqrt(tau);
 342 :       local_scalar_t__ sigma_sqrt = DUMMY_VAR__;
 343 :       current_statement__ = 10;
 344 :       sigma_sqrt = stan::math::sqrt(sigma);
 345 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta_scale =
 346 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 347 :       current_statement__ = 11;
 348 :       stan::model::assign(zeta_scale, stan::math::multiply(zeta, tau_sqrt),
 349 :         "assigning variable zeta_scale");
 350 :       Eigen::Matrix<local_scalar_t__,-1,1> eps_scale =
 351 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 352 :       current_statement__ = 12;
 353 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 354 :         "assigning variable eps_scale");
 355 :       current_statement__ = 9;
 356 :       stan::math::check_greater_or_equal(function__, "tau_sqrt", tau_sqrt, 0);
 357 :       current_statement__ = 10;
 358 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 359 :         sigma_sqrt, 0);
 360 :       {
 361 :         current_statement__ = 13;
 362 :         stan::math::validate_non_negative_index("dis", "C", C);
 363 :         current_statement__ = 14;
 364 :         stan::math::validate_non_negative_index("dis", "K", K);
 365 :         Eigen::Matrix<local_scalar_t__,-1,-1> dis =
 366 :           Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(C, K, DUMMY_VAR__);
 367 :         current_statement__ = 16;
 368 :         stan::math::validate_non_negative_index("lambda", "C", C);
 369 :         current_statement__ = 17;
 370 :         stan::math::validate_non_negative_index("lambda", "K", K);
 371 :         Eigen::Matrix<local_scalar_t__,-1,-1> lambda =
 372 :           Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(C, K, DUMMY_VAR__);
 373 :         current_statement__ = 19;
 374 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(sigma, 0, priorVa));
 375 :         current_statement__ = 20;
 376 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(tau, 0, priorVa));
 377 :         current_statement__ = 21;
 378 :         lp_accum__.add(stan::math::lognormal_lpdf<propto__>(rho, rho_center,
 379 :                          rho_sd));
 380 :         current_statement__ = 22;
 381 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(mu, 0, priorCo));
 382 :         current_statement__ = 23;
 383 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(theta, 0, priorCo));
 384 :         current_statement__ = 26;
 385 :         for (int c = 1; c <= C; ++c) {
 386 :           current_statement__ = 24;
 387 :           lp_accum__.add(stan::math::normal_lpdf<propto__>(
 388 :                            stan::model::rvalue(delta, "delta",
 389 :                              stan::model::index_uni(c)), 750, nestrange));
 390 :         }
 391 :         current_statement__ = 27;
 392 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(eps, 0, 1));
 393 :         current_statement__ = 28;
 394 :         lp_accum__.add(stan::math::normal_lpdf<propto__>(zeta, 0, 1));
 395 :         current_statement__ = 35;
 396 :         for (int k = 1; k <= K; ++k) {
 397 :           current_statement__ = 33;
 398 :           for (int i = 1; i <= C; ++i) {
 399 :             current_statement__ = 29;
 400 :             stan::model::assign(dis,
 401 :               stan::math::sqrt(
 402 :                 (stan::math::square(
 403 :                    (stan::model::rvalue(delta, "delta",
 404 :                       stan::model::index_uni(i), stan::model::index_uni(1)) -
 405 :                    stan::model::rvalue(trap, "trap",
 406 :                      stan::model::index_uni(k), stan::model::index_uni(1))))
 407 :                 +
 408 :                 stan::math::square(
 409 :                   (stan::model::rvalue(delta, "delta",
 410 :                      stan::model::index_uni(i), stan::model::index_uni(2)) -
 411 :                   stan::model::rvalue(trap, "trap",
 412 :                     stan::model::index_uni(k), stan::model::index_uni(2)))))),
 413 :               "assigning variable dis", stan::model::index_uni(i),
 414 :               stan::model::index_uni(k));
 415 :             current_statement__ = 30;
 416 :             stan::model::assign(lambda,
 417 :               (((((-stan::model::rvalue(dis, "dis",
 418 :                       stan::model::index_uni(i), stan::model::index_uni(k)) /
 419 :               rho) + (theta *
 420 :               stan::model::rvalue(floral, "floral", stan::model::index_uni(k))))
 421 :               + mu) +
 422 :               stan::model::rvalue(zeta_scale, "zeta_scale",
 423 :                 stan::model::index_uni(i))) +
 424 :               stan::model::rvalue(eps_scale, "eps_scale",
 425 :                 stan::model::index_uni(k))), "assigning variable lambda",
 426 :               stan::model::index_uni(i), stan::model::index_uni(k));
 427 :             current_statement__ = 31;
 428 :             lp_accum__.add(stan::math::poisson_log_lpmf<propto__>(
 429 :                              stan::model::rvalue(y, "y",
 430 :                                stan::model::index_uni(i),
 431 :                                stan::model::index_uni(k)),
 432 :                              stan::model::rvalue(lambda, "lambda",
 433 :                                stan::model::index_uni(i),
 434 :                                stan::model::index_uni(k))));
 435 :           }
 436 :         }
 437 :       }
 438 :     } catch (const std::exception& e) {
 439 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 440 :     }
 441 :     lp_accum__.add(lp__);
 442 :     return lp_accum__.sum();
 443 :   }
 444 :   template <typename RNG, typename VecR, typename VecI, typename VecVar,
 445 :             stan::require_vector_like_vt<std::is_floating_point,
 446 :             VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
 447 :             VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
 448 :             VecVar>* = nullptr>
 449 :   inline void
 450 :   write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
 451 :                    VecVar& vars__, const bool
 452 :                    emit_transformed_parameters__ = true, const bool
 453 :                    emit_generated_quantities__ = true, std::ostream*
 454 :                    pstream__ = nullptr) const {
 455 :     using local_scalar_t__ = double;
 456 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 457 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 458 :     static constexpr bool propto__ = true;
 459 :     // suppress unused var warning
 460 :     (void) propto__;
 461 :     double lp__ = 0.0;
 462 :     // suppress unused var warning
 463 :     (void) lp__;
 464 :     int current_statement__ = 0;
 465 :     stan::math::accumulator<double> lp_accum__;
 466 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 467 :     // suppress unused var warning
 468 :     (void) DUMMY_VAR__;
 469 :     constexpr bool jacobian__ = false;
 470 :     static constexpr const char* function__ =
 471 :       "modelb0e4552dd85b__namespace::write_array";
 472 :     // suppress unused var warning
 473 :     (void) function__;
 474 :     try {
 475 :       double rho = std::numeric_limits<double>::quiet_NaN();
 476 :       current_statement__ = 1;
 477 :       rho = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 478 :               lp__);
 479 :       double sigma = std::numeric_limits<double>::quiet_NaN();
 480 :       current_statement__ = 2;
 481 :       sigma = in__.template read_constrain_lb<local_scalar_t__,
 482 :                 jacobian__>(0, lp__);
 483 :       double tau = std::numeric_limits<double>::quiet_NaN();
 484 :       current_statement__ = 3;
 485 :       tau = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
 486 :               lp__);
 487 :       double theta = std::numeric_limits<double>::quiet_NaN();
 488 :       current_statement__ = 4;
 489 :       theta = in__.template read<local_scalar_t__>();
 490 :       double mu = std::numeric_limits<double>::quiet_NaN();
 491 :       current_statement__ = 5;
 492 :       mu = in__.template read<local_scalar_t__>();
 493 :       Eigen::Matrix<double,-1,1> eps =
 494 :         Eigen::Matrix<double,-1,1>::Constant(K,
 495 :           std::numeric_limits<double>::quiet_NaN());
 496 :       current_statement__ = 6;
 497 :       eps = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(K);
 498 :       Eigen::Matrix<double,-1,1> zeta =
 499 :         Eigen::Matrix<double,-1,1>::Constant(C,
 500 :           std::numeric_limits<double>::quiet_NaN());
 501 :       current_statement__ = 7;
 502 :       zeta = in__.template read<Eigen::Matrix<local_scalar_t__,-1,1>>(C);
 503 :       std::vector<Eigen::Matrix<double,-1,1>> delta =
 504 :         std::vector<Eigen::Matrix<double,-1,1>>(C,
 505 :           Eigen::Matrix<double,-1,1>::Constant(2,
 506 :             std::numeric_limits<double>::quiet_NaN()));
 507 :       current_statement__ = 8;
 508 :       delta = in__.template read_constrain_lub<
 509 :                 std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>,
 510 :                 jacobian__>(lowerbound, upperbound, lp__, C, 2);
 511 :       double tau_sqrt = std::numeric_limits<double>::quiet_NaN();
 512 :       double sigma_sqrt = std::numeric_limits<double>::quiet_NaN();
 513 :       Eigen::Matrix<double,-1,1> zeta_scale =
 514 :         Eigen::Matrix<double,-1,1>::Constant(C,
 515 :           std::numeric_limits<double>::quiet_NaN());
 516 :       Eigen::Matrix<double,-1,1> eps_scale =
 517 :         Eigen::Matrix<double,-1,1>::Constant(K,
 518 :           std::numeric_limits<double>::quiet_NaN());
 519 :       out__.write(rho);
 520 :       out__.write(sigma);
 521 :       out__.write(tau);
 522 :       out__.write(theta);
 523 :       out__.write(mu);
 524 :       out__.write(eps);
 525 :       out__.write(zeta);
 526 :       for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 527 :         for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 528 :           out__.write(delta[(sym2__ - 1)][(sym1__ - 1)]);
 529 :         }
 530 :       }
 531 :       if (stan::math::logical_negation(
 532 :             (stan::math::primitive_value(emit_transformed_parameters__) ||
 533 :             stan::math::primitive_value(emit_generated_quantities__)))) {
 534 :         return ;
 535 :       }
 536 :       current_statement__ = 9;
 537 :       tau_sqrt = stan::math::sqrt(tau);
 538 :       current_statement__ = 10;
 539 :       sigma_sqrt = stan::math::sqrt(sigma);
 540 :       current_statement__ = 11;
 541 :       stan::model::assign(zeta_scale, stan::math::multiply(zeta, tau_sqrt),
 542 :         "assigning variable zeta_scale");
 543 :       current_statement__ = 12;
 544 :       stan::model::assign(eps_scale, stan::math::multiply(eps, sigma_sqrt),
 545 :         "assigning variable eps_scale");
 546 :       current_statement__ = 9;
 547 :       stan::math::check_greater_or_equal(function__, "tau_sqrt", tau_sqrt, 0);
 548 :       current_statement__ = 10;
 549 :       stan::math::check_greater_or_equal(function__, "sigma_sqrt",
 550 :         sigma_sqrt, 0);
 551 :       if (emit_transformed_parameters__) {
 552 :         out__.write(tau_sqrt);
 553 :         out__.write(sigma_sqrt);
 554 :         out__.write(zeta_scale);
 555 :         out__.write(eps_scale);
 556 :       }
 557 :       if (stan::math::logical_negation(emit_generated_quantities__)) {
 558 :         return ;
 559 :       }
 560 :     } catch (const std::exception& e) {
 561 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 562 :     }
 563 :   }
 564 :   template <typename VecVar, typename VecI,
 565 :             stan::require_vector_t<VecVar>* = nullptr,
 566 :             stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
 567 :   inline void
 568 :   unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
 569 :                          VecVar& vars__, std::ostream* pstream__ = nullptr) const {
 570 :     using local_scalar_t__ = double;
 571 :     stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
 572 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 573 :     int current_statement__ = 0;
 574 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 575 :     // suppress unused var warning
 576 :     (void) DUMMY_VAR__;
 577 :     try {
 578 :       int pos__ = std::numeric_limits<int>::min();
 579 :       pos__ = 1;
 580 :       local_scalar_t__ rho = DUMMY_VAR__;
 581 :       current_statement__ = 1;
 582 :       rho = in__.read<local_scalar_t__>();
 583 :       out__.write_free_lb(0, rho);
 584 :       local_scalar_t__ sigma = DUMMY_VAR__;
 585 :       current_statement__ = 2;
 586 :       sigma = in__.read<local_scalar_t__>();
 587 :       out__.write_free_lb(0, sigma);
 588 :       local_scalar_t__ tau = DUMMY_VAR__;
 589 :       current_statement__ = 3;
 590 :       tau = in__.read<local_scalar_t__>();
 591 :       out__.write_free_lb(0, tau);
 592 :       local_scalar_t__ theta = DUMMY_VAR__;
 593 :       current_statement__ = 4;
 594 :       theta = in__.read<local_scalar_t__>();
 595 :       out__.write(theta);
 596 :       local_scalar_t__ mu = DUMMY_VAR__;
 597 :       current_statement__ = 5;
 598 :       mu = in__.read<local_scalar_t__>();
 599 :       out__.write(mu);
 600 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 601 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 602 :       current_statement__ = 6;
 603 :       stan::model::assign(eps,
 604 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(K),
 605 :         "assigning variable eps");
 606 :       out__.write(eps);
 607 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 608 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 609 :       current_statement__ = 7;
 610 :       stan::model::assign(zeta,
 611 :         in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(C),
 612 :         "assigning variable zeta");
 613 :       out__.write(zeta);
 614 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 615 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 616 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 617 :       current_statement__ = 8;
 618 :       for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 619 :         current_statement__ = 8;
 620 :         for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 621 :           current_statement__ = 8;
 622 :           stan::model::assign(delta, in__.read<local_scalar_t__>(),
 623 :             "assigning variable delta", stan::model::index_uni(sym2__),
 624 :             stan::model::index_uni(sym1__));
 625 :         }
 626 :       }
 627 :       out__.write_free_lub(lowerbound, upperbound, delta);
 628 :     } catch (const std::exception& e) {
 629 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 630 :     }
 631 :   }
 632 :   template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
 633 :   inline void
 634 :   transform_inits_impl(const stan::io::var_context& context__, VecVar&
 635 :                        vars__, std::ostream* pstream__ = nullptr) const {
 636 :     using local_scalar_t__ = double;
 637 :     stan::io::serializer<local_scalar_t__> out__(vars__);
 638 :     int current_statement__ = 0;
 639 :     local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 640 :     // suppress unused var warning
 641 :     (void) DUMMY_VAR__;
 642 :     try {
 643 :       current_statement__ = 1;
 644 :       context__.validate_dims("parameter initialization", "rho", "double",
 645 :         std::vector<size_t>{});
 646 :       current_statement__ = 2;
 647 :       context__.validate_dims("parameter initialization", "sigma", "double",
 648 :         std::vector<size_t>{});
 649 :       current_statement__ = 3;
 650 :       context__.validate_dims("parameter initialization", "tau", "double",
 651 :         std::vector<size_t>{});
 652 :       current_statement__ = 4;
 653 :       context__.validate_dims("parameter initialization", "theta", "double",
 654 :         std::vector<size_t>{});
 655 :       current_statement__ = 5;
 656 :       context__.validate_dims("parameter initialization", "mu", "double",
 657 :         std::vector<size_t>{});
 658 :       current_statement__ = 6;
 659 :       context__.validate_dims("parameter initialization", "eps", "double",
 660 :         std::vector<size_t>{static_cast<size_t>(K)});
 661 :       current_statement__ = 7;
 662 :       context__.validate_dims("parameter initialization", "zeta", "double",
 663 :         std::vector<size_t>{static_cast<size_t>(C)});
 664 :       current_statement__ = 8;
 665 :       context__.validate_dims("parameter initialization", "delta", "double",
 666 :         std::vector<size_t>{static_cast<size_t>(C), static_cast<size_t>(2)});
 667 :       int pos__ = std::numeric_limits<int>::min();
 668 :       pos__ = 1;
 669 :       local_scalar_t__ rho = DUMMY_VAR__;
 670 :       current_statement__ = 1;
 671 :       rho = context__.vals_r("rho")[(1 - 1)];
 672 :       out__.write_free_lb(0, rho);
 673 :       local_scalar_t__ sigma = DUMMY_VAR__;
 674 :       current_statement__ = 2;
 675 :       sigma = context__.vals_r("sigma")[(1 - 1)];
 676 :       out__.write_free_lb(0, sigma);
 677 :       local_scalar_t__ tau = DUMMY_VAR__;
 678 :       current_statement__ = 3;
 679 :       tau = context__.vals_r("tau")[(1 - 1)];
 680 :       out__.write_free_lb(0, tau);
 681 :       local_scalar_t__ theta = DUMMY_VAR__;
 682 :       current_statement__ = 4;
 683 :       theta = context__.vals_r("theta")[(1 - 1)];
 684 :       out__.write(theta);
 685 :       local_scalar_t__ mu = DUMMY_VAR__;
 686 :       current_statement__ = 5;
 687 :       mu = context__.vals_r("mu")[(1 - 1)];
 688 :       out__.write(mu);
 689 :       Eigen::Matrix<local_scalar_t__,-1,1> eps =
 690 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(K, DUMMY_VAR__);
 691 :       {
 692 :         std::vector<local_scalar_t__> eps_flat__;
 693 :         current_statement__ = 6;
 694 :         eps_flat__ = context__.vals_r("eps");
 695 :         current_statement__ = 6;
 696 :         pos__ = 1;
 697 :         current_statement__ = 6;
 698 :         for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 699 :           current_statement__ = 6;
 700 :           stan::model::assign(eps, eps_flat__[(pos__ - 1)],
 701 :             "assigning variable eps", stan::model::index_uni(sym1__));
 702 :           current_statement__ = 6;
 703 :           pos__ = (pos__ + 1);
 704 :         }
 705 :       }
 706 :       out__.write(eps);
 707 :       Eigen::Matrix<local_scalar_t__,-1,1> zeta =
 708 :         Eigen::Matrix<local_scalar_t__,-1,1>::Constant(C, DUMMY_VAR__);
 709 :       {
 710 :         std::vector<local_scalar_t__> zeta_flat__;
 711 :         current_statement__ = 7;
 712 :         zeta_flat__ = context__.vals_r("zeta");
 713 :         current_statement__ = 7;
 714 :         pos__ = 1;
 715 :         current_statement__ = 7;
 716 :         for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 717 :           current_statement__ = 7;
 718 :           stan::model::assign(zeta, zeta_flat__[(pos__ - 1)],
 719 :             "assigning variable zeta", stan::model::index_uni(sym1__));
 720 :           current_statement__ = 7;
 721 :           pos__ = (pos__ + 1);
 722 :         }
 723 :       }
 724 :       out__.write(zeta);
 725 :       std::vector<Eigen::Matrix<local_scalar_t__,-1,1>> delta =
 726 :         std::vector<Eigen::Matrix<local_scalar_t__,-1,1>>(C,
 727 :           Eigen::Matrix<local_scalar_t__,-1,1>::Constant(2, DUMMY_VAR__));
 728 :       {
 729 :         std::vector<local_scalar_t__> delta_flat__;
 730 :         current_statement__ = 8;
 731 :         delta_flat__ = context__.vals_r("delta");
 732 :         current_statement__ = 8;
 733 :         pos__ = 1;
 734 :         current_statement__ = 8;
 735 :         for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 736 :           current_statement__ = 8;
 737 :           for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 738 :             current_statement__ = 8;
 739 :             stan::model::assign(delta, delta_flat__[(pos__ - 1)],
 740 :               "assigning variable delta", stan::model::index_uni(sym2__),
 741 :               stan::model::index_uni(sym1__));
 742 :             current_statement__ = 8;
 743 :             pos__ = (pos__ + 1);
 744 :           }
 745 :         }
 746 :       }
 747 :       out__.write_free_lub(lowerbound, upperbound, delta);
 748 :     } catch (const std::exception& e) {
 749 :       stan::lang::rethrow_located(e, locations_array__[current_statement__]);
 750 :     }
 751 :   }
 752 :   inline void
 753 :   get_param_names(std::vector<std::string>& names__, const bool
 754 :                   emit_transformed_parameters__ = true, const bool
 755 :                   emit_generated_quantities__ = true) const {
 756 :     names__ = std::vector<std::string>{"rho", "sigma", "tau", "theta", "mu",
 757 :                 "eps", "zeta", "delta"};
 758 :     if (emit_transformed_parameters__) {
 759 :       std::vector<std::string>
 760 :         temp{"tau_sqrt", "sigma_sqrt", "zeta_scale", "eps_scale"};
 761 :       names__.reserve(names__.size() + temp.size());
 762 :       names__.insert(names__.end(), temp.begin(), temp.end());
 763 :     }
 764 :     if (emit_generated_quantities__) {}
 765 :   }
 766 :   inline void
 767 :   get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
 768 :            emit_transformed_parameters__ = true, const bool
 769 :            emit_generated_quantities__ = true) const {
 770 :     dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
 771 :                 std::vector<size_t>{}, std::vector<size_t>{},
 772 :                 std::vector<size_t>{}, std::vector<size_t>{},
 773 :                 std::vector<size_t>{static_cast<size_t>(K)},
 774 :                 std::vector<size_t>{static_cast<size_t>(C)},
 775 :                 std::vector<size_t>{static_cast<size_t>(C),
 776 :                   static_cast<size_t>(2)}};
 777 :     if (emit_transformed_parameters__) {
 778 :       std::vector<std::vector<size_t>>
 779 :         temp{std::vector<size_t>{}, std::vector<size_t>{},
 780 :              std::vector<size_t>{static_cast<size_t>(C)},
 781 :              std::vector<size_t>{static_cast<size_t>(K)}};
 782 :       dimss__.reserve(dimss__.size() + temp.size());
 783 :       dimss__.insert(dimss__.end(), temp.begin(), temp.end());
 784 :     }
 785 :     if (emit_generated_quantities__) {}
 786 :   }
 787 :   inline void
 788 :   constrained_param_names(std::vector<std::string>& param_names__, bool
 789 :                           emit_transformed_parameters__ = true, bool
 790 :                           emit_generated_quantities__ = true) const final {
 791 :     param_names__.emplace_back(std::string() + "rho");
 792 :     param_names__.emplace_back(std::string() + "sigma");
 793 :     param_names__.emplace_back(std::string() + "tau");
 794 :     param_names__.emplace_back(std::string() + "theta");
 795 :     param_names__.emplace_back(std::string() + "mu");
 796 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 797 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 798 :         std::to_string(sym1__));
 799 :     }
 800 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 801 :       param_names__.emplace_back(std::string() + "zeta" + '.' +
 802 :         std::to_string(sym1__));
 803 :     }
 804 :     for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 805 :       for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 806 :         param_names__.emplace_back(std::string() + "delta" + '.' +
 807 :           std::to_string(sym2__) + '.' + std::to_string(sym1__));
 808 :       }
 809 :     }
 810 :     if (emit_transformed_parameters__) {
 811 :       param_names__.emplace_back(std::string() + "tau_sqrt");
 812 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
 813 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 814 :         param_names__.emplace_back(std::string() + "zeta_scale" + '.' +
 815 :           std::to_string(sym1__));
 816 :       }
 817 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 818 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 819 :           std::to_string(sym1__));
 820 :       }
 821 :     }
 822 :     if (emit_generated_quantities__) {}
 823 :   }
 824 :   inline void
 825 :   unconstrained_param_names(std::vector<std::string>& param_names__, bool
 826 :                             emit_transformed_parameters__ = true, bool
 827 :                             emit_generated_quantities__ = true) const final {
 828 :     param_names__.emplace_back(std::string() + "rho");
 829 :     param_names__.emplace_back(std::string() + "sigma");
 830 :     param_names__.emplace_back(std::string() + "tau");
 831 :     param_names__.emplace_back(std::string() + "theta");
 832 :     param_names__.emplace_back(std::string() + "mu");
 833 :     for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 834 :       param_names__.emplace_back(std::string() + "eps" + '.' +
 835 :         std::to_string(sym1__));
 836 :     }
 837 :     for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 838 :       param_names__.emplace_back(std::string() + "zeta" + '.' +
 839 :         std::to_string(sym1__));
 840 :     }
 841 :     for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
 842 :       for (int sym2__ = 1; sym2__ <= C; ++sym2__) {
 843 :         param_names__.emplace_back(std::string() + "delta" + '.' +
 844 :           std::to_string(sym2__) + '.' + std::to_string(sym1__));
 845 :       }
 846 :     }
 847 :     if (emit_transformed_parameters__) {
 848 :       param_names__.emplace_back(std::string() + "tau_sqrt");
 849 :       param_names__.emplace_back(std::string() + "sigma_sqrt");
 850 :       for (int sym1__ = 1; sym1__ <= C; ++sym1__) {
 851 :         param_names__.emplace_back(std::string() + "zeta_scale" + '.' +
 852 :           std::to_string(sym1__));
 853 :       }
 854 :       for (int sym1__ = 1; sym1__ <= K; ++sym1__) {
 855 :         param_names__.emplace_back(std::string() + "eps_scale" + '.' +
 856 :           std::to_string(sym1__));
 857 :       }
 858 :     }
 859 :     if (emit_generated_quantities__) {}
 860 :   }
 861 :   inline std::string get_constrained_sizedtypes() const {
 862 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"zeta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"zeta_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 863 :   }
 864 :   inline std::string get_unconstrained_sizedtypes() const {
 865 :     return std::string("[{\"name\":\"rho\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigma\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"tau\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"mu\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"eps\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"parameters\"},{\"name\":\"zeta\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"parameters\"},{\"name\":\"delta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(C) + ",\"element_type\":{\"name\":\"vector\",\"length\":" + std::to_string(2) + "}},\"block\":\"parameters\"},{\"name\":\"tau_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sigma_sqrt\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"zeta_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(C) + "},\"block\":\"transformed_parameters\"},{\"name\":\"eps_scale\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(K) + "},\"block\":\"transformed_parameters\"}]");
 866 :   }
 867 :   // Begin method overload boilerplate
 868 :   template <typename RNG> inline void
 869 :   write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
 870 :               Eigen::Matrix<double,-1,1>& vars, const bool
 871 :               emit_transformed_parameters = true, const bool
 872 :               emit_generated_quantities = true, std::ostream*
 873 :               pstream = nullptr) const {
 874 :     const size_t num_params__ = (((((((1 + 1) + 1) + 1) + 1) + K) + C) + (C *
 875 :       2));
 876 :     const size_t num_transformed = emit_transformed_parameters * ((((1 + 1) +
 877 :       C) + K));
 878 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 879 :     const size_t num_to_write = num_params__ + num_transformed +
 880 :       num_gen_quantities;
 881 :     std::vector<int> params_i;
 882 :     vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
 883 :              std::numeric_limits<double>::quiet_NaN());
 884 :     write_array_impl(base_rng, params_r, params_i, vars,
 885 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 886 :   }
 887 :   template <typename RNG> inline void
 888 :   write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
 889 :               params_i, std::vector<double>& vars, bool
 890 :               emit_transformed_parameters = true, bool
 891 :               emit_generated_quantities = true, std::ostream*
 892 :               pstream = nullptr) const {
 893 :     const size_t num_params__ = (((((((1 + 1) + 1) + 1) + 1) + K) + C) + (C *
 894 :       2));
 895 :     const size_t num_transformed = emit_transformed_parameters * ((((1 + 1) +
 896 :       C) + K));
 897 :     const size_t num_gen_quantities = emit_generated_quantities * (0);
 898 :     const size_t num_to_write = num_params__ + num_transformed +
 899 :       num_gen_quantities;
 900 :     vars = std::vector<double>(num_to_write,
 901 :              std::numeric_limits<double>::quiet_NaN());
 902 :     write_array_impl(base_rng, params_r, params_i, vars,
 903 :       emit_transformed_parameters, emit_generated_quantities, pstream);
 904 :   }
 905 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 906 :   log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
 907 :     Eigen::Matrix<int,-1,1> params_i;
 908 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 909 :   }
 910 :   template <bool propto__, bool jacobian__, typename T_> inline T_
 911 :   log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
 912 :            std::ostream* pstream = nullptr) const {
 913 :     return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
 914 :   }
 915 :   inline void
 916 :   transform_inits(const stan::io::var_context& context,
 917 :                   Eigen::Matrix<double,-1,1>& params_r, std::ostream*
 918 :                   pstream = nullptr) const final {
 919 :     std::vector<double> params_r_vec(params_r.size());
 920 :     std::vector<int> params_i;
 921 :     transform_inits(context, params_i, params_r_vec, pstream);
 922 :     params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
 923 :                  params_r_vec.size());
 924 :   }
 925 :   inline void
 926 :   transform_inits(const stan::io::var_context& context, std::vector<int>&
 927 :                   params_i, std::vector<double>& vars, std::ostream*
 928 :                   pstream__ = nullptr) const {
 929 :     vars.resize(num_params_r__);
 930 :     transform_inits_impl(context, vars, pstream__);
 931 :   }
 932 :   inline void
 933 :   unconstrain_array(const std::vector<double>& params_constrained,
 934 :                     std::vector<double>& params_unconstrained, std::ostream*
 935 :                     pstream = nullptr) const {
 936 :     const std::vector<int> params_i;
 937 :     params_unconstrained = std::vector<double>(num_params_r__,
 938 :                              std::numeric_limits<double>::quiet_NaN());
 939 :     unconstrain_array_impl(params_constrained, params_i,
 940 :       params_unconstrained, pstream);
 941 :   }
 942 :   inline void
 943 :   unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
 944 :                     Eigen::Matrix<double,-1,1>& params_unconstrained,
 945 :                     std::ostream* pstream = nullptr) const {
 946 :     const std::vector<int> params_i;
 947 :     params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
 948 :                              std::numeric_limits<double>::quiet_NaN());
 949 :     unconstrain_array_impl(params_constrained, params_i,
 950 :       params_unconstrained, pstream);
 951 :   }
 952 : };
 953 : }
 954 : using stan_model = modelb0e4552dd85b__namespace::modelb0e4552dd85b_;
 955 : #ifndef USING_R
 956 : // Boilerplate
 957 : stan::model::model_base&
 958 : new_model(stan::io::var_context& data_context, unsigned int seed,
 959 :           std::ostream* msg_stream) {
 960 :   stan_model* m = new stan_model(data_context, seed, msg_stream);
 961 :   return *m;
 962 : }
 963 : stan::math::profile_map& get_stan_profile_data() {
 964 :   return modelb0e4552dd85b__namespace::profiles__;
 965 : }
 966 : #endif
 967 : #endif
 968 : 
 969 : RCPP_MODULE(stan_fit4modelb0e4552dd85b__mod) {
 970 :   class_<rstan::stan_fit<stan_model, boost::random::ecuyer1988> >(
 971 :       "stan_fit4modelb0e4552dd85b_")
 972 : 
 973 :       .constructor<SEXP, SEXP, SEXP>()
 974 : 
 975 :       .method(
 976 :           "call_sampler",
 977 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::call_sampler)
 978 :       .method(
 979 :           "param_names",
 980 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_names)
 981 :       .method("param_names_oi",
 982 :               &rstan::stan_fit<stan_model,
 983 :                                boost::random::ecuyer1988>::param_names_oi)
 984 :       .method("param_fnames_oi",
 985 :               &rstan::stan_fit<stan_model,
 986 :                                boost::random::ecuyer1988>::param_fnames_oi)
 987 :       .method(
 988 :           "param_dims",
 989 :           &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::param_dims)
 990 :       .method("param_dims_oi",
 991 :               &rstan::stan_fit<stan_model,
 992 :                                boost::random::ecuyer1988>::param_dims_oi)
 993 :       .method("update_param_oi",
 994 :               &rstan::stan_fit<stan_model,
 995 :                                boost::random::ecuyer1988>::update_param_oi)
 996 :       .method("param_oi_tidx",
 997 :               &rstan::stan_fit<stan_model,
 998 :                                boost::random::ecuyer1988>::param_oi_tidx)
 999 :       .method("grad_log_prob",
1000 :               &rstan::stan_fit<stan_model,
1001 :                                boost::random::ecuyer1988>::grad_log_prob)
1002 :       .method("log_prob",
1003 :               &rstan::stan_fit<stan_model, boost::random::ecuyer1988>::log_prob)
1004 :       .method("unconstrain_pars",
1005 :               &rstan::stan_fit<stan_model,
1006 :                                boost::random::ecuyer1988>::unconstrain_pars)
1007 :       .method("constrain_pars",
1008 :               &rstan::stan_fit<stan_model,
1009 :                                boost::random::ecuyer1988>::constrain_pars)
1010 :       .method(
1011 :           "num_pars_unconstrained",
1012 :           &rstan::stan_fit<stan_model,
1013 :                            boost::random::ecuyer1988>::num_pars_unconstrained)
1014 :       .method(
1015 :           "unconstrained_param_names",
1016 :           &rstan::stan_fit<
1017 :               stan_model, boost::random::ecuyer1988>::unconstrained_param_names)
1018 :       .method(
1019 :           "constrained_param_names",
1020 :           &rstan::stan_fit<stan_model,
1021 :                            boost::random::ecuyer1988>::constrained_param_names)
1022 :       .method("standalone_gqs",
1023 :               &rstan::stan_fit<stan_model,
1024 :                                boost::random::ecuyer1988>::standalone_gqs);
1025 : }
1026 : 
1027 : 
1028 : // declarations
1029 : extern "C" {
1030 : SEXP fileb0e43cc7ba38( ) ;
1031 : }
1032 : 
1033 : // definition
1034 : SEXP fileb0e43cc7ba38() {
1035 :  return Rcpp::wrap("anon_model");
1036 : }
make cmd is
  make -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/etc/Makeconf' -f '/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/share/make/shlib.mk' -f '/home/melanson/.R/Makevars' CXX='$(CXX17) $(CXX17STD)' CXXFLAGS='$(CXX17FLAGS)' CXXPICFLAGS='$(CXX17PICFLAGS)' SHLIB_LDFLAGS='$(SHLIB_CXX17LDFLAGS)' SHLIB_LD='$(SHLIB_CXX17LD)' SHLIB='fileb0e43cc7ba38.so' OBJECTS='fileb0e43cc7ba38.o'

make would use
g++ -std=gnu++17 -I"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/include" -DNDEBUG   -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/Rcpp/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppEigen/include/unsupported"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/BH/include" -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/src/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/include/"  -I"/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_DISABLE_ASSERTS  -DBOOST_PENDING_INTEGER_LOG2_HPP  -DSTAN_THREADS  -DUSE_STANC3 -DSTRICT_R_HEADERS  -DBOOST_PHOENIX_NO_VARIADIC_EXPRESSION  -D_HAS_AUTO_PTR_ETC=0  -include '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/include/stan/math/prim/fun/Eigen.hpp'  -D_REENTRANT -DRCPP_PARALLEL_USE_TBB=1   -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/java/17.0.6/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include -I/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Core/flexiblascore/3.3.1/include/flexiblas    -fpic  -O2 -ftree-vectorize -march=x86-64-v3 -fno-math-errno  -c fileb0e43cc7ba38.cpp -o fileb0e43cc7ba38.o
if test  "zfileb0e43cc7ba38.o" != "z"; then \
  echo g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o fileb0e43cc7ba38.so fileb0e43cc7ba38.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
  g++ -std=gnu++17 -shared -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/lib"  -o fileb0e43cc7ba38.so fileb0e43cc7ba38.o  '/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/rstan/lib//libStanServices.a' -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/StanHeaders/lib/' -lStanHeaders -L'/home/melanson/R/x86_64-pc-linux-gnu-library/4.3/RcppParallel/lib/' -ltbb   -L"/cvmfs/soft.computecanada.ca/easybuild/software/2023/x86-64-v3/Compiler/gcccore/r/4.3.1/lib64/R/lib" -lR; \
fi

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1).

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2).

COMPILING MODEL 'anon_model' NOW.

STARTING SAMPLER FOR MODEL 'anon_model' NOW.

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3).

SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4).
Chain 1: 
Chain 1: Gradient evaluation took 0.083308 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 833.08 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 2: 
Chain 2: Gradient evaluation took 0.083616 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 836.16 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 3: 
Chain 3: Gradient evaluation took 0.081818 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 818.18 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 4: 
Chain 4: Gradient evaluation took 0.082082 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 820.82 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 3: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 1: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 2: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 4: Iteration:    1 / 4000 [  0%]  (Warmup)
Chain 1: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 4000 [ 10%]  (Warmup)
Chain 4: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 1: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 2: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 3: Iteration:  800 / 4000 [ 20%]  (Warmup)
Chain 4: Iteration: 1001 / 4000 [ 25%]  (Sampling)
Chain 1: Iteration: 1001 / 4000 [ 25%]  (Sampling)
Chain 2: Iteration: 1001 / 4000 [ 25%]  (Sampling)
Chain 3: Iteration: 1001 / 4000 [ 25%]  (Sampling)
Chain 4: Iteration: 1400 / 4000 [ 35%]  (Sampling)
Chain 1: Iteration: 1400 / 4000 [ 35%]  (Sampling)
Chain 2: Iteration: 1400 / 4000 [ 35%]  (Sampling)
Chain 3: Iteration: 1400 / 4000 [ 35%]  (Sampling)
Chain 4: Iteration: 1800 / 4000 [ 45%]  (Sampling)
Chain 1: Iteration: 1800 / 4000 [ 45%]  (Sampling)
Chain 2: Iteration: 1800 / 4000 [ 45%]  (Sampling)
Chain 3: Iteration: 1800 / 4000 [ 45%]  (Sampling)
Chain 4: Iteration: 2200 / 4000 [ 55%]  (Sampling)
Chain 1: Iteration: 2200 / 4000 [ 55%]  (Sampling)
Chain 2: Iteration: 2200 / 4000 [ 55%]  (Sampling)
Chain 3: Iteration: 2200 / 4000 [ 55%]  (Sampling)
Chain 4: Iteration: 2600 / 4000 [ 65%]  (Sampling)
Chain 1: Iteration: 2600 / 4000 [ 65%]  (Sampling)
Chain 2: Iteration: 2600 / 4000 [ 65%]  (Sampling)
Chain 3: Iteration: 2600 / 4000 [ 65%]  (Sampling)
Chain 4: Iteration: 3000 / 4000 [ 75%]  (Sampling)
Chain 1: Iteration: 3000 / 4000 [ 75%]  (Sampling)
Chain 2: Iteration: 3000 / 4000 [ 75%]  (Sampling)
Chain 3: Iteration: 3000 / 4000 [ 75%]  (Sampling)
Chain 4: Iteration: 3400 / 4000 [ 85%]  (Sampling)
Chain 1: Iteration: 3400 / 4000 [ 85%]  (Sampling)
Chain 2: Iteration: 3400 / 4000 [ 85%]  (Sampling)
Chain 3: Iteration: 3400 / 4000 [ 85%]  (Sampling)
Chain 4: Iteration: 3800 / 4000 [ 95%]  (Sampling)
Chain 1: Iteration: 3800 / 4000 [ 95%]  (Sampling)
Chain 2: Iteration: 3800 / 4000 [ 95%]  (Sampling)
Chain 3: Iteration: 3800 / 4000 [ 95%]  (Sampling)
Chain 4: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 4202.5 seconds (Warm-up)
Chain 4:                7898.46 seconds (Sampling)
Chain 4:                12101 seconds (Total)
Chain 4: 
Chain 1: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 4265.59 seconds (Warm-up)
Chain 1:                7877.15 seconds (Sampling)
Chain 1:                12142.7 seconds (Total)
Chain 1: 
Chain 2: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 4286.02 seconds (Warm-up)
Chain 2:                7897.77 seconds (Sampling)
Chain 2:                12183.8 seconds (Total)
Chain 2: 
Chain 3: Iteration: 4000 / 4000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 4449.53 seconds (Warm-up)
Chain 3:                7762.51 seconds (Sampling)
Chain 3:                12212 seconds (Total)
Chain 3: 
